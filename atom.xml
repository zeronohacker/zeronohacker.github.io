<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zeronohacker</title>
  
  <subtitle>零度非安全</subtitle>
  <link href="https://zeronohacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://zeronohacker.github.io/"/>
  <updated>2021-09-19T08:04:00.963Z</updated>
  <id>https://zeronohacker.github.io/</id>
  
  <author>
    <name>zeronohacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向分析商业软件 010 Editor 及注册机编写</title>
    <link href="https://zeronohacker.github.io/2019/05/28/reverse-analysis-of-business-software-010-editor-and-registration-machine-writing/"/>
    <id>https://zeronohacker.github.io/2019/05/28/reverse-analysis-of-business-software-010-editor-and-registration-machine-writing/</id>
    <published>2019-05-28T07:38:38.000Z</published>
    <updated>2021-09-19T08:04:00.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="010-Editor-简单介绍"><a href="#010-Editor-简单介绍" class="headerlink" title="010 Editor 简单介绍"></a>010 Editor 简单介绍</h2><p><code>010 Editor</code> 是一款非常强大的文本、十六进制编辑器，除了文本、十六进制编辑外，还包括文件解析、计算器、文件比较等功能，但它真正的强大之处还在于文件的解析功能。我们可以使用 <code>010Editor</code> 官方网站提供的解析脚本对 <code>avi、bmp、png、exe</code> 等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。但是 <code>010 Editor</code> 是收费的，不过官方给出了 30 天的免费使用期限供用户体验。本文将为大家分析如何去除使用限制和编写注册机。目前最新版本为 <code>v9.0.1</code>，也是本文将分析的版本。<code>010 Editor</code> 官网：<a href="http://www.sweetscape.com/010editor/">http://www.sweetscape.com/010editor/</a></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1m_KwL9zqK1RjSZFj762lCFXaL.png" alt=""></p><p>2 暴力破解分析</p><p>在软件破解中，暴力破解可谓是一个最基本，也是最常见的一种手段，无非就是改跳转指令（例如 JNZ 改 JZ、JZ 改 JNZ、把跳转指令 NOP 掉等），让它跳的时候不跳，不该跳的时候跳，从而避开检测以获取它的永久使用权限。下面就列下 <code>010 Editor</code> 暴力破解的分析步骤：</p><ul><li>找到注册窗口；</li><li>测试注册窗口的反应；</li><li>根据反应做出下一步分析的打算（猜测 API、API 下断动态调试、挑出敏感字符串，在程序中搜索）；</li><li>动态分析，定位关键跳转，修改代码；</li><li>动态分析，定位关键 CALL，修改代码；</li></ul><p>在官网下载最新版本并在你的计算机上安装好后，双击让它运行起来，并点击关于，会看到 <code>Free 30-Day Trial</code> 字样，另外，注册窗口在 <code>Tools --&gt; Register</code> ，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB12XKALVzqK1RjSZFo762fcXXaD.png" alt=""></p><p>点击 <code>Check License</code> 按钮，弹出如下提示：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1qpGrL9rqK1RjSZK9760yypXaY.png" alt=""></p><p>上述意思是你输入了一个无效的用户名或者是密码，也就是说，你点击那个按钮会弹出这个提示窗口，那么我们可以从这个提示窗口入手，比如对创建这个窗口的 API 下断，或者是寻找提示信息的这段字符串。废话不多说，上 OD，附加进程调试，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1ecqJLZfpK1RjSZFO7616nFXae.png" alt=""></p><p>附加后，我们需要来到主模块，点击 OD 上方的 <code>e</code> 按钮，点击第一个，这里需要重复操作两次才到主模块，完成上述操作后，我们先来看下程序主模块导入了哪些函数，<code>右键 -&gt; 查找 -&gt; 当前模块中的名称（标签）</code>，或者按下快捷键 <kbd>Ctrl</kbd> + <kbd>N</kbd>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1b2qAL3HqK1RjSZFP763wapXar.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1eECCL3HqK1RjSZFE763GMXXaq.png" alt=""></p><p>在上面图中可以看出 <code>010 Editor</code> 调用了大量的 Qt 库函数，由此可猜测它是由 Qt 编写的，对于 Qt 中创建窗口函数，个人觉得，不管是何种高级语言，在底层中还是得调用诸如 <code>CreateWindow、MessageBox</code> 以及一些 <code>Dialog</code> 相关的函数，这些函数位于 <code>User32.dll</code> 中，同样点击 OD 上方的小 <code>e</code> 按钮，在里面找到 <code>user32.dll</code>，双击进去，在这里要说一点就是，创建窗口的 API 函数不止一个，而且也不存在 <code>CreateWindow、MessageBox</code> 这类函数，其实它们只是个宏，在深入一点都是调用 <code>Ex</code> 的版本，那么问题又来了，是调用 <code>A 版</code> 还是调用 <code>W 版</code> 的，学过 windows 编程的都知道，<code>A 版</code> 的最终还是会去调用 <code>W 版</code> 的， 所以我们不妨先对 <code>CreateWindowExW</code> 函数下断，按 <kbd>Ctrl</kbd> + <kbd>G</kbd>，输入 <code>CreateWindowExW</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1W11DL7PoK1RjSZKb7601IXXa3.png" alt=""></p><p>转到这里后，对该地址下断，回到 <code>010 Editor</code> 注册界面，点击 <code>Check Lincense</code>，之后你会发现程序断下来了，这说明断点下对了，程序停在了 <code>0x74892480</code> 地址处。断下来之后，我们接下来要想的是哪里调用了这个函数，我们可以上方的 <code>k</code> 小按钮来查看，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1om1DLZbpK1RjSZFy760_qFXas.png" alt=""></p><p>通过栈回溯分析，可以看出，在地址 <code>0x00EFCD24</code> 上的函数过程有个很显眼的字 <code>show</code>，貌似跟显示窗口有关，我们双击进去看下里面有什么可以利用的信息，结果没发现有价值的东西，不要慌，我们继续点击上面这个地址的下一个地址，双击进行查看，结果也没有，再跟进去下一个地址，也就是 <code>0x00EFCDFC</code> 处，双击进去，会发现如下这种情况：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB17deAL8LoK1RjSZFu760n0XXa1.png" alt=""></p><p>通过上图可以看出，在这里面出现了大量可疑的字符串，其中 <code>Invalid name or password......</code> 这个字符串就是我们随意输入用户名和密码时弹出的信息提示，该处为一个 <code>push</code> 指令，我们向上看会发现该处是由 <code>0x1DE8489</code> 处跳转过来的，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1S_5PLZfpK1RjSZFO7616nFXaO.png" alt=""></p><p>不妨在 <code>0x1DE8489</code> 处下断点，把之前的断点禁用或者删除，回到注册界面，点击 <code>Check License</code>，会发现在该处断下来了，F8 一下就跳到无效密码处，在该 JNZ 指令上有三组 CMP 指令，并且第一组 CMP 指令是从地址 <code>0x01DE8336</code> 处跳转过来的，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Qzq1L7voK1RjSZFw763iCFXaI.png" alt=""></p><p>我们来到第一组 CMP 指令源跳转处，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1zrzgL4jaK1RjSZKz760VwXXaH.png" alt=""></p><p>我们不妨在上面处下个断，重新回到注册界面，点击 <code>Check License</code>，会发现它会断在刚下的这个断点处，按 F8 下去，你会发现有两个关键的地方，一个是 <code>EDI</code> 的值，一个是 <code>EBX</code> 的值，前者需要和 <code>0xDB</code> 这个值作比较，后者则需要跟 <code>0xE7</code> 这个值作比较，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1mRr0MwTqK1RjSZPh760fOFXar.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1boL9MpzqK1RjSZFo762fcXXam.png" alt=""></p><p>这些值都是来自于 <code>EAX</code> 的赋值，而我们知道，<code>EAX</code> 寄存器存放的是函数的返回值，所以我们需要跟进函数里头去看下返回值是如何返回的，但现不急着跟进去，因为现在是暴力破解它，所以我们只需将地址 <code>0x019D8336</code> 处的 JNZ 指令给 NOP 掉即可，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB14ZvHMIfpK1RjSZFO7616nFXaT.png" alt=""></p><p>最后保存文件即可，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1MM2pMSrqK1RjSZK9760yypXaL.png" alt=""></p><p>双击运行 Dump 出来的文件，点击 <code>Check License</code> 会发现弹出如下提示：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>点击 <code>OK</code> 就可以进入到主界面了，这样就达到了暴力破解的目的了，但是这种方法对于这个软件来说有一点不好的地方的就是每次运行都会弹出这个注册界面，需再次点击 <code>Check License</code>，这样才能够使用。我们能不能双击直接进入呢？答案肯定能，我们重新理一下整个过程，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>如果 EBX 为 0xE7 则跳，跳过之后，再对 EDI 比较，此时 EDI 为 0x177，0x177 不等于 0xDB 又跳走，接着有两次对 EDI 进行比较，值分别为 0xED 和 0x20C，我们知道，EDI 值为 0x177，所以两处的 JE 指令不成立，最后对比 EBX 的值，用它跟 0x93 对比，很明显 0xE7 不等于 0x93，所以 JNZ 指令成立，将跳过密码已被接受过程。</p><p>所以为了一开始不跳，<code>EBX</code> 的值要不为 <code>0xE7</code>，<code>EDI</code> 的值要为 <code>0xDB</code>，在上面谈到的两个重要的 CALL 里，第二个 CALL 是根据第一个 CALL 的最终 <code>EAX</code> 的来进行对 <code>EDI</code> 进行赋值，所以，为了让 <code>EDI</code> 的值为 <code>0xDB</code>，<code>EBX</code> 的值要为 <code>0x2D</code>，也就是说第一个 CALL 的最终 <code>EAX</code> 值要为 <code>0x2D</code>，我们可以跟进第一个 CALL 内，在最开头部分写下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x2D</span><br></pre></td></tr></table></figure><p>如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>修改完后，会发现下一条指令的 <code>OPCODE</code> 下有一根下划线，这说明需要重定位，下次再运行时可能就不是这个地址了，所以我们需要做的就是把软件的重定位标志置为 0 保存即可，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1_W_QMMHqK1RjSZFE763GMXXaO.png" alt=""></p><p>重新运行 OD，将其载入，在最开头部分写下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x2D</span><br><span class="line">retn 0x8</span><br></pre></td></tr></table></figure><p>如下所示：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1p9fSMQPoK1RjSZKb7601IXXaE.png" alt=""></p><p>最后 Dump 出来，双击运行下看是否成功，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1t6LGMMDqK1RjSZSy761xEVXaY.png" alt=""></p><p>由此可见，我们已成功完美破解了 <code>010 Editor</code> 了，尽情享用吧！</p><h2 id="初步分析算法"><a href="#初步分析算法" class="headerlink" title="初步分析算法"></a>初步分析算法</h2><p>在这小节当中，会对 <code>010 Editor</code> 注册算法进行详细分析。回顾上一小节，我们只是修改了一个跳转，但关键点还是在于那两个重要的 CALL，尤其是第一个 CALL，必须让它返回 <code>0x2D</code> 才是正确的，所以本小节将会跟进第一个关键 CALL 内去分析注册算法。在跟进之前，我们先来看下这个 CALL 有哪些参数，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1UyOaM7voK1RjSZFw763iCFXan.png" alt=""></p><p>我们知道，<code>ECX</code> 传参为 this 指针，后面两个分别为 <code>0x4596</code> 和 <code>0xA</code>，传的参肯定和用户名和密码有关系，我们不妨跟进 <code>ECX</code> 地址所在处数据窗口，<code>ECX</code> 的值为 <code>0330B300</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1dnx9M3HqK1RjSZFg7617JXXag.png" alt=""></p><p>从上图可知，这个 this 指针应该是指向一个字符串数组，接着我们需进入到地址 <code>0330B304</code> 处，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1WBOhM7voK1RjSZFw763iCFXa7.png" alt=""></p><p>在这里我们需要转化成 <code>Unicode 16 位</code> 查看，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1wIt8M8LoK1RjSZFu760n0XXap.png" alt=""></p><p>注意地址的对应，从上图可知，这个字符串就是我们输入的用户名 <code>fanfanblog.cn</code>，我们返回到 this 指针下的第二个地址处跟进到数据窗口看下，也是同样的操作，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>同样地，注意地址的对应，在这一段为你输入的密码，也可叫做序列号。知道这些后，对后面分析有一定帮助。我们跟进去第一个重要 CALL 内，以下作了一个简单的分析：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Dx1DM4jaK1RjSZKz760VwXXaL.png" alt=""></p><p>由上面分析知，<code>ECX</code> 存放的是 this 指针，而 this 指针指向的是一个字符串数组，这个数组存放着用户名和密码字符串，我已将说明标注在上图中。所以为什么说之前我们需要跟进 <code>ECX</code> 中的数据窗口去查看下这个地址里存放的是什么东西，那么在上图分析过程中起到一个辅助作用。</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1aDOcM9zqK1RjSZPx7634tVXav.png" alt=""></p><p>在检测用户名和密码是否为空后，紧接着将一个局部变量的值压和栈中，右键栈中的地址数据窗口跟随，会发现这个数据是你输入的密码字符串，而且为 16 进制，所以说 PUSH 指令下的这个 CALL，是将密码字符串转为 16 进制字节的数据。如果你不放心，可以多测试几下，这里把密码换成 <code>1234-5678-9009-8765-4321</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1viCoM9zqK1RjSZFp761kSXXav.png" alt=""></p><p>我们接着分析，在接下来，程序会将字符串 <code>999</code> 压入栈中进行一番不知什么操作，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB13qMFM4jaK1RjSZKz760VwXXaZ.png" alt=""></p><p>这一段并没有对用户名和密码字符串进行操作，所以不去深究它也无太大影响，在逆向分析中，并不是每条都分析一遍你才能破解它，而是找到关键部分进行分析，这一小段为一个小循环，这个 CALL，根据提示，应该 Qt 中运算符重载，由于对 Qt 不是很熟悉，而且这小段并未对用户名和密码进行操作，所以跳过它往下继续分析。从循环开始，那就是真正的到达算法处，算法并不是很难，但是有一点绕，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1gBAgM9zqK1RjSZFH7623CpXaT.png" alt=""></p><p>在上图中，有几个关键点地方，第一个圈起来的，它会拿你输入的密码的第 4 组数据去和 <code>0x9C、0xAC、0xFC</code> 这三个数进行比较，如果不是这三个数中的其中一个，那么程序会将 <code>0xE7</code> 赋值给 <code>EAX</code>，而在前面一小节当中，<code>EAX</code> 的值不能为 <code>0XE7</code>，否则失败，所以我们令 JNZ 下方这条指令为新的 EIP，否则 JNZ 条件成立跳过去了，就不好分析了，最后我们可以肯定，密码有三个版本，这里只分析下 <code>0x9C</code> 这个版本。第二个关键点是第二个圈起来的地方，跟进这个 CALL 里，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1eP.cM6DpK1RjSZFr76178VXaU.png" alt=""></p><p>同样，代码也不复杂，主要是判断余数是否为 0，如果为 0，那么就返回商，如果不为 0，那么就返回 0。所以这么一整段下来，在对 <code>k[0]、k[1]、k[2]、k[3]、k[4]、k[5]、k[6]、k[7]</code> 在进行操作，而我们输入的密码有 10 组，OD 中并没看到对 <code>k[8]、k[9]</code> 进行处理，其实这里有个关子，那就是当你密码中第 4 组数据为 <code>0x9C</code>，那么生成的密码并没有 10 组，而是 8 组，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Lz3EM3HqK1RjSZFk760.WFXa1.png" alt=""></p><p>但不管怎么说，在 <code>0x9C</code> 情况下对每组数据进行异或、相加、与等操作，我们不妨先建立下注册机模型，我这里用的是 MFC 进行编写，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1Uy6ZM9zqK1RjSZPc762TepXa1.png" alt=""></p><p>在 <code>Generate</code> 生成按钮添加单击事件，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy010EditorRegisterDlg::OnBnClickedButtonGenerate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    m_edit_password.<span class="built_in">SetWindowText</span>(<span class="string">L&quot;&quot;</span>);</span><br><span class="line">    CString str;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    BYTE k[<span class="number">8</span>] = &#123; <span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x9C</span>,<span class="number">0x90</span>,<span class="number">0x09</span>,<span class="number">0x87</span>,<span class="number">0x65</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        BYTE k0 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k6 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        <span class="comment">// AL = (k[0]^k[6]^0x18 + 0x3D)^0xA7</span></span><br><span class="line">        BYTE AL = (k0 ^ k6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line">        <span class="keyword">if</span> (AL &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k[<span class="number">0</span>] = k0;</span><br><span class="line">            k[<span class="number">6</span>] = k6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ESI = (0x100*(k[1]^k[7] &amp; 0xFF) + k[2]^k[5] &amp; 0xFF)&amp;0xFFFF</span></span><br><span class="line">    <span class="comment">// EAX = ((ESI^0x7892+0x4D30)^0x3421)&amp;0xFFFF / 0xB</span></span><br><span class="line">    <span class="comment">// 判断余数是否为0，为0返回商，不为0返回0</span></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        BYTE k1 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k7 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k2 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">        BYTE k5 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">        DWORD ESI = (<span class="number">0x100</span> * (k1 ^ k7 &amp; <span class="number">0xFF</span>) + k2 ^ k5 &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        DWORD EAX = (((ESI ^ <span class="number">0x7892</span>) + <span class="number">0x4D30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="keyword">if</span> (EAX % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; EAX / <span class="number">0xB</span> &lt;= <span class="number">0x3E8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k[<span class="number">1</span>] = k1;</span><br><span class="line">            k[<span class="number">7</span>] = k7;</span><br><span class="line">            k[<span class="number">2</span>] = k2;</span><br><span class="line">            k[<span class="number">5</span>] = k5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.<span class="built_in">Format</span>(<span class="string">L&quot;%02x%02x-%02x%02x-%02x%02x-%02x%02x&quot;</span>, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>], k[<span class="number">3</span>], k[<span class="number">4</span>], k[<span class="number">5</span>], k[<span class="number">6</span>], k[<span class="number">7</span>]);</span><br><span class="line">    m_edit_password.<span class="built_in">SetWindowText</span>(str.<span class="built_in">MakeUpper</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码只是让你遇到那两个 JE 和一个 JA 跳转指令可以使它不成立，这个雏形生成的密码并没有与用户名进行关联，在下一小节当中会分析密码与用户名的之间的联系。</p><h2 id="深入分析算法"><a href="#深入分析算法" class="headerlink" title="深入分析算法"></a>深入分析算法</h2><p>在上一小节当中，通过穷举法来找出符合要求的密码。下面将会为大家分析下用户名和密码之间的关系。</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1o_VeNkvoK1RjSZFN763xMVXap.png" alt=""></p><p>咱继续，接下来这一小段将 <code>ECX</code> 与 <code>0x2</code> 进行对比，其实好像也没什么用，我们看 JMP 跳转后的指令，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>这一段主要是将用户名的字符串转为 <code>ASCII</code> 版，在接下来的一个调用 CALL 后，<code>EAX</code> 中为用户名字符串地址，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1RVufae3tHKVjSZSg7604QFXau.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1jMFRNhnaK1RjSZFt762C2VXan.png" alt=""></p><p>在上图中的 <code>ds:[edi+0x1C]</code> 处其实是前面处理 <code>k[0] 和 k[6]</code> 那个 CALL 后的返回值（即 <code>AL</code> 的值），所以我们需要将代码中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (AL &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    k[<span class="number">0</span>] = k0;</span><br><span class="line">    k[<span class="number">6</span>] = k6;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (AL &gt; <span class="number">0xA</span>)</span><br><span class="line">&#123;</span><br><span class="line">    k[<span class="number">0</span>] = k0;</span><br><span class="line">    k[<span class="number">6</span>] = k6;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是要做的就是那个对用户名处理的 CALL，通过分析知道，这个 CALL 的返回值类似于哈希值，我们需要得到这个值，回为这个值需要和 <code>k[4]、k[5]、k[6]、k[7]</code> 发生关系，我们不妨声明这样一个函数，用来处理 <code>ASCII</code> 码版的用户名字符串，这里有个取巧的办法，那就是利用 IDA，将 <code>010 Editor</code> 载入 IDA 中，我们需要先获取处理这个用户名字符串的 CALL 的地址，这个地址可以通过 OD 找到，找到之后，切换到 IDA，按 <code>g</code> 输入地址回车，再按下 <code>F5</code> 进行翻译，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1JdJwNgHqK1RjSZFg7617JXXaW.png" alt=""></p><p>大致浏览一下，并不是太复杂，其中用到了一个数组，也就是上图圈出来的，双击进去，如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>这里显示的比较乱，我们可把地址 <code>02EDD840</code> 转到 OD 里查看，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1leRBNa6qK1RjSZFm7600PFXaP.png" alt=""></p><p>利用 OD 的插件将这一段进行数据转换并以 C++ 形式复制出来，并将其命名为 <code>dwEncodeArray</code>，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1CMaQae3tHKVjSZSg7604QFXa8.png" alt=""></p><p>并将原来的代码做下调整，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成密码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy010EditorRegisterDlg::OnBnClickedButtonGenerate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="comment">// 先判断用户名输入是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(m_edit_name.<span class="built_in">GetWindowTextLength</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_edit_password.<span class="built_in">SetWindowText</span>(<span class="string">L&quot;&quot;</span>);</span><br><span class="line">        CString str;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> nRet = <span class="number">0x3E8</span>;</span><br><span class="line">        BYTE k[<span class="number">8</span>] = &#123; <span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x9C</span>,<span class="number">0x90</span>,<span class="number">0x09</span>,<span class="number">0x87</span>,<span class="number">0x65</span> &#125;;</span><br><span class="line">        m_edit_name.<span class="built_in">GetWindowText</span>(str);</span><br><span class="line">        <span class="function">CStringA <span class="title">stra</span><span class="params">(str.GetBuffer(<span class="number">0</span>))</span></span>;</span><br><span class="line">        str.<span class="built_in">ReleaseBuffer</span>();</span><br><span class="line">        <span class="function">string <span class="title">st</span><span class="params">(stra.GetBuffer(<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cs = st.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="comment">// 用户名进行加密</span></span><br><span class="line">        DWORD dwKey = <span class="built_in">EncodeUserName</span>(cs, <span class="number">1</span>, <span class="number">0</span>, nRet);</span><br><span class="line">        <span class="comment">// CMP k[4],RetValue&amp;0xFF</span></span><br><span class="line">        <span class="comment">// CMP k[5],RetValue&gt;&gt;8&amp;0xFF</span></span><br><span class="line">        <span class="comment">// CMP k[6],RetValue&gt;&gt;16&amp;0xFF</span></span><br><span class="line">        <span class="comment">// CMP k[7],RetValue&gt;&gt;24&amp;0xFF</span></span><br><span class="line">        k[<span class="number">4</span>] = dwKey &amp; <span class="number">0xFF</span>;</span><br><span class="line">        k[<span class="number">5</span>] = dwKey &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">        k[<span class="number">6</span>] = dwKey &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">        k[<span class="number">7</span>] = dwKey &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            BYTE k0 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">            BYTE k6 = k[<span class="number">6</span>];</span><br><span class="line">            <span class="comment">// AL = (k[0]^k[6]^0x18 + 0x3D)^0xA7</span></span><br><span class="line">            BYTE AL = (k0 ^ k6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line">            <span class="keyword">if</span> (AL &gt; <span class="number">0xA</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k[<span class="number">0</span>] = k0;</span><br><span class="line">                k[<span class="number">6</span>] = k6;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ESI = (0x100*(k[1]^k[7] &amp; 0xFF) + k[2]^k[5] &amp; 0xFF)&amp;0xFFFF</span></span><br><span class="line">        <span class="comment">// EAX = ((ESI^0x7892+0x4D30)^0x3421)&amp;0xFFFF / 0xB</span></span><br><span class="line">        <span class="comment">// 判断余数是否为0，为0返回商，不为0返回0</span></span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            BYTE k1 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">            BYTE k7 = k[<span class="number">7</span>];</span><br><span class="line">            BYTE k2 = <span class="built_in">rand</span>() % <span class="number">0xFF</span>;</span><br><span class="line">            BYTE k5 = k[<span class="number">5</span>];</span><br><span class="line">            DWORD ESI = (<span class="number">0x100</span> * (k1 ^ k7 &amp; <span class="number">0xFF</span>) + k2 ^ k5 &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">            DWORD EAX = (((ESI ^ <span class="number">0x7892</span>) + <span class="number">0x4D30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">            <span class="keyword">if</span> (EAX % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; EAX / <span class="number">0xB</span> == <span class="number">0x3E8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k[<span class="number">1</span>] = k1;</span><br><span class="line">                k[<span class="number">7</span>] = k7;</span><br><span class="line">                k[<span class="number">2</span>] = k2;</span><br><span class="line">                k[<span class="number">5</span>] = k5;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        str.<span class="built_in">Format</span>(<span class="string">L&quot;%02x%02x-%02x%02x-%02x%02x-%02x%02x&quot;</span>, k[<span class="number">0</span>], k[<span class="number">1</span>], k[<span class="number">2</span>], k[<span class="number">3</span>], k[<span class="number">4</span>], k[<span class="number">5</span>], k[<span class="number">6</span>], k[<span class="number">7</span>]);</span><br><span class="line">        m_edit_password.<span class="built_in">SetWindowText</span>(str.<span class="built_in">MakeUpper</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="string">L&quot;Please enter name&quot;</span>, <span class="string">L&quot;warning&quot;</span>, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EncodeUserName</code> 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">CMy010EditorRegisterDlg::EncodeUserName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">char</span> a3, <span class="keyword">unsigned</span> __int16 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// edx</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// edi</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v7; <span class="comment">// bl</span></span><br><span class="line">    <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> v9; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">int</span> v10; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v12; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v13; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [esp+10h] [ebp-8h]</span></span><br><span class="line">    <span class="keyword">int</span> v15; <span class="comment">// [esp+14h] [ebp-4h]</span></span><br><span class="line">    v4 = a1;</span><br><span class="line">    v15 = <span class="number">0</span>;</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v5 &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v12 = <span class="number">0</span>;</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    v7 = <span class="number">15</span> * a4;</span><br><span class="line">    v14 = <span class="number">17</span> * a3;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="built_in">toupper</span>((<span class="keyword">unsigned</span> __int8)v4[v6]);</span><br><span class="line">        v9 = v15 + dwEcodeArray[v8];</span><br><span class="line">        <span class="keyword">if</span> (a2)</span><br><span class="line">            v10 = dwEcodeArray[v13]</span><br><span class="line">            + dwEcodeArray[v7]</span><br><span class="line">            + dwEcodeArray[v14]</span><br><span class="line">            + dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">47</span>)] * (dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">13</span>)] ^ v9);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v10 = dwEcodeArray[v12]</span><br><span class="line">            + dwEcodeArray[v7]</span><br><span class="line">            + dwEcodeArray[v14]</span><br><span class="line">            + dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">23</span>)] * (dwEcodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">63</span>)] ^ v9);</span><br><span class="line">        result = v10;</span><br><span class="line">        v15 = v10;</span><br><span class="line">        v13 += <span class="number">19</span>;</span><br><span class="line">        ++v6;</span><br><span class="line">        v14 += <span class="number">9</span>;</span><br><span class="line">        v7 += <span class="number">13</span>;</span><br><span class="line">        v12 += <span class="number">7</span>;</span><br><span class="line">        v4 = a1;</span><br><span class="line">    &#125; <span class="keyword">while</span> (v6 &lt; v5);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB146JTNkvoK1RjSZFN763xMVXaA.png" alt=""></p><p>这样就达到了任意用户名注册！</p><h2 id="去除网络验证"><a href="#去除网络验证" class="headerlink" title="去除网络验证"></a>去除网络验证</h2><p>已加去除网络验证这一小节，今天在打开 <code>010 Editor</code> 时，发现它弹出如下界面：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1d4CJNpzqK1RjSZFv763B7VXao.png" alt=""></p><p>出现这种情况是 <code>010 Editor</code> 会把该密码上传到它的服务器，如果发现不是通过正常渠道获取得的密码，它会把这个密码拉黑，出现上述这种情况你也不要慌，接下来我会为大家分析怎么来去除网络验证。</p><p>打开 OD，把 <code>010 Editor</code> 拖进来，<code>F9</code> 运行起来，点击 <code>Check License</code>，会断在如下地方：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1nVWCNrPpK1RjSZFF7615PpXas.png" alt=""></p><p>因为之前下的断点我并没删除，<code>F8</code> 来到 <code>00E08229</code> 处，如果按照正常来说，在调用完这两个 CALL 后，<code>EAX</code> 中的值要为 <code>0xDB</code>，而此时变成了 <code>0x113</code>，第一个 CALL 调用后，<code>EAX</code> 的值为 <code>0x2D</code>，这个没问题，那么问题可能出现在第二个 CALL 内，这个 CALL 本应该把 <code>EAX</code> 的值修改为 <code>0xDB</code>，而它去却把它修改成了 <code>0x113</code>，我们不妨跟进这个 CALL 内，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB15hW9NxjaK1RjSZKz760VwXXa6.png" alt=""></p><p><code>F8</code> 运行到此处后，发现此处的 JE 指令跳转不成功，接下来的 <code>mov eax,0x113</code> 代码将被执行并返回，所以需将 JE 指令改为 JMP，改完之后，该 CALL 最后返回 <code>0xDB</code>，而不是 <code>0x113</code>，在后面你会发现即使修改了这处，它还是一样会验证失败，原因如下：</p><div class="tip "><p>提示：由于此文写的比较早，当时上传的图是使用免费图床，官方会不时清理免费用户的图，所以导致缺失。</p></div><p>这个 JNS 指令它会跳到失败处，也就是那个字符串提示你的密码已被删除，注意图中的 <code>EAX</code> 的值，它为 -1，同时，在运行 <code>00E0824B</code> 的 CALL 指令会卡一下，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB1vGCQNq6qK1RjSZFm7600PFXa0.png" alt=""></p><p>整个注册界面会变灰，这时它在调用这个 CALL 进行网络验证，需要等待一下，等它验证完后，<code>EAX</code> 的值变会变成 -1，从而使得 JNS 指令成立，所以解决的办法是进入到网络验证这个 CALL 内，把 <code>EAX</code> 的值修改成不是负数，在这我把它改成 1，如下：</p><p><img src="https://image.zeronohacker.com/article/2019/05/28/HTB190G2NxYaK1RjSZFn76180pXa7.png" alt=""></p><p><code>ret</code> 多少，可以向下滑，看它正常 <code>ret</code> 多少，你这里也 <code>ret</code> 多少，最后 Dump 出来覆盖原文件就可以了，注册机还是不变，只要你从官网下载 32 位版的 <code>010 Editor</code> 并安装在你计算机后，运行注册机后注册即可，以后就不用担心拉黑了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;010-Editor-简单介绍&quot;&gt;&lt;a href=&quot;#010-Editor-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;010 Editor 简单介绍&quot;&gt;&lt;/a&gt;010 Editor 简单介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;010 Editor&lt;/</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="010 Editor" scheme="https://zeronohacker.github.io/tags/010-Editor/"/>
    
    <category term="逆向破解" scheme="https://zeronohacker.github.io/tags/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>手工打造 PE 解析器之区块表</title>
    <link href="https://zeronohacker.github.io/2018/12/25/manually-build-the-block-table-of-the-pe-parser/"/>
    <id>https://zeronohacker.github.io/2018/12/25/manually-build-the-block-table-of-the-pe-parser/</id>
    <published>2018-12-25T07:26:22.000Z</published>
    <updated>2021-09-19T07:33:10.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在 NT 头结束后，紧接着就是区块表，区块表用来描述位于其后各个区块的各种属性，PE 文件最少要有一个区块才能被加载运行。</p><h2 id="区块表"><a href="#区块表" class="headerlink" title="区块表"></a>区块表</h2><p>区块表是一个 IMAGE_SECTION_HEADER 结构数组，这个结构包含区块的信息，比如位置、长度、属性等，区块的数目是由 NT 头中的文件头里的 NumberOfSections 给出。以下为 IMAGE_SECTION_HEADER 结构：</p><p><img src="https://image.zeronohacker.com/article/2018/12/25/152750rzsnk49xzic4fc3k.png" alt=""></p><p>在上述图中，有两个字段比较重要，分别为 VirtualAddress、PointerToRawData，这两个字段用于将相对虚拟地址或虚拟地址转换为文件偏移地址，以下为 RVA 转 FOA 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RVA 转 FOA</span></span><br><span class="line"><span class="function">DWORD <span class="title">RVAtoFOA</span><span class="params">(DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取区段表的数量</span></span><br><span class="line">    DWORD dwCounts = g_NtHeader-&gt;FileHeader.NumberOfSections;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取区段表数组的首元素</span></span><br><span class="line">    <span class="keyword">auto</span> Sections = <span class="built_in">IMAGE_FIRST_SECTION</span>(g_NtHeader);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历所有的区段表找到符合要求的区段</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwCounts; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要求：RVA &gt;= 区段的首地址 并且 RVA &lt; 区段的结尾的地址</span></span><br><span class="line">        <span class="keyword">if</span> (dwRva &gt;= Sections[i].VirtualAddress &amp;&amp;</span><br><span class="line">            dwRva &lt; (Sections[i].VirtualAddress + Sections[i].SizeOfRawData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// FOA = VA - ImageBase - （所在区段的 RVA - 所在区段的 FOA）</span></span><br><span class="line">            <span class="comment">// FOA = RVA - 所在区段的 RVA + 所在区段的 FOA</span></span><br><span class="line">            <span class="keyword">return</span> dwRva - Sections[i].VirtualAddress + Sections[i].PointerToRawData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果找不到就返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip "><p>计算公式：FOA = VA – ImageBase – (所在区段的 RVA – 所在区段的 FOA) 或 FOA = RVA – 所在区段的 RVA + 所在区段的 FOA </p></div><p>在上述代码中，有一个为 IMAGE_FIRST_SECTION，我们来看下它的定义，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/25/152838k3ppyv1n1w2y3vjj.png" alt=""></p><p>其实 IMAGE_FIRST_SECTION 为一个宏，它主要由三部分相加组成，作用是获取到第一个区段的首地址，参数为 NT 头。你可以把这个首地址理解成数组名，数组的首地址。在获取到了地址后，下面的 for 循环遍历所有的区段表找到符合要求的区段。这三部分内容具体如下：</p><ul><li>IMAGE_NT_HEADERS 的起始地址</li><li>IMAGE_OPTIONAL_HEADER32 （PE 扩展头）在 IMAGE_NT_HEADERS 中的偏移</li><li>IMAGE_OPTIONAL_HEADER32 的大小</li></ul><p>其中后两个加起来的大小恰好就是 IMAGE_NT_HEADERS 的大小，再跟第一个相加就得到区段表的地址了。看到这你可以会问，为什么不直接加上 IMAGE_NT_HEADERS 的大小呢？因为 IMAGE_OPTIONAL_HEADER32 大小不固定，32 位下该值为 0x00E0H，64 位下该值为 0x00F0H，并且用户还可以自定义其大小。</p><h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><p>扩展头大小是由文件头中 SizeOfOptionalHeader 字段给出，FIELD_OFFSET 这个是给出 OptionalHeader 在 IMAGE_NT_HEADERS 结构中的偏移，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/25/152910udjjjs8rdg8pcqq8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;在 NT 头结束后，紧接着就是区块表，区块表用来描述位于其后各个区块的各种属性，PE 文件最少要有一个区块才能被加载运行。&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="PE" scheme="https://zeronohacker.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>手工打造 PE 解析器之 DOS 头和 NT 头</title>
    <link href="https://zeronohacker.github.io/2018/12/24/manually-build-the-dos-header-and-nt-header-of-the-pe-parser/"/>
    <id>https://zeronohacker.github.io/2018/12/24/manually-build-the-dos-header-and-nt-header-of-the-pe-parser/</id>
    <published>2018-12-24T07:00:38.000Z</published>
    <updated>2021-09-19T07:23:49.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>可执行文件格式是操作系统本身执行机制的反映，理解它有助于对操作系统的深刻理解，掌握可执行文件的数据结构及其一些机理，是研究软件安全的必修课。PE (Portable Executable File Format) 是目前 windows 平台上的主流可执行文件格式。PE 文件衍生于早期的 COFF 文件格式，描述 PE 格式及 COFF 文件的主要地方在 winnt.h 这个头文件，其中有一节叫 Image Format，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100550eewmdrffq2e5fnq5.png" alt=""></p><p>该节给出了 DOS MZ 格式和 windows 3.1 的 NE 格式文件头，之后就是 PE 文件的内容，在这个头文件中，几乎能找到关于 PE 文件的每一个数据结构的定义、枚举类型、常量定义。winnt.h 这个头文件是 PE 文件定义的最终决定者。DLL 和 EXE 文件之间的区别完全是语义上的，它们使用完全相同的 PE 格式。唯一的区别就是用一个字段标识出这个文件是 EXE 还是 DLL。同时也包括其它的 DLL 扩展，比如 OCX 控件和控制面板程序 (CPL 文件)。另外，64 位 windows 只是对 PE 格式做了一些简单的修饰，新格式叫 PE32+，没有新的结构加进去，其余的改变只是简单地将以前的 32 位字段扩展成 64 位，比如 IMAGE_NT_HEADERS，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100616a78xi7k6ii00v641.png" alt=""></p><h2 id="PE-文件大体结构"><a href="#PE-文件大体结构" class="headerlink" title="PE 文件大体结构"></a>PE 文件大体结构</h2><p>结构的选择依赖于用户正在编译的模式 (尤其是 _WIN64 是否被定义)，在具体学习 PE 之前，先大概清楚下 PE 格式布局是怎样子的，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100650vomjiz9sx9jj8mgm.png" alt=""></p><p>PE 文件使用的是一个平面地址空间，所有代码和数据都被合并在一起，组成一个很大的结构，文件的内容被分割为不同的区块，区块包含代码和数据，各个区块按页边界来对齐，区块没有大小限制，是一个连续结构，每个块都有它自己在内存中的一套属性。PE 文件是由 PE 加载器加载到内存中的，这个 PE 加载器也就是 windows 加载器，它并不是将 PE 文件作为单一内存映射文件装入到内存中，而是去遍历 PE 文件，决定将哪一部分进行映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址，当磁盘文件装入到内存中，其数据结构布局是一致的，但是数据之间的相对位置可能会改变，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100802zpj28547nb442p5a.png" alt=""></p><h2 id="模块和基地址"><a href="#模块和基地址" class="headerlink" title="模块和基地址"></a>模块和基地址</h2><p>下面需要理清两个概念，那就是 模块 和 基地址，当 PE 文件通过 windows 加载器加载到内存后，内存中的版本被称为模块 (Module)，映射文件的起始地址被称为模块句柄 (hModule)，可以通过模块句柄来访问在内存中其它的数据结构，这个初始地址也被称为基地址 (ImageBase)。在 32 位 windows 系统中可以直接调用 GetModuleHandle 以取得指向 DLL 的指针，通过指针访问该 DLL Module 的内容，函数原型为：HMODULE WINAPI GetModuleHandle(LPCTSTR lpModuleName)</p><p>功能：获取一个应用程序或动态链接库的模块句柄。</p><p>参数：传递一个可执行文件或 DLL 文件名字符串</p><p>返回值：若执行成功，则返回模块的句柄，也就是加载的基地址，若返回零，则表示失败。如果传递参数为 NULL，则返回调用的可执行文件的基地址。</p><p>注意事项：只有在当前进程中，这个句柄才会有效，也就是说已映射到调用该函数的进程内，才会正确得到模块句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">    std::cout &lt;&lt; hModule &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PE 文件加载的基地址 (ImageBase)：EXE 默认基地址为 0x00400000，DLL 默认基地址为 0x10000000，这个值可以在链接应用时使用链接程序的 /BASE 选项设定，或者通过 REBASE 应用程序进行设置。说完基地址，再来说下相对虚拟地址，由于 PE 文件中里的东西可以载入到空间的任何位置，所以不能依赖于 PE 的载入点，必须有一个方法来指定地址而不依赖于 PE 载入点的地址，所以出现相对虚拟地址 (RVA) 概念，RVA 只是内存中的一个简单的相对于 PE 文件装入地址的偏移位置，例如，假设一个 EXE 文件从地址 0x400000 处装入，并且它的代码区块开始于 0x401000，代码区块的 RVA 就是：0x401000 – 0x400000 = 0x1000，在这里，0x401000 是实际的内存地址，这个地址被称为虚拟内存地址 (VA)，另外也可以把虚拟地址想象为加上首选装入地址的 RVA。</p><h2 id="文件偏移地址"><a href="#文件偏移地址" class="headerlink" title="文件偏移地址"></a>文件偏移地址</h2><p>当 PE 文件储存在磁盘上，某个数据的位置相对于文件头的偏移量，称为文件偏移地址或物理地址。文件偏移地址从 PE 文件的第一个字节开始计数，起始值为 0，用十六进制文本编辑器打开文件，里头显示的就是文件偏移地址。</p><h2 id="IMAGE-DOS-HEADER-结构"><a href="#IMAGE-DOS-HEADER-结构" class="headerlink" title="IMAGE_DOS_HEADER 结构"></a>IMAGE_DOS_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/100902xhvfefb5jf5j45be.png" alt=""></p><p>在这个结构体中，有两个字段非常重要，分别是第一个和最后一个，其它的不重要，其中第一个 e_magic 字段需要被设置为 0x5A4D。它也被称为魔术数字。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100926k80ot4fjfu0qm1ov.png" alt=""></p><p>这个值有个宏定义，名为 IMAGE_DOS_SIGNATURE，它的 ASCII 值为 MZ，是 MS-DOS 的最初创建者之一 Mark Zbikowski 字母的缩写。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/100948ota0a21iteiztt0t.png" alt=""></p><p>e_lfanew 字段是真正 PE 文件头的相对偏移（RVA），那么，这个字段在哪呢？</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101013bp14g9p7cz7zvadv.png" alt=""></p><p>上图已经说明了，为了验证是否正确，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101034vtog24sxkxoo3k21.png" alt=""></p><p>在 3CH 偏移处，显示 0x00000110 (由于 Intel CPU 属于 Little-Endian 类，字符存储时低位在前，高位在后，反序排列，将顺序恢复后便是 0x00000110)，这个是 e_lfanew 字段所存储的值，它占 4 个字节。后面就是 PE 头了。</p><h2 id="IMAGE-NT-HEADER-结构"><a href="#IMAGE-NT-HEADER-结构" class="headerlink" title="IMAGE_NT_HEADER 结构"></a>IMAGE_NT_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/101103izx0tct3acnl3xft.png" alt=""></p><p>在一个有效的 PE 文件里，Signature 字段被设置为 0x00004550，ASCII 码字符是 PE00</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101127usuosiszoij7osug.png" alt=""></p><p>宏定义为 IMAGE_NT_SIGNATURE</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101153ky45o5pjkqnqteto.png" alt=""></p><p>那么这两个重要的字段 (e_lfanew 和 Signature) 有什么用呢？这个在以后解析 PE 文件，判断一个文件是否是一个 PE 文件时提供重要依据，即判断这两个字段的值是否为 0x5A4D 和 0x00004550，你也可以用它们的宏定义，分别为 IMAGE_DOS_SIGNATURE 和 IMAGE_NT_SIGNATURE，如果相等，则为一个 PE 文件，如果不相等，则不是一个 PE 文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.首先须打开一个文件</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;test.png&quot;</span>),</span><br><span class="line">        GENERIC_ALL,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2.判断文件句柄是否有效，若无效则提示打开文件失败并退出</span></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;打开文件失败！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.若打开文件成功，则获取文件的大小</span></span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 4.申请内存空间，用于存放文件数据</span></span><br><span class="line">    BYTE * FileBuffer = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line">    <span class="comment">// 5.读取文件内容</span></span><br><span class="line">    DWORD dwReadFile = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, FileBuffer, dwFileSize, &amp;dwReadFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 6.判断这个文件是不是一个有效的PE文件</span></span><br><span class="line">    <span class="comment">//    6.1 先检查 DOS 头中的 MZ 标记，判断 e_magic 字段是否为 0x5A4D，或者是 IMAGE_DOS_SIGNATURE</span></span><br><span class="line">    DWORD dwFileAddr = (DWORD)FileBuffer;</span><br><span class="line">    <span class="keyword">auto</span> DosHeader = (PIMAGE_DOS_HEADER)dwFileAddr;</span><br><span class="line">    <span class="keyword">if</span> (DosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是则提示用户，并立即结束</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;这不是一个有效 PE 文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    6.2 若都通过的话再获取 NT 头所在的位置，并判断 e_lfanew 字段是否为 0x00004550，或者是 IMAGE_NT_SIGNATURE</span></span><br><span class="line">    <span class="keyword">auto</span> NtHeader = (PIMAGE_NT_HEADERS)(dwFileAddr + DosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (NtHeader-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是则提示用户，并立即结束</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;这不是一个有效 PE 文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7.若上述都通过，则为一个有效的 PE 文件</span></span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;这是一个有效 PE 文件&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="comment">// 8.结束程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是简单实现判断一个文件是不是有效的 PE 文件。在上述代码中，运用了 CreateFile()、GetFileSize()、ReadFile() 来获取文件内容，得到文件的基址 dwFileAddr，只需将该变量转换成 PIMAGE_DOS_HEADER 类型，那么就能获取到 NT 头的开始位置，NT 头的位置可通过 (PIMAGE_NT_HEADERS)((PIMAGE_DOS_HEADER)dwFileAddr-&gt;e_lfanew + dwFileAddr) 获取，有了这个，后面的工作就变得简单多了。</p><h2 id="IMAGE-FILE-HEADER-结构"><a href="#IMAGE-FILE-HEADER-结构" class="headerlink" title="IMAGE_FILE_HEADER 结构"></a>IMAGE_FILE_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/101254s5g40z4tzcw077yj.png" alt=""></p><p>该结构体描述的是文件的一般性质，有 7 个字段，共占 20 个字节，20 相当于十六进制的 14H，下图已标出实际位置，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101317t3uougwpvga25x3w.png" alt=""></p><ul><li>第 1 处标记的是 Machine 字段，占两个字节，它的值为 0x014C，代表的是 Intel i386 平台。</li><li>第 2 处标记的是 NumberOfSections 字段，占两个字节，它的值为 0x0006，代表的是有 6 个区块，也可以说有 6 个节。</li><li>第 3 处标记的是 TimeDateStamp 字段，占四个字节，它的值为 0x5C0748D5，代表的是文件创建日期和时间。由以下图可以看出，该文件创建时间为 2018-12-05 / 11:41:09。<br><img src="https://image.zeronohacker.com/article/2018/12/24/101343te0hecseval0eel2.png" alt=""></li><li>第 4 处值以 0 填充，用不到。</li><li>第 5 处值以0填充，用不到。</li><li>第 6 处字段就比较重要，划重点，SizeOfOptionalHeader，占两个字节，它的值为 0x00E0，代表的是 IMAGE_OPTIONAL_HEADER32 结构的大小，在 32 位系统，它的值为 0x00E0，在 64 位系统，它的值为 0x00F0，</li><li>第 7 处最后一个字段 Characteristics，占两个字节，它的值为 0x0102，代表的是文件的属性。这个值是由 0x0100 和 0x0002 两者之和，0x0100 这个值代表的是目标平台为 32 位机器，0x0002 这个值代表文件可执行，如果为 0，一般是链接出现了问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件头</span></span><br><span class="line"><span class="keyword">auto</span> FileHeader = NtHeader-&gt;FileHeader;</span><br><span class="line"><span class="comment">// 接下来就是解析各字段</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;运行平台：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Machine &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;区块数目：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.NumberOfSections &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件创建日期和时间：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.TimeDateStamp &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IMAGE_OPTIONAL_HEADER32结构大小：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.SizeOfOptionalHeader &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件属性：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Characteristics &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>将上述代码插入到 return 0; 之前，运行如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101427zf1xwf4jzi5i5xgk.png" alt=""></p><p>再将上面文件创建日期和时间进行转换，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件头</span></span><br><span class="line"><span class="keyword">auto</span> FileHeader = NtHeader-&gt;FileHeader;</span><br><span class="line"><span class="comment">// 接下来就是解析各字段</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;运行平台：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Machine &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;区块数目：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.NumberOfSections &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 进行时间转换</span></span><br><span class="line">tm FileCreateTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> nError = <span class="built_in">gmtime_s</span>(&amp;FileCreateTime, (<span class="keyword">time_t</span>*)&amp;FileHeader.TimeDateStamp);</span><br><span class="line"><span class="keyword">if</span> (!nError)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;文件创建日期和时间：&quot;</span> &lt;&lt; std::dec &lt;&lt; FileCreateTime.tm_year + <span class="number">1900</span> &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_mon + <span class="number">1</span> &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_mday &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_hour + <span class="number">8</span> &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_min &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">        &lt;&lt; FileCreateTime.tm_sec &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IMAGE_OPTIONAL_HEADER32结构大小：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.SizeOfOptionalHeader &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件属性：0x&quot;</span> &lt;&lt; std::hex &lt;&lt; FileHeader.Characteristics &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>上面是用到了 tm 的结构，以及 gmtime_s 这个函数进行转换，在用之前需要包含头文件 time.h，运行如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101511ks13t1en11s1efn1.png" alt=""></p><p>不过还是要注意下，首先 tm_year 这个值为十六进制，需转成十进制，而且要加上 1900，因为时间是从 1900 开始算，它的值为偏移，其次月是从 0 开始算的，所以要加 1，最后是时区问题，因为我这里位于东八区，所以小时需加上 8。另外关于调试的那两个字段，没有必要去对它深究，因为微软的VS已用了新的 Debug 格式，这个只是用来设置 COFF 符号，跟 COFF 符号有关，一般这个值都为 0，所以不探讨它。关于运行平台代码和文件属性代码可以去网上查表就行，这里就省略。</p><h2 id="IMAGE-OPTIONAL-HEADER-结构"><a href="#IMAGE-OPTIONAL-HEADER-结构" class="headerlink" title="IMAGE_OPTIONAL_HEADER 结构"></a>IMAGE_OPTIONAL_HEADER 结构</h2><p><img src="https://image.zeronohacker.com/article/2018/12/24/101529oflj8jv835dfzlli.png" alt=""></p><p>上图展示的是 IMAGE_OPTIONAL_HEADER32 结构体各字段，这个结构体相对来说就比较大，我已经分析好了，这个是 32 位的，64 位的大体结构没变，只是有几个字段改成的 ULONGLONG 类型，那么它在实际内部是怎么样的呢？下面这张图是验证上面图片所叙述的。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101549rggwziijno4tzm01.png" alt=""></p><p>上图所标记的，为 IMAGE_OPTIONAL_HEADER32 结构所有成员，你也注意到了，在结尾处，有 .text，说明已经到了该结构体的末尾了，算了一下，恰好占了 224 个字节，这个值其实在 IMAGE_FILE_HEADER 中倒数第二个字段已经指出了，值为 0xE0，这个值相当于十进制中的 224。为了更好的说明，我用序号标记了各个字段，其中有一些为透明，一是没地方标，二是能看清实际数值大小，这样便于分析。</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101613zqrdmhla98udt5sr.png" alt=""></p><p>以下是各字段解析：</p><div class="table-container"><table><thead><tr><th>序号</th><th><strong>字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>0001</td><td>Magic</td><td>这个是一个标记，它的值为 0x010B，代表的是普通的可执行映象，一般是 0x010B，如果是 64 位，则为 0x020B，如果为 ROM 映象，该值为 0x0107</td></tr><tr><td>0002</td><td>MajorLinkerVersion</td><td>链接程序主版本号，值为 0x0E</td></tr><tr><td>0003</td><td>MinorLinkerVersion</td><td>链接程序次版本号，值为 0x00</td></tr><tr><td>0004</td><td><strong>SizeOfCode</strong></td><td>所有含有代码区块的总大小，该值为 0x0031D000，这个代码区块是带有 IMAGE_SCN_CNT_CODE 属性，这个值是向上对齐某一个值的整数倍。通常情况下，多数文件只有一个 Code 块，所以这个字段和 .text 块的大小匹配</td></tr><tr><td>0005</td><td>SizeOfInitializedData</td><td>所有初始化数据区块总大小，该值为 0x000B4000，这个是在编译时所构成的块的大小（不包括代码段），一般这个值是不准确的</td></tr><tr><td>0006</td><td>SizeOfUninitializedData</td><td>所有未初始化数据区块总大小，该值为 0，这些块在程序开始运行时没有指定值，未初始化的数据通常在 .bss 块中</td></tr><tr><td>0007</td><td><strong>AddressOfEntryPoint</strong></td><td>程序执行入口 RVA，该值为 0x002B56D0。在大多数可执行文件中，这个地址并不直接指向 Main、WinMain 或者是 DllMain，而是指向运行库代码并由它来调用上述函数。对于 DLL 来说，这个入口点是在程序初始化和关闭时以及线程创建和毁灭时被调用</td></tr><tr><td>0008</td><td><strong>BaseOfCode</strong></td><td>代码段的起始 RVA，该值为 0x00001000，如果是用微软的链接器生成的，则该值通常是 0x00001000</td></tr><tr><td>0009</td><td><strong>BaseOfData</strong></td><td>数据段的起始 RVA，该值为 0x0031E000，数据段通常在内存的末尾，对于不同版本的微软链接器，这个值是不一致的，在64位可执行文件中是不出现的</td></tr><tr><td>0010</td><td><strong>ImageBase</strong></td><td>程序默认装入地址，该值为 0x00400000，加载器试图在这个地址表装入 PE 文件，如果可执行文件是在这个地址装入的，那么加载器将跳过应用基址重定位的步骤</td></tr><tr><td>0011</td><td><strong>SectionAlignment</strong></td><td>内存中区块对齐大小，值为 0x00001000，默认对齐尺寸是目标 CPU 的页尺寸，最小的对齐尺寸是一页 1000H（4KB），在 IA-64 上，这个值是 8KB。每个区块装入地址必定是本字段指定数值的整数倍</td></tr><tr><td>0012</td><td><strong>FileAlignment</strong></td><td>磁盘上 PE 文件内的区块对齐大小，值为 0x00000200，对于 x86 的可执行文件，这个值通常是 200H 或 1000H，这是为了保证块总是从磁盘的扇区开始的，这个值必须是 2 的幂，最小为 200H</td></tr><tr><td>0013</td><td>MajorOperatingSystemVersion</td><td>要求操作系统的最低版本号的主版本号，该值为 0x0006，这个值似乎没什么用</td></tr><tr><td>0014</td><td>MinorOperatingSystemVersion</td><td>同上，没什么用</td></tr><tr><td>0015</td><td>MajorImageVersion</td><td>同上，没什么用</td></tr><tr><td>0016</td><td>MinorImageVersion</td><td>同上，没什么用</td></tr><tr><td>0017</td><td>MajorSubsystemVersion</td><td>同上，没什么用</td></tr><tr><td>0018</td><td>MinorSubsystemVersion</td><td>同上，没什么用</td></tr><tr><td>0019</td><td>Win32VersionValue</td><td>同上，没什么用</td></tr><tr><td>0020</td><td>SizeOfImage</td><td>映象装入内存后的总尺寸，该值为 0x003D5000，它指装入文件从 ImageBase 到最后一个块的大小，最后一个块根据其大小往上取整</td></tr><tr><td>0021</td><td>SizeOfHeaders</td><td>是 MS-DOS 头部、PE 头部、区块表的组合尺寸。该值为 0x00000400</td></tr><tr><td>0022</td><td>CheckSum</td><td>校验和，IMAGEHLP.DLL 中的 CheckSumMappedFile 函数可以计算这个值，一般的EXE文件可以是 0，但一些内核模式的驱动程序和系统 DLL 必须有一个校验和</td></tr><tr><td>0023</td><td>Subsystem</td><td>一个标明可执行文件所期望的子系统的枚举值，这个值只对 EXE 是重要的。该值为 0x0003</td></tr><tr><td>0024</td><td>DllCharacteristics</td><td>DllMain() 函数何时被调用，默认为 0</td></tr><tr><td>0025</td><td>SizeOfStackReserve</td><td>在 EXE 文件里，为线程保留的堆栈大小，它一开始只提交其中一部分，只有在必要时，才提交剩下的部分</td></tr><tr><td>0026</td><td>SizeOfStackCommit</td><td>在 EXE 文件里，一开始即被委派堆栈的内存数量，默认值为 4KB</td></tr><tr><td>0027</td><td>SizeHeapReserve</td><td>在 EXE 文件里，为进程的默认堆保留的内存，默认值为 1MB，但是在当前 Windows 里，堆值在用户不干涉的情况下就能增长超过这个值</td></tr><tr><td>0028</td><td>SizeOfHeapCommit</td><td>在 EXE 文件里，委派给堆的内存大小，默认值是 4KB</td></tr><tr><td>0029</td><td>LoaderFlag</td><td>与调试有关，默认为 0</td></tr><tr><td>0030</td><td>NumberOfRvaAndSizes</td><td>数据目录表的项数，这个字段一直以来都为 16</td></tr><tr><td>0031</td><td><strong>DataDirectory[16]</strong></td><td>数据目录表，由数个 IMAGE_DATA_DIRECTORY 结构组成，指向输入表、输出表、资源等数据</td></tr></tbody></table></div><div class="tip "><p>提示：以上表格中有颜色标记的为比较重要的字段 </p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取扩展头各个字段</span></span><br><span class="line"><span class="keyword">auto</span> OptionalHeader = NtHeader-&gt;OptionalHeader;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;扩展头解析&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (OptionalHeader.Magic == <span class="number">0x10b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;文件类型：32位&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;链接器的主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; (<span class="keyword">int</span>)OptionalHeader.MajorLinkerVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;链接器的次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; (<span class="keyword">int</span>)OptionalHeader.MinorLinkerVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所有含有代码区块的总大小:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SizeOfCode &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所有初始化数据区块的总大小:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SizeOfInitializedData &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所有未初始化数据区块的总大小:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SizeOfUninitializedData &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序执行入口:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.AddressOfEntryPoint &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序默认装入基地址:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.ImageBase &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;内存中区块对齐值:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.SectionAlignment &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;文件中区块对齐值:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.FileAlignment &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;操作系统主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MajorOperatingSystemVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;操作系统次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MinorOperatingSystemVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;用户自定义主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MajorImageVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;用户自定义次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MinorImageVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所需系统主版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MajorSubsystemVersion &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;所需系统次版本号:0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.MinorSubsystemVersion &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">delete</span>[] FileBuffer;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br></pre></td></tr></table></figure><p>同样，将上述代码放置最后，对扩展头进行解析，因字段太多，没一一列举，运行后如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101702y6ani066ixy98vii.png" alt=""></p><p>对于该结构的最后一个字段，它是一个数组，这个数组有 16 个成员，代表的是目录表中的项，每项包含两个结构体成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD VirtualAddress;    <span class="comment">// 数据块的起始 RVA</span></span><br><span class="line">    DWORD Size;              <span class="comment">// 数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>其实遍历它也不是很难，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;目录表&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;RVA\t\t大小&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt;</span><br><span class="line">        std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.DataDirectory[i].VirtualAddress &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt;</span><br><span class="line">        std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; OptionalHeader.DataDirectory[i].Size &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101746zn7aznjwsllhqujo.png" alt=""></p><p>将上述与 LoadPE 对照，看下是否正确，如下：</p><p><img src="https://image.zeronohacker.com/article/2018/12/24/101806x3mrbgwwmvlu33gb.png" alt=""></p><p>从上面可以看出，已经成功遍历出目录表中每项的 RVA 和大小。关于目录表各项具有什么作用，我会在本系列文章中后面详细讲到，故在此不再作过多讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;可执行文件格式是操作系统本身执行机制的反映，理解它有助于对操作系统的深刻理解，掌握可执行文件的数据结构及其一些机理，是研究软件安全的必修课。</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="PE" scheme="https://zeronohacker.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>对一个简单的 win32 汇编程序剖析及拓展</title>
    <link href="https://zeronohacker.github.io/2018/08/06/analysis-and-expansion-a-simple-win32-assembler/"/>
    <id>https://zeronohacker.github.io/2018/08/06/analysis-and-expansion-a-simple-win32-assembler/</id>
    <published>2018-08-06T06:12:46.000Z</published>
    <updated>2021-09-19T07:24:14.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的-win32-汇编程序"><a href="#一个简单的-win32-汇编程序" class="headerlink" title="一个简单的 win32 汇编程序"></a>一个简单的 win32 汇编程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">; Include 文件定义</span><br><span class="line">inclue        windows.inc</span><br><span class="line">include       user32.inc</span><br><span class="line">include       kernel32.inc</span><br><span class="line">includelib    user32.lib</span><br><span class="line">includelib    kernel32.lib</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox !&#x27;,0</span><br><span class="line">szText db &#x27;Hello, World !&#x27;,0</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">    invoke MessageBox,NULL,offset szText,\</span><br><span class="line">            offset szCaption,MB_OK</span><br><span class="line">    invoke ExitProcess,NULL</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h2 id="指定指令集"><a href="#指定指令集" class="headerlink" title="指定指令集"></a>指定指令集</h2><p>.386 语句是汇编程言的伪指令，类似的还有 .8086，.186，.286，.386/.386p，.486/.486p 和 .586/.586p 等，用于告诉编译器在本程序中使用的指令集。在 DOS 汇编默认使用的是 8086 指令集，如果在源程序中写入 80386 所特有的指令或使用 32 位的寄存器就会报错，为了在 DOS 环境下进行保护模式编程或仅为了使用 32 位寄存器，常在 DOS 的汇编中使用 .386 来定义。Win32 环境工作在 80386 及以上的处理器中，所以 .386 这一句必不可少。后面带 p 的伪指令则表示程序中可以使用特权指令。</p><h2 id="model-语句"><a href="#model-语句" class="headerlink" title="model 语句"></a>model 语句</h2><p>.model 语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式[,语言模式][,其他模式]</span><br></pre></td></tr></table></figure><p>内存模式的定义影响最后生成的可执行文件，现在一般都用 flat (平坦模式)，可以突破 64KB 段大小的限制，在保护模式下，系统把每一个 win32 程序都放在分开的虚拟地址空间中去运行，也就是说，每一个程序都拥有其相互独立的 4GB 地址空间，4GB 的空间用 32 位寄存器全部都能访问到，相关模式可参看下图：</p><p><img src="https://image.zeronohacker.com/article/2018/08/06/400c8ebd1df134a8664386b3f629d6b5.png" alt=""></p><p>在 flat 后，便是语言模式，即子程序的调用方式，开头的示例中所用的是 stdcall，它指出了调用子程序或 win32 API 时参数传递的次序和堆栈平衡的方法。windows 的 API 调用使用的是 stdcall 格式，所以在 win32 汇编中没有选择，必须在 .model 中加上 stdcall 参数。</p><h2 id="option-语句"><a href="#option-语句" class="headerlink" title="option 语句"></a>option 语句</h2><p>用 option 语句定义的选项非常多，比如 option language 定义和 option segment 定义等，在 win32 汇编中，只需要定义 option casemap:none，这个语句定义了程序中的变量和子程序名是否对大小写敏感，由于 win32 API 中的 API 名称是区分大小写的，所以必须指定这个选项，否则在调用 API 的时候会有问题。</p><h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><p>在 win32 汇编程序中，经常会看到 .stack，.data，.data?，.const，.code 等段说明，其中 .stack 常常被忽略，因为 win32 汇编程序不必考虑堆栈，系统会为程序分配一个向下扩展的、足够大的段作为堆栈段，这一点与 DOS 汇编 (16 位) 不同。注意这里的段不是 DOS 汇编中那种意义上的段，而是内存 “分段”，上一段的结束就是下一段的开始，所有的 “分段” 合起来，包括系统使用的地址空间，就组成了整个可以寻址的 4GB 空间，win32 环境的内存管理使用了 80386 处理器的分页机制，每页 (4KB) 可以自由指定属性，所以上一个 4KB 可能是代码，属性是可执行但不可写，下一个 4KB 就有可能是既可读也可写但不执行的数据，再下面呢？有可能是可读不可写也不可执行的数据。可以换个角度看，程序中的 “分段” 的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页中，这中间不涉及使用不同的段选择器。</p><p>.data，.data? 和 .const 定义的是数据段，分别对应不同方式的数据定义，在最后生成可执行文件中也分别放在不同的节区中，有三类数据：</p><ul><li>第一类是可读可写的已定义变量，必须定义在 .data 段，.data 段是已初始化数据段，其中定义的数据是可读可写的，.data 段一般存放在可执行文件的 _DATA 节区内；</li><li>第二类是可读可写的未定义变量，这些变量一般是当作缓冲区或者在程序执行后才开始使用，可定义在 .data 段，也可定义在 .data? 段，但最是定义在 .data? 段，因为生成后，后者比前者体积更大，.data? 段一般存放在 _BSS 节区中；</li><li>第三类数据是一些常量，此类数据可定义在 .const 段中，它是可读不可写的，你也可以定义到 .data 段中，但最好还是选择 .const 段中；</li></ul><p>.code 段为代码段，代码段一般放在 _TEXT 节区中，可读不可写可执行，一定不可写吗？这可不一定，比如一些压缩软件和加壳软件，它们就可以修改程序的代码段，另外在 0 环运行的程序对所有的段都有读写权利，包括代码段。</p><p>.stack 段还需提一下，.stack 段是可读可写可执行的，这样靠动态修改代码的反跟踪模块可以拷贝到堆栈中去边修改边执行，一些病毒或黑客工具用到缓冲区溢出技术也用到了这个特征。</p><h2 id="程序结束和程序入口"><a href="#程序结束和程序入口" class="headerlink" title="程序结束和程序入口"></a>程序结束和程序入口</h2><p>程序的结束由 end 语句来指定，end 后这个标号为程序的入口。当编写多模块程序时，不需要在每个程序文件中指定入口，当最终把多个模块链接在一起时，只需在主模块中指定即可。</p><h2 id="注释和换行"><a href="#注释和换行" class="headerlink" title="注释和换行"></a>注释和换行</h2><p>汇编源程序的注释符号为分号，可放在任意位置。换行符号为反斜杠，如开头那个示例那样。</p><h2 id="调用-API"><a href="#调用-API" class="headerlink" title="调用 API"></a>调用 API</h2><p>API 为应用程序接口，为一系列函数、结构和消息等，不仅为应用程序所调用，同时也是 windows 自身的一部分。在 DOS 下，操作系统功能是通过软中断来实现，比如 int 21h 为 DOS 中断，int 13h 为磁盘中断，int 10h 为视频中断，当应用程序要引用系统功能时要把相应的参数放在各个寄存器再调用相应的中断，程序控制权转到中断处理程序去执行，完成后会通过 iret 中断返回指令回到应用程序中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9</span><br><span class="line">mov dx,offset szHello</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>9 为功能号，存放在 ah 中，表示屏幕显示，要输出到屏幕上的内容地址存放在 dx 中，然后调用 int 21h，字符串就会显示在屏幕上，DOS 时代汇编程序员都有一本厚厚的 《中断大全》，因为所有的功能编号包括使用的参数仅从字面上看，是看不出一点头绪来的。另外，80×86 系列处理器最多只能处理 256 个中断，中断数量太少，到最后就会现中断里挂中断，这是非常不好的，所以 API 出现了，win32 系统功能实现放在 Dll 中，我们可以通过 DLL 中的导出表可看出，有三大核心 Dll，分别为 kernel32.dll，gdi32.dll，user32.dll。想一想在 C 语言如何使用一个函数，首先需要先声明，然后就是要这个函数的实现，在 win32 汇编程序中，系统函数声明在 inc 文件中，函数实现在 lib 文件 (静态库) 中，前者由 include 包含，后者由 includelib 包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include 文件名</span><br><span class="line">include &lt;文件名&gt;</span><br><span class="line">includelib 文件名</span><br><span class="line">includelib &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>参照下开头那个示例。那如何调用了，这得使用到另一个伪指令 invoke，为什么会有 invoke 指令，因为在 win32 的 API 中，动不动就是十几个参数，甚至更多，如果都用 push 来写的话，这就非常恐怖了，invoke 正好解决这个问题，参数可写在一行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK</span><br></pre></td></tr></table></figure><p>invoke 为 MASM 编译器的伪指令，在编译的时候由编译器把上面的指令展开成我们需要的 4 个 push 和 1 个 call 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push szText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure><p>函数的返回值存放在 eax 中，如果要返回的内容不是一个 eax 所能容纳的，win32 API 采用的方法一般是 eax 返回一个指向返回数据的指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去。</p><p>最后提一下在汇编下一个 API 函数的声明，比如 MessageBox：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO hWnd:dword,lpText:dword,lpCaption:dword,uType:dword</span><br></pre></td></tr></table></figure><p>可简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO :dword,:dword,:dword,:dword</span><br></pre></td></tr></table></figure><p>句中 PROTO 是函数声明的伪指令，其实是不存在 MessageBox 的，只存在 MessageBoxA 和 MessageBoxW，在 user32.inc 中有一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox equ &lt;MessageBoxA&gt;</span><br></pre></td></tr></table></figure><p>MessageBoxA 和 MessageBoxW 对应两个字符集，一个是 ANSI，另一个为 UNICODE，每一个 ANSI 字符只占用一个字节宽，每一个 UNICODE 占两个字节宽，对于欧洲语言体系，ANSI 字符集就已经够了，但对于有成千上万个不同字符的几种东方语言体系来说，UNICODE 字符集更有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的-win32-汇编程序&quot;&gt;&lt;a href=&quot;#一个简单的-win32-汇编程序&quot; class=&quot;headerlink&quot; title=&quot;一个简单的 win32 汇编程序&quot;&gt;&lt;/a&gt;一个简单的 win32 汇编程序&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/categories/Assembly/"/>
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Assembly-Language-for-x86-Processors-Part03</title>
    <link href="https://zeronohacker.github.io/2018/06/13/Assembly-Language-for-x86-Processors-Part03/"/>
    <id>https://zeronohacker.github.io/2018/06/13/Assembly-Language-for-x86-Processors-Part03/</id>
    <published>2018-06-13T05:11:14.000Z</published>
    <updated>2021-09-19T06:09:19.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是 Kip·Irvine 所写的 Assembly Langrage for x86 Processors (Seventh Edition) 第三章节的小结以及个人对章节编程习题的解答</p></blockquote><p><img src="https://image.zeronohacker.com/article/2018/06/13/acd43387742959dec4bc102af72d3cd2.png" alt=""></p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>整型常量表达式是算术表达式，包括了整数常量、符号常量和算术运算符。优先级是指当表达式有两个或更多运算符时，运算符的隐含顺序。</p><p>字符常量是用引号括起来的单个字符。汇编器把字符转换成一个字节，其中包含的是该字符的二进制 ASCII 码。字符串常量是用引号括起来的字符序列，可以选择用空字节标记结束。</p><p>汇编语言有一组保留字，它们含义特殊且只能用于正确的上下文中。标识符是程序员选择的名称，用于标识变量、符号常量、子程序和代码标号。不能用保留字作标识符。</p><p>伪指令是嵌在源代码中的命令，由汇编器进行转换。指令是源代码语句，由处理器在运行时执行。指令助记符是短关键字，用于标识指令执行的操作。标号是一种标识符，用作指令或数据的位置标记。</p><p>操作数是传递给指令的数据。一条汇编指令有 0 ~ 3 个操作数，每一个都可以是寄存器、内存操作数、整数表达式或输入输出端口号。</p><p>程序包括了逻辑段，名称分别为代码段、数据段和堆栈段。代码段包含了可执行指令；堆栈段包含了子程序参数、局部变量和返回地址；数据段包含了变量。</p><p>源文件包含了汇编语言语句。列表文件包含了程序源代码的副本，再加上行号、偏移地址、翻译的机器代码和符号表，适合打印。源文件用文本编辑器创建。汇编器是一种程序，它读取源文件，并生成目标文件和列表文件。链接器也是一种程序，它读取了一个或多个目标文件，并生成可执行文件。后者由操作系统加载器来执行。</p><p>MASM 识别内容数据类型，每一种类型都描述了一组数值，这些数值能分配给指定类型的变量和表达式：</p><ul><li>BYTE 和 SBYTE 定义 8 位变量</li><li>WORD 和 SWORD 定义 16 位变量</li><li>DWORD 和 SDWORD 定义 32 位变量</li><li>QWORD 和 TBYTE 分别定义 8 字节和 10 字节变量</li><li>REAL4、REAL8 和 REAL10 分别定义 4 字节、8 字节和 10 字节实数变量</li></ul><p>数据定义语句为变量预留内存空间，并可以选择性地给变量分配一个名称。如果一个数据定义有多个初始值，那么它的标号仅指向第一个初始值的偏移量。创建字符串数据定义时，要用引号把字符序列括起来。DUP 运算符用常量表达式作为计数器，生成重复的存储分配。当前地址计数器运算符 ($) 用于地址计算表达式。</p><p>x86 处理器用小端顺序在内存中存取数据：变量的最低有效字节存储在其起始 (最低) 地址中。</p><p>符号常量 (或符号定义) 把标识符与一个整数或文本表达式连接起来。有 3 个伪指令能够定义符号常量：</p><ul><li>等号伪指令 (=) 连接符号名称与整数常量表达式</li><li>EQU 和 TESTEQU 伪指令连接符号与整数常量表达式或一些任意的文本</li></ul><div class="tip "><p>提示：以下编程练习中的答案为本人的解答，并非标准答案，仅供参考。</p></div><h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><span class='p blue'>整数表达式的计算</span><p>参考 3.2 节的程序 AddTwo，编写程序，利用寄存器计算表达式：A = (A + B) – (C – D)。整数值分配给寄存器 EAX、EBX、ECX 和 EDX。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">A_ DWORD 1</span><br><span class="line">B_ DWORD 2</span><br><span class="line">C_ DWORD 3</span><br><span class="line">D_ DWORD 4</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov eax, A_</span><br><span class="line">    mov ebx, B_</span><br><span class="line">    mov ecx, C_</span><br><span class="line">    mov edx, D_</span><br><span class="line">    add eax, ebx</span><br><span class="line">    sub ecx, edx</span><br><span class="line">    sub eax, ecx</span><br><span class="line">    </span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>符号整数常量</span><p>编写程序，为一周七天定义符号常量。创建一个数组变量，用这些符号常量作为其初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">Mon = 1</span><br><span class="line">Tue = 2</span><br><span class="line">Wed = 3</span><br><span class="line">Thu = 4</span><br><span class="line">Fri = 5</span><br><span class="line">Sat = 6</span><br><span class="line">Sun = 7</span><br><span class="line">Week DWORD Mon, Tue, Wed, Thu, Fri, Sat, Sun</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>数据定义</span><p>编写程序，对 3.4 节表 3-2 中列出的每一个数据类型进行定义，并将每个变量都初始化为与其类型一致的数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">; BYTE SBYTE</span><br><span class="line">value1 BYTE &#x27;A&#x27;</span><br><span class="line">value2 BYTE 0</span><br><span class="line">value3 BYTE 255</span><br><span class="line">value4 SBYTE -128</span><br><span class="line">value5 SBYTE 127</span><br><span class="line">; TBYTE</span><br><span class="line">intVal TBYTE 80000000000000001234h</span><br><span class="line">; WORD SWORD</span><br><span class="line">word1 WORD 65535</span><br><span class="line">word2 SWORD -32768</span><br><span class="line">; DWORD SDWORD</span><br><span class="line">dword1 DWORD 12345678h</span><br><span class="line">dword2 SDWORD -2147483648</span><br><span class="line">; FWORD QWORD</span><br><span class="line">fword1 FWORD 123456781234h</span><br><span class="line">qword1 QWORD 1234567812345678h</span><br><span class="line">; REAL4 REAL8 REAL10</span><br><span class="line">reVal1 REAL4 -1.2</span><br><span class="line">reVal2 REAL8 3.2E-260</span><br><span class="line">reVal3 REAL10 4.6E+4096</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>符号文本常量</span><p>编写程序，定义几个字符串文本 (引号之间的字符) 的符号名称，并将每个符号名称都用于变量定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">text1 TEXTEQU &lt;&quot;text1&quot;&gt;</span><br><span class="line">text2 TEXTEQU &lt;&quot;test2&quot;&gt;</span><br><span class="line">.data</span><br><span class="line">val1 BYTE text1</span><br><span class="line">val2 BYTE text2</span><br><span class="line">.code</span><br><span class="line">main PROC  </span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END mainv</span><br></pre></td></tr></table></figure><span class='p blue'>AddTwoSum 的列表文件</span><p>生成 AddTwoSum 程序的列表文件，为每条指令机器代码字节编写说明。某些字节值的含义需要猜测。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line"> 00000000.data</span><br><span class="line"> 00000000 00000000sum DWORD 0</span><br><span class="line"> 00000000.code</span><br><span class="line"> 00000000main PROC</span><br><span class="line"> 00000000  B8 00000005    mov eax, 5</span><br><span class="line"> 00000005  83 C0 06    add eax, 6</span><br><span class="line"> 00000008  A3 00000000 R    mov sum, eax</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line"> 0000000D  6A 00   *    push   +000000000h</span><br><span class="line"> 0000000F  E8 00000000 E   *    call   ExitProcess</span><br><span class="line"> 00000014main ENDP</span><br><span class="line">END main</span><br><span class="line">Segments and Groups:</span><br><span class="line">                N a m e                 Size     Length   Align   Combine Class</span><br><span class="line">FLAT . . . . . . . . . . . . . .GROUP</span><br><span class="line">STACK  . . . . . . . . . . . . .32 Bit 00001000 DWord  Stack  &#x27;STACK&#x27; </span><br><span class="line">_DATA  . . . . . . . . . . . . .32 Bit 00000004 DWord  Public  &#x27;DATA&#x27;</span><br><span class="line">_TEXT  . . . . . . . . . . . . .32 Bit 00000014 DWord  Public  &#x27;CODE&#x27;</span><br><span class="line">Procedures, parameters, and locals:</span><br><span class="line">                N a m e                 Type     Value    Attr</span><br><span class="line">ExitProcess  . . . . . . . . . .P Near 00000000 FLATLength= 00000000 External STDCALL</span><br><span class="line">main . . . . . . . . . . . . . .P Near 00000000 _TEXTLength= 00000014 Public STDCALL</span><br><span class="line">Symbols:</span><br><span class="line">                N a m e                 Type     Value    Attr</span><br><span class="line">@CodeSize  . . . . . . . . . . .Number 00000000h   </span><br><span class="line">@DataSize  . . . . . . . . . . .Number 00000000h   </span><br><span class="line">@Interface . . . . . . . . . . .Number 00000003h   </span><br><span class="line">@Model . . . . . . . . . . . . .Number 00000007h   </span><br><span class="line">@code  . . . . . . . . . . . . .Text    _TEXT</span><br><span class="line">@data  . . . . . . . . . . . . .Text    FLAT</span><br><span class="line">@fardata?  . . . . . . . . . . .Text    FLAT</span><br><span class="line">@fardata . . . . . . . . . . . .Text    FLAT</span><br><span class="line">@stack . . . . . . . . . . . . .Text    FLAT</span><br><span class="line">sum  . . . . . . . . . . . . . .DWord 00000000 _DATA</span><br><span class="line">   0 Warnings</span><br><span class="line">   0 Errors</span><br></pre></td></tr></table></figure><p>主要看下以下三条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  B8 00000005       mov eax, 5</span><br><span class="line">00000005  83 C0 06          add eax, 6</span><br><span class="line">00000008  A3 00000000 R    mov sum, eax</span><br></pre></td></tr></table></figure><p>B8 代表 <code>mov ax, immed16</code>；83 C0 猜测与 add 之类有关，这个得去查手册；A3 代表 <code>mov [mem16], ax</code>。</p><span class='p blue'>AddVariables 程序</span><p>修改 AddVariables 程序使其使用 64 位变量。描述汇编器产生的语法错误，并说明为解决这些错误采取的措施。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">firstval DWORD 20002000h</span><br><span class="line">secondval DWORD 11111111h</span><br><span class="line">thirdval DWORD 22222222h</span><br><span class="line">sum DWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov rax, firstval</span><br><span class="line">    add rax, secondval</span><br><span class="line">    add rax, thirdval</span><br><span class="line">    mov sum, rax</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined symbol : rax</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExitProcess PROTO</span><br><span class="line">.data</span><br><span class="line">firstval QWORD 20002000h</span><br><span class="line">secondval QWORD 11111111h</span><br><span class="line">thirdval QWORD 22222222h</span><br><span class="line">sum QWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov rax, firstval</span><br><span class="line">    add rax, secondval</span><br><span class="line">    add rax, thirdval</span><br><span class="line">    mov sum, rax</span><br><span class="line">    </span><br><span class="line">    mov ecx, 0</span><br><span class="line">    call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是 Kip·Irvine 所写的 Assembly Langrage for x86 Processors (Seventh Edition) 第三章节的小结以及个人对章节编程习题的解答&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/categories/Assembly/"/>
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Python 之禅</title>
    <link href="https://zeronohacker.github.io/2018/04/25/import-this-in-python/"/>
    <id>https://zeronohacker.github.io/2018/04/25/import-this-in-python/</id>
    <published>2018-04-25T04:37:32.000Z</published>
    <updated>2021-09-19T05:38:28.586Z</updated>
    
    <content type="html"><![CDATA[<p>在博主学习 Python 的模块部分中，曾不小心写下了这句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></table></figure></p><p><img src="https://image.zeronohacker.com/article/2018/04/25/b2f60bf633736257e846216fc24d14ac.png" alt=""></p><p>将上述这段话翻译一下，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"> </span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line"><span class="comment"># 优美胜于丑陋（Python以编写优美的代码为目标）</span></span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line"><span class="comment"># 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span></span><br><span class="line">Simple <span class="keyword">is</span> better than <span class="built_in">complex</span>.</span><br><span class="line"><span class="comment"># 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span></span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line"><span class="comment"># 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span></span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line"><span class="comment"># 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span></span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line"><span class="comment"># 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span></span><br><span class="line">Readability counts.</span><br><span class="line"><span class="comment"># 可读性很重要（优美的代码是可读的）</span></span><br><span class="line">Special cases aren’t special enough to <span class="keyword">break</span> the rules.Although practicality beats purity.</span><br><span class="line"><span class="comment"># 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span></span><br><span class="line">Errors should never <span class="keyword">pass</span> silently.Unless explicitly silenced.</span><br><span class="line"><span class="comment"># 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span></span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line"><span class="comment"># 当存在多种可能，不要尝试去猜测</span></span><br><span class="line">There should be one– <span class="keyword">and</span> preferably only one –obvious way to do it.</span><br><span class="line"><span class="comment"># 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span></span><br><span class="line">Although that way may <span class="keyword">not</span> be obvious at first unless you’re Dutch</span><br><span class="line"><span class="comment"># 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）</span></span><br><span class="line">Now <span class="keyword">is</span> better than never.Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line"><span class="comment"># 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span></span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it’s a bad idea.If the implementation <span class="keyword">is</span> easy to explain, it may be a good idea.</span><br><span class="line"><span class="comment"># 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span></span><br><span class="line">Namespaces are one honking great idea — let’s do more of those!</span><br><span class="line"><span class="comment"># 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在博主学习 Python 的模块部分中，曾不小心写下了这句：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pr</summary>
      
    
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
