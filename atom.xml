<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zeronohacker</title>
  
  <subtitle>零度非安全</subtitle>
  <link href="https://zeronohacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://zeronohacker.github.io/"/>
  <updated>2021-09-19T06:24:34.700Z</updated>
  <id>https://zeronohacker.github.io/</id>
  
  <author>
    <name>zeronohacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对一个简单的 win32 汇编程序剖析及拓展</title>
    <link href="https://zeronohacker.github.io/2018/08/06/analysis-and-expansion-a-simple-win32-assembler/"/>
    <id>https://zeronohacker.github.io/2018/08/06/analysis-and-expansion-a-simple-win32-assembler/</id>
    <published>2018-08-06T06:12:46.000Z</published>
    <updated>2021-09-19T06:24:34.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的-win32-汇编程序"><a href="#一个简单的-win32-汇编程序" class="headerlink" title="一个简单的 win32 汇编程序"></a>一个简单的 win32 汇编程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">; Include 文件定义</span><br><span class="line">inclue        windows.inc</span><br><span class="line">include       user32.inc</span><br><span class="line">include       kernel32.inc</span><br><span class="line">includelib    user32.lib</span><br><span class="line">includelib    kernel32.lib</span><br><span class="line">; 数据段</span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox !&#x27;,0</span><br><span class="line">szText db &#x27;Hello, World !&#x27;,0</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">    invoke MessageBox,NULL,offset szText,\</span><br><span class="line">            offset szCaption,MB_OK</span><br><span class="line">    invoke ExitProcess,NULL</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h2 id="指定指令集"><a href="#指定指令集" class="headerlink" title="指定指令集"></a>指定指令集</h2><p>.386 语句是汇编程言的伪指令，类似的还有 .8086，.186，.286，.386/.386p，.486/.486p 和 .586/.586p 等，用于告诉编译器在本程序中使用的指令集。在 DOS 汇编默认使用的是 8086 指令集，如果在源程序中写入 80386 所特有的指令或使用 32 位的寄存器就会报错，为了在 DOS 环境下进行保护模式编程或仅为了使用 32 位寄存器，常在 DOS 的汇编中使用 .386 来定义。Win32 环境工作在 80386 及以上的处理器中，所以 .386 这一句必不可少。后面带 p 的伪指令则表示程序中可以使用特权指令。</p><h2 id="model-语句"><a href="#model-语句" class="headerlink" title="model 语句"></a>model 语句</h2><p>.model 语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式[,语言模式][,其他模式]</span><br></pre></td></tr></table></figure><p>内存模式的定义影响最后生成的可执行文件，现在一般都用 flat (平坦模式)，可以突破 64KB 段大小的限制，在保护模式下，系统把每一个 win32 程序都放在分开的虚拟地址空间中去运行，也就是说，每一个程序都拥有其相互独立的 4GB 地址空间，4GB 的空间用 32 位寄存器全部都能访问到，相关模式可参看下图：</p><p><img src="https://image.zeronohacker.com/article/2018/08/06/400c8ebd1df134a8664386b3f629d6b5.png" alt=""></p><p>在 flat 后，便是语言模式，即子程序的调用方式，开头的示例中所用的是 stdcall，它指出了调用子程序或 win32 API 时参数传递的次序和堆栈平衡的方法。windows 的 API 调用使用的是 stdcall 格式，所以在 win32 汇编中没有选择，必须在 .model 中加上 stdcall 参数。</p><h2 id="option-语句"><a href="#option-语句" class="headerlink" title="option 语句"></a>option 语句</h2><p>用 option 语句定义的选项非常多，比如 option language 定义和 option segment 定义等，在 win32 汇编中，只需要定义 option casemap:none，这个语句定义了程序中的变量和子程序名是否对大小写敏感，由于 win32 API 中的 API 名称是区分大小写的，所以必须指定这个选项，否则在调用 API 的时候会有问题。</p><h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><p>在 win32 汇编程序中，经常会看到 .stack，.data，.data?，.const，.code 等段说明，其中 .stack 常常被忽略，因为 win32 汇编程序不必考虑堆栈，系统会为程序分配一个向下扩展的、足够大的段作为堆栈段，这一点与 DOS 汇编 (16 位) 不同。注意这里的段不是 DOS 汇编中那种意义上的段，而是内存 “分段”，上一段的结束就是下一段的开始，所有的 “分段” 合起来，包括系统使用的地址空间，就组成了整个可以寻址的 4GB 空间，win32 环境的内存管理使用了 80386 处理器的分页机制，每页 (4KB) 可以自由指定属性，所以上一个 4KB 可能是代码，属性是可执行但不可写，下一个 4KB 就有可能是既可读也可写但不执行的数据，再下面呢？有可能是可读不可写也不可执行的数据。可以换个角度看，程序中的 “分段” 的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页中，这中间不涉及使用不同的段选择器。</p><p>.data，.data? 和 .const 定义的是数据段，分别对应不同方式的数据定义，在最后生成可执行文件中也分别放在不同的节区中，有三类数据：</p><ul><li>第一类是可读可写的已定义变量，必须定义在 .data 段，.data 段是已初始化数据段，其中定义的数据是可读可写的，.data 段一般存放在可执行文件的 _DATA 节区内；</li><li>第二类是可读可写的未定义变量，这些变量一般是当作缓冲区或者在程序执行后才开始使用，可定义在 .data 段，也可定义在 .data? 段，但最是定义在 .data? 段，因为生成后，后者比前者体积更大，.data? 段一般存放在 _BSS 节区中；</li><li>第三类数据是一些常量，此类数据可定义在 .const 段中，它是可读不可写的，你也可以定义到 .data 段中，但最好还是选择 .const 段中；</li></ul><p>.code 段为代码段，代码段一般放在 _TEXT 节区中，可读不可写可执行，一定不可写吗？这可不一定，比如一些压缩软件和加壳软件，它们就可以修改程序的代码段，另外在 0 环运行的程序对所有的段都有读写权利，包括代码段。</p><p>.stack 段还需提一下，.stack 段是可读可写可执行的，这样靠动态修改代码的反跟踪模块可以拷贝到堆栈中去边修改边执行，一些病毒或黑客工具用到缓冲区溢出技术也用到了这个特征。</p><h2 id="程序结束和程序入口"><a href="#程序结束和程序入口" class="headerlink" title="程序结束和程序入口"></a>程序结束和程序入口</h2><p>程序的结束由 end 语句来指定，end 后这个标号为程序的入口。当编写多模块程序时，不需要在每个程序文件中指定入口，当最终把多个模块链接在一起时，只需在主模块中指定即可。</p><h2 id="注释和换行"><a href="#注释和换行" class="headerlink" title="注释和换行"></a>注释和换行</h2><p>汇编源程序的注释符号为分号，可放在任意位置。换行符号为反斜杠，如开头那个示例那样。</p><h2 id="调用-API"><a href="#调用-API" class="headerlink" title="调用 API"></a>调用 API</h2><p>API 为应用程序接口，为一系列函数、结构和消息等，不仅为应用程序所调用，同时也是 windows 自身的一部分。在 DOS 下，操作系统功能是通过软中断来实现，比如 int 21h 为 DOS 中断，int 13h 为磁盘中断，int 10h 为视频中断，当应用程序要引用系统功能时要把相应的参数放在各个寄存器再调用相应的中断，程序控制权转到中断处理程序去执行，完成后会通过 iret 中断返回指令回到应用程序中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9</span><br><span class="line">mov dx,offset szHello</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>9 为功能号，存放在 ah 中，表示屏幕显示，要输出到屏幕上的内容地址存放在 dx 中，然后调用 int 21h，字符串就会显示在屏幕上，DOS 时代汇编程序员都有一本厚厚的 《中断大全》，因为所有的功能编号包括使用的参数仅从字面上看，是看不出一点头绪来的。另外，80×86 系列处理器最多只能处理 256 个中断，中断数量太少，到最后就会现中断里挂中断，这是非常不好的，所以 API 出现了，win32 系统功能实现放在 Dll 中，我们可以通过 DLL 中的导出表可看出，有三大核心 Dll，分别为 kernel32.dll，gdi32.dll，user32.dll。想一想在 C 语言如何使用一个函数，首先需要先声明，然后就是要这个函数的实现，在 win32 汇编程序中，系统函数声明在 inc 文件中，函数实现在 lib 文件 (静态库) 中，前者由 include 包含，后者由 includelib 包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include 文件名</span><br><span class="line">include &lt;文件名&gt;</span><br><span class="line">includelib 文件名</span><br><span class="line">includelib &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>参照下开头那个示例。那如何调用了，这得使用到另一个伪指令 invoke，为什么会有 invoke 指令，因为在 win32 的 API 中，动不动就是十几个参数，甚至更多，如果都用 push 来写的话，这就非常恐怖了，invoke 正好解决这个问题，参数可写在一行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK</span><br></pre></td></tr></table></figure><p>invoke 为 MASM 编译器的伪指令，在编译的时候由编译器把上面的指令展开成我们需要的 4 个 push 和 1 个 call 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push szText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure><p>函数的返回值存放在 eax 中，如果要返回的内容不是一个 eax 所能容纳的，win32 API 采用的方法一般是 eax 返回一个指向返回数据的指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去。</p><p>最后提一下在汇编下一个 API 函数的声明，比如 MessageBox：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO hWnd:dword,lpText:dword,lpCaption:dword,uType:dword</span><br></pre></td></tr></table></figure><p>可简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox PROTO :dword,:dword,:dword,:dword</span><br></pre></td></tr></table></figure><p>句中 PROTO 是函数声明的伪指令，其实是不存在 MessageBox 的，只存在 MessageBoxA 和 MessageBoxW，在 user32.inc 中有一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox equ &lt;MessageBoxA&gt;</span><br></pre></td></tr></table></figure><p>MessageBoxA 和 MessageBoxW 对应两个字符集，一个是 ANSI，另一个为 UNICODE，每一个 ANSI 字符只占用一个字节宽，每一个 UNICODE 占两个字节宽，对于欧洲语言体系，ANSI 字符集就已经够了，但对于有成千上万个不同字符的几种东方语言体系来说，UNICODE 字符集更有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的-win32-汇编程序&quot;&gt;&lt;a href=&quot;#一个简单的-win32-汇编程序&quot; class=&quot;headerlink&quot; title=&quot;一个简单的 win32 汇编程序&quot;&gt;&lt;/a&gt;一个简单的 win32 汇编程序&lt;/h2&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Assembly-Language-for-x86-Processors-Part03</title>
    <link href="https://zeronohacker.github.io/2018/06/13/Assembly-Language-for-x86-Processors-Part03/"/>
    <id>https://zeronohacker.github.io/2018/06/13/Assembly-Language-for-x86-Processors-Part03/</id>
    <published>2018-06-13T05:11:14.000Z</published>
    <updated>2021-09-19T06:09:19.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是 Kip·Irvine 所写的 Assembly Langrage for x86 Processors (Seventh Edition) 第三章节的小结以及个人对章节编程习题的解答</p></blockquote><p><img src="https://image.zeronohacker.com/article/2018/06/13/acd43387742959dec4bc102af72d3cd2.png" alt=""></p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>整型常量表达式是算术表达式，包括了整数常量、符号常量和算术运算符。优先级是指当表达式有两个或更多运算符时，运算符的隐含顺序。</p><p>字符常量是用引号括起来的单个字符。汇编器把字符转换成一个字节，其中包含的是该字符的二进制 ASCII 码。字符串常量是用引号括起来的字符序列，可以选择用空字节标记结束。</p><p>汇编语言有一组保留字，它们含义特殊且只能用于正确的上下文中。标识符是程序员选择的名称，用于标识变量、符号常量、子程序和代码标号。不能用保留字作标识符。</p><p>伪指令是嵌在源代码中的命令，由汇编器进行转换。指令是源代码语句，由处理器在运行时执行。指令助记符是短关键字，用于标识指令执行的操作。标号是一种标识符，用作指令或数据的位置标记。</p><p>操作数是传递给指令的数据。一条汇编指令有 0 ~ 3 个操作数，每一个都可以是寄存器、内存操作数、整数表达式或输入输出端口号。</p><p>程序包括了逻辑段，名称分别为代码段、数据段和堆栈段。代码段包含了可执行指令；堆栈段包含了子程序参数、局部变量和返回地址；数据段包含了变量。</p><p>源文件包含了汇编语言语句。列表文件包含了程序源代码的副本，再加上行号、偏移地址、翻译的机器代码和符号表，适合打印。源文件用文本编辑器创建。汇编器是一种程序，它读取源文件，并生成目标文件和列表文件。链接器也是一种程序，它读取了一个或多个目标文件，并生成可执行文件。后者由操作系统加载器来执行。</p><p>MASM 识别内容数据类型，每一种类型都描述了一组数值，这些数值能分配给指定类型的变量和表达式：</p><ul><li>BYTE 和 SBYTE 定义 8 位变量</li><li>WORD 和 SWORD 定义 16 位变量</li><li>DWORD 和 SDWORD 定义 32 位变量</li><li>QWORD 和 TBYTE 分别定义 8 字节和 10 字节变量</li><li>REAL4、REAL8 和 REAL10 分别定义 4 字节、8 字节和 10 字节实数变量</li></ul><p>数据定义语句为变量预留内存空间，并可以选择性地给变量分配一个名称。如果一个数据定义有多个初始值，那么它的标号仅指向第一个初始值的偏移量。创建字符串数据定义时，要用引号把字符序列括起来。DUP 运算符用常量表达式作为计数器，生成重复的存储分配。当前地址计数器运算符 ($) 用于地址计算表达式。</p><p>x86 处理器用小端顺序在内存中存取数据：变量的最低有效字节存储在其起始 (最低) 地址中。</p><p>符号常量 (或符号定义) 把标识符与一个整数或文本表达式连接起来。有 3 个伪指令能够定义符号常量：</p><ul><li>等号伪指令 (=) 连接符号名称与整数常量表达式</li><li>EQU 和 TESTEQU 伪指令连接符号与整数常量表达式或一些任意的文本</li></ul><div class="tip "><p>提示：以下编程练习中的答案为本人的解答，并非标准答案，仅供参考。</p></div><h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><span class='p blue'>整数表达式的计算</span><p>参考 3.2 节的程序 AddTwo，编写程序，利用寄存器计算表达式：A = (A + B) – (C – D)。整数值分配给寄存器 EAX、EBX、ECX 和 EDX。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">A_ DWORD 1</span><br><span class="line">B_ DWORD 2</span><br><span class="line">C_ DWORD 3</span><br><span class="line">D_ DWORD 4</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov eax, A_</span><br><span class="line">    mov ebx, B_</span><br><span class="line">    mov ecx, C_</span><br><span class="line">    mov edx, D_</span><br><span class="line">    add eax, ebx</span><br><span class="line">    sub ecx, edx</span><br><span class="line">    sub eax, ecx</span><br><span class="line">    </span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>符号整数常量</span><p>编写程序，为一周七天定义符号常量。创建一个数组变量，用这些符号常量作为其初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">Mon = 1</span><br><span class="line">Tue = 2</span><br><span class="line">Wed = 3</span><br><span class="line">Thu = 4</span><br><span class="line">Fri = 5</span><br><span class="line">Sat = 6</span><br><span class="line">Sun = 7</span><br><span class="line">Week DWORD Mon, Tue, Wed, Thu, Fri, Sat, Sun</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>数据定义</span><p>编写程序，对 3.4 节表 3-2 中列出的每一个数据类型进行定义，并将每个变量都初始化为与其类型一致的数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">; BYTE SBYTE</span><br><span class="line">value1 BYTE &#x27;A&#x27;</span><br><span class="line">value2 BYTE 0</span><br><span class="line">value3 BYTE 255</span><br><span class="line">value4 SBYTE -128</span><br><span class="line">value5 SBYTE 127</span><br><span class="line">; TBYTE</span><br><span class="line">intVal TBYTE 80000000000000001234h</span><br><span class="line">; WORD SWORD</span><br><span class="line">word1 WORD 65535</span><br><span class="line">word2 SWORD -32768</span><br><span class="line">; DWORD SDWORD</span><br><span class="line">dword1 DWORD 12345678h</span><br><span class="line">dword2 SDWORD -2147483648</span><br><span class="line">; FWORD QWORD</span><br><span class="line">fword1 FWORD 123456781234h</span><br><span class="line">qword1 QWORD 1234567812345678h</span><br><span class="line">; REAL4 REAL8 REAL10</span><br><span class="line">reVal1 REAL4 -1.2</span><br><span class="line">reVal2 REAL8 3.2E-260</span><br><span class="line">reVal3 REAL10 4.6E+4096</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><span class='p blue'>符号文本常量</span><p>编写程序，定义几个字符串文本 (引号之间的字符) 的符号名称，并将每个符号名称都用于变量定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">text1 TEXTEQU &lt;&quot;text1&quot;&gt;</span><br><span class="line">text2 TEXTEQU &lt;&quot;test2&quot;&gt;</span><br><span class="line">.data</span><br><span class="line">val1 BYTE text1</span><br><span class="line">val2 BYTE text2</span><br><span class="line">.code</span><br><span class="line">main PROC  </span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END mainv</span><br></pre></td></tr></table></figure><span class='p blue'>AddTwoSum 的列表文件</span><p>生成 AddTwoSum 程序的列表文件，为每条指令机器代码字节编写说明。某些字节值的含义需要猜测。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line"> 00000000.data</span><br><span class="line"> 00000000 00000000sum DWORD 0</span><br><span class="line"> 00000000.code</span><br><span class="line"> 00000000main PROC</span><br><span class="line"> 00000000  B8 00000005    mov eax, 5</span><br><span class="line"> 00000005  83 C0 06    add eax, 6</span><br><span class="line"> 00000008  A3 00000000 R    mov sum, eax</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line"> 0000000D  6A 00   *    push   +000000000h</span><br><span class="line"> 0000000F  E8 00000000 E   *    call   ExitProcess</span><br><span class="line"> 00000014main ENDP</span><br><span class="line">END main</span><br><span class="line">Segments and Groups:</span><br><span class="line">                N a m e                 Size     Length   Align   Combine Class</span><br><span class="line">FLAT . . . . . . . . . . . . . .GROUP</span><br><span class="line">STACK  . . . . . . . . . . . . .32 Bit 00001000 DWord  Stack  &#x27;STACK&#x27; </span><br><span class="line">_DATA  . . . . . . . . . . . . .32 Bit 00000004 DWord  Public  &#x27;DATA&#x27;</span><br><span class="line">_TEXT  . . . . . . . . . . . . .32 Bit 00000014 DWord  Public  &#x27;CODE&#x27;</span><br><span class="line">Procedures, parameters, and locals:</span><br><span class="line">                N a m e                 Type     Value    Attr</span><br><span class="line">ExitProcess  . . . . . . . . . .P Near 00000000 FLATLength= 00000000 External STDCALL</span><br><span class="line">main . . . . . . . . . . . . . .P Near 00000000 _TEXTLength= 00000014 Public STDCALL</span><br><span class="line">Symbols:</span><br><span class="line">                N a m e                 Type     Value    Attr</span><br><span class="line">@CodeSize  . . . . . . . . . . .Number 00000000h   </span><br><span class="line">@DataSize  . . . . . . . . . . .Number 00000000h   </span><br><span class="line">@Interface . . . . . . . . . . .Number 00000003h   </span><br><span class="line">@Model . . . . . . . . . . . . .Number 00000007h   </span><br><span class="line">@code  . . . . . . . . . . . . .Text    _TEXT</span><br><span class="line">@data  . . . . . . . . . . . . .Text    FLAT</span><br><span class="line">@fardata?  . . . . . . . . . . .Text    FLAT</span><br><span class="line">@fardata . . . . . . . . . . . .Text    FLAT</span><br><span class="line">@stack . . . . . . . . . . . . .Text    FLAT</span><br><span class="line">sum  . . . . . . . . . . . . . .DWord 00000000 _DATA</span><br><span class="line">   0 Warnings</span><br><span class="line">   0 Errors</span><br></pre></td></tr></table></figure><p>主要看下以下三条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  B8 00000005       mov eax, 5</span><br><span class="line">00000005  83 C0 06          add eax, 6</span><br><span class="line">00000008  A3 00000000 R    mov sum, eax</span><br></pre></td></tr></table></figure><p>B8 代表 <code>mov ax, immed16</code>；83 C0 猜测与 add 之类有关，这个得去查手册；A3 代表 <code>mov [mem16], ax</code>。</p><span class='p blue'>AddVariables 程序</span><p>修改 AddVariables 程序使其使用 64 位变量。描述汇编器产生的语法错误，并说明为解决这些错误采取的措施。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode: DWORD</span><br><span class="line">.data</span><br><span class="line">firstval DWORD 20002000h</span><br><span class="line">secondval DWORD 11111111h</span><br><span class="line">thirdval DWORD 22222222h</span><br><span class="line">sum DWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov rax, firstval</span><br><span class="line">    add rax, secondval</span><br><span class="line">    add rax, thirdval</span><br><span class="line">    mov sum, rax</span><br><span class="line">    INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined symbol : rax</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExitProcess PROTO</span><br><span class="line">.data</span><br><span class="line">firstval QWORD 20002000h</span><br><span class="line">secondval QWORD 11111111h</span><br><span class="line">thirdval QWORD 22222222h</span><br><span class="line">sum QWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    mov rax, firstval</span><br><span class="line">    add rax, secondval</span><br><span class="line">    add rax, thirdval</span><br><span class="line">    mov sum, rax</span><br><span class="line">    </span><br><span class="line">    mov ecx, 0</span><br><span class="line">    call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是 Kip·Irvine 所写的 Assembly Langrage for x86 Processors (Seventh Edition) 第三章节的小结以及个人对章节编程习题的解答&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/categories/Assembly/"/>
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Python 之禅</title>
    <link href="https://zeronohacker.github.io/2018/04/25/import-this-in-python/"/>
    <id>https://zeronohacker.github.io/2018/04/25/import-this-in-python/</id>
    <published>2018-04-25T04:37:32.000Z</published>
    <updated>2021-09-19T05:38:28.586Z</updated>
    
    <content type="html"><![CDATA[<p>在博主学习 Python 的模块部分中，曾不小心写下了这句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></table></figure></p><p><img src="https://image.zeronohacker.com/article/2018/04/25/b2f60bf633736257e846216fc24d14ac.png" alt=""></p><p>将上述这段话翻译一下，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"> </span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line"><span class="comment"># 优美胜于丑陋（Python以编写优美的代码为目标）</span></span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line"><span class="comment"># 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span></span><br><span class="line">Simple <span class="keyword">is</span> better than <span class="built_in">complex</span>.</span><br><span class="line"><span class="comment"># 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span></span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line"><span class="comment"># 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span></span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line"><span class="comment"># 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span></span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line"><span class="comment"># 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span></span><br><span class="line">Readability counts.</span><br><span class="line"><span class="comment"># 可读性很重要（优美的代码是可读的）</span></span><br><span class="line">Special cases aren’t special enough to <span class="keyword">break</span> the rules.Although practicality beats purity.</span><br><span class="line"><span class="comment"># 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span></span><br><span class="line">Errors should never <span class="keyword">pass</span> silently.Unless explicitly silenced.</span><br><span class="line"><span class="comment"># 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span></span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line"><span class="comment"># 当存在多种可能，不要尝试去猜测</span></span><br><span class="line">There should be one– <span class="keyword">and</span> preferably only one –obvious way to do it.</span><br><span class="line"><span class="comment"># 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span></span><br><span class="line">Although that way may <span class="keyword">not</span> be obvious at first unless you’re Dutch</span><br><span class="line"><span class="comment"># 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）</span></span><br><span class="line">Now <span class="keyword">is</span> better than never.Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line"><span class="comment"># 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span></span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it’s a bad idea.If the implementation <span class="keyword">is</span> easy to explain, it may be a good idea.</span><br><span class="line"><span class="comment"># 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span></span><br><span class="line">Namespaces are one honking great idea — let’s do more of those!</span><br><span class="line"><span class="comment"># 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在博主学习 Python 的模块部分中，曾不小心写下了这句：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pr</summary>
      
    
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
