<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>x64 进程注入技术 —— NINA | zeronohacker</title><meta name="keywords" content="NINI,Inject"><meta name="author" content="zeronohacker"><meta name="copyright" content="zeronohacker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文翻译自：https:&#x2F;&#x2F;undev.ninja&#x2F;nina-x64-process-injection&#x2F;  前述在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，Que">
<meta property="og:type" content="article">
<meta property="og:title" content="x64 进程注入技术 —— NINA">
<meta property="og:url" content="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/index.html">
<meta property="og:site_name" content="zeronohacker">
<meta property="og:description" content="本文翻译自：https:&#x2F;&#x2F;undev.ninja&#x2F;nina-x64-process-injection&#x2F;  前述在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，Que">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg">
<meta property="article:published_time" content="2020-06-05T10:04:25.000Z">
<meta property="article:modified_time" content="2021-09-19T11:17:39.408Z">
<meta property="article:author" content="zeronohacker">
<meta property="article:tag" content="NINA">
<meta property="article:tag" content="Inject">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg"><link rel="shortcut icon" href="https://image.zeronohacker.com/favicon.png"><link rel="canonical" href="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'x64 进程注入技术 —— NINA',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-19 19:17:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="zeronohacker" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://image.zeronohacker.com/header.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zeronohacker</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">x64 进程注入技术 —— NINA</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-06-05T10:04:25.000Z" title="undefined 2020-06-05 18:04:25">2020-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">安全技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="x64 进程注入技术 —— NINA"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文翻译自：<a target="_blank" rel="noopener" href="https://undev.ninja/nina-x64-process-injection/">https://undev.ninja/nina-x64-process-injection/</a></p>
</blockquote>
<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>在本文中，我将详细介绍一种实验性的进程注入技术，其中对比较通用的和“危险”函数使用施加了严格的限制，即 <strong>WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。 我称这种技术为 NINA：No Injection，No Allocation。 该技术的目的是为了通过减少可疑的 call 数量而不需要复杂的 ROP 链进而达到更加的隐蔽效果。 PoC 可以在这里找到：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NtRaiseHardError/NINA">https://github.com/NtRaiseHardError/NINA</a></p>
<p>测试环境：</p>
<ul>
<li>Windows 10 x64 version 2004</li>
<li>Windows 10 x64 version 1903</li>
</ul>
<h2 id="实现-No-Injection"><a href="#实现-No-Injection" class="headerlink" title="实现 No Injection"></a>实现 No Injection</h2><p>让我们从移除需要注入的数据这种情况开始。最基本的进程注入所需要的操作：</p>
<ul>
<li>包含 payload 的目标地址；</li>
<li>将 payload 传递给目标进程；</li>
<li>执行操作以执行 payload；</li>
</ul>
<p>为了将重点放在 No Injection 部分，我将使用经典的 VirtualAllocEx 在远程进程中分配内存。 重要的是要防止页面同时具有写和执行权限，因此应首先设置 RW，然后在写入数据后用 RX 重新保护。 由于我稍后将讨论 No Allocation 方法，因此我们现在可以将页面设置为 RWX，以使事情变得简单。</p>
<p>如果我们限制自己不使用数据注入，则意味着恶意进程不会使用 WriteProcessMemory 将数据直接从自身传输到目标进程。 为了解决这个问题，我受到Deep Instinct（复杂）“Inject Me”进程注入技术（由 @slaeryan 分享）记录的反向 ReadProcessMemory 的启发。 还有其他将数据传递到进程的方法：使用 GlobalGetAtomName（来自 Atom Bombing 技术），以及通过命令行选项或环境变量传递数据（使用 CreateProcess 调用来生成目标进程）。 但是，这三种方法有一个小的限制，那就是 payload 不得包含 NULL 字符。 Ghost Writing 也许是一种选择，但它需要复杂的 ROP 链。</p>
<p>为了得到执行，我选择了 SetThreadContext 函数的线程劫持技术，因为我们不能使用 <strong>CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread</strong>。</p>
<p>下面是大体的一个过程：</p>
<ul>
<li>CreateProcess 生成目标进程；</li>
<li>VirtualAllocEx 为 payload 和堆栈分配内存；</li>
<li>SetThreadContext 强制目标进程执行 ReadProcessMemory；</li>
<li>SetThreadContext 执行 payload；</li>
</ul>
<h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><p>使用这种注入技术时应考虑一些注意事项。 第一个是来自 CreateProcess 的调用。 尽管此技术不依赖于 CreateProcess，但出于某些原因，使用它代替诸如 OpenProcess 或 OpenThread 之类的方法可能更有利。 原因之一是，没有远程（外部）进程访问权限来获取句柄，否则这些句柄可能会被使用ObRegisterCallbacks 的监视工具（例如 Sysmon）检测到。 另一个原因是，它允许使用命令行和环境变量进行上述两种数据注入方法。 如果您正在创建进程，则还可以利用 <a target="_blank" rel="noopener" href="https://blog.xpnsec.com/protecting-your-malware/">blockdll 和 ACG</a> 来击败防病毒用户模式下 HOOK。</p>
<h3 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h3><p>当然，目标进程需要能够容纳 payload，但是此技术还需要堆栈。 这将很快阐明。</p>
<h3 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h3><p>要以相反的方式使用此功能，我们必须考虑两个问题：在堆栈上传递 5 个参数，并对我们自己的恶意进程使用有效的进程句柄。 让我们先来看第 5 个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  *lpNumberOfBytesRead</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用 SetThreadContext 仅允许在 x64 上使用前四个参数。 如果我们阅读 lpNumberOfBytesRead 的描述，我们可以看到它是可选的：</p>
<div class="tip "><p>指向变量的指针，该变量接收传输到指定缓冲区的字节数， 如果 lpNumberOfBytesRead 为 NULL，则忽略该参数。</p>
</div>
<p>幸运的是，如果我们使用 VirtualAllocEx 创建页面，该函数会将它们归 0：</p>
<div class="tip "><p>在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态， 该函数将其分配的内存初始化为 0。</p>
</div>
<p>将堆栈设置为 0 分配的页面将使得第 5 个参数有效。</p>
<p>第二个问题是传递给 ReadProcessMemory 的进程句柄。 因为我们正试图让目标进程读取我们的恶意进程，所以我们需要为其提供处理程序的句柄。 这可以使用 DuplicateHandle 函数来实现。 它会被赋予我们当前进程句柄，并返回一个可以被目标进程使用的句柄。</p>
<h3 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h3><p>SetThreadContext 是强大而灵活的功能，它允许读取，写入和执行。 但是，使用它传递 fastcall 参数存在一个已知问题：易失性寄存器 RCX，RDX，R8 和 R9 无法可靠地设置为所需值。考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to read shellcode</span></span><br><span class="line"><span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    <span class="comment">// Target thread</span></span><br><span class="line">    &amp;TargetThread,</span><br><span class="line">    <span class="comment">// Set RIP to read our shellcode</span></span><br><span class="line">    _ReadProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to stack</span></span><br><span class="line">    StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Handle to our own process to read shellcode</span></span><br><span class="line">    TargetProcess,</span><br><span class="line">    <span class="comment">// RDX: Address to read from</span></span><br><span class="line">    &amp;Shellcode,</span><br><span class="line">    <span class="comment">// R8: Buffer to store shellcode</span></span><br><span class="line">    TargetBuffer,</span><br><span class="line">    <span class="comment">// R9: Size to read</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果执行此代码，我们期望当目标线程到达 ReadProcessMemory 时，易失性寄存器将保持其正确的值。但是，这不是实际发生的情况：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/CA9DFE2D9145CECD6F71BB5D689CDEF4.png" alt=""></p>
<p>由于某些未知的原因，易失性寄存器被更改，使该技术无法使用。 RCX 不是进程的有效句柄，RDX 为 0，R9 太大。 我发现一种方法可以可靠地设置易失性寄存器：在使用 SetThreadContext 之前，只需将 RIP 设置为无限 jmp -2 循环即可。 让我们来看看它的作用：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/7BAF12FF23B954527B4D2C75D76C46EF.png" alt=""></p>
<p>可以使用 SetThreadContext 执行无限循环，然后可以使用正确的易失性寄存器调用 ReadProcessMemory：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/A6000B5907CB4BE65EB45AB86CF3F805.png" alt=""></p>
<p>现在我们需要处理返回。 请注意，我们已分配并转至我们自己的堆栈。 如果我们可以使用 ReadProcessMemory 将 Shellcode 读入 RSP 的堆栈位置，则可以设置 Shellcode 的前 8 个字节，以便它重新回到自身。 这是一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to Shellcode + 8</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/420994740F05B40711840E38FCA670AA.png" alt=""></p>
<p>RSP 和 R8 指向 000001F457C21000。 向上的地址将用于 ReadProcessMemory 调用中的堆栈。 将要写入 Shellcode 的目标缓冲区从 R8 向下。 当 ReadProcessMemory 返回时，它将使用 shellcode 的前 8 个字节作为实际 shellcode 起始处的 000001F457C21008 的返回地址：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/39788EDE3F4EA6FFEF7F7CFF5C75109B.png" alt=""></p>
<h2 id="实现：No-Allocation"><a href="#实现：No-Allocation" class="headerlink" title="实现：No Allocation"></a>实现：No Allocation</h2><p>现在让我们讨论如何通过移除对 VirtualAllocEx 的依赖来进行改进。 这与上一节相比并不那么琐碎，因为会出现一些初始问题：</p>
<ul>
<li>我们如何为 ReadProcessMemory 设置堆栈</li>
<li>如果没有 RWX 节，如何使用 ReadProcessMemory 编写和执行 Shellcode</li>
</ul>
<p>但是，为什么要在已经可以使用的内存中分配内存呢？ 请记住，如果内存中的任何现有页面都受到影响，则应注意不要覆盖任何关键数据（如果应恢复原始执行流程）。</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>如果我们无法为堆栈分配内存，则可以找到一个空白的 RW 页面来使用。如果担心 ReadProcessMemory 的第 5 个参数为 NULL，则可以轻松解决。 如果我们不想覆盖潜在的关键数据，则可以利用可执行映像内可能的 RW 页面内的节填充。 当然，这假定存在可用的填充。</p>
<p>要在可执行映像的内存范围内定位 RW 页面，我们可以通过进程环境块（PEB）定位映像的基址，然后使用 VirtualQueryEx 枚举范围。 此函数将返回诸如保护及其大小之类的信息，这些信息可用于查找任何现有的 RW 页面，以及它们的大小是否适合 Shellcode。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get PEB.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInformation,</span><br><span class="line">    &amp;ProcessBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESS_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get image base.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ProcessBasicInfo.PebBaseAddress,</span><br><span class="line">    &amp;Peb,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(PEB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    ImageBaseAddress = Peb.Reserved3[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get DOS header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ImageBaseAddress,</span><br><span class="line">    &amp;DosHeader,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_DOS_HEADER),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get NT headers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    (LPBYTE)ImageBaseAddress + DosHeader.e_lfanew,</span><br><span class="line">    &amp;NtHeaders,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_NT_HEADERS),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look for existing memory pages inside the executable image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = <span class="number">0</span>; i &lt; NtHeaders.OptionalHeader.SizeOfImage; i += MemoryBasicInfo.RegionSize) &#123;</span><br><span class="line">    <span class="built_in">VirtualQueryEx</span>(</span><br><span class="line">        ProcessHandle,</span><br><span class="line">        (LPBYTE)ImageBaseAddress + i,</span><br><span class="line">        &amp;MemoryBasicInfo,</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(MEMORY_BASIC_INFORMATION)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Search for a RW region to act as the stack.</span></span><br><span class="line">    <span class="comment">// Note: It&#x27;s probably ideal to look for a RW section </span></span><br><span class="line">    <span class="comment">// inside the executable image memory pages because</span></span><br><span class="line">    <span class="comment">// the padding of sections suits the fifth, optional</span></span><br><span class="line">    <span class="comment">// argument for ReadProcessMemory and WriteProcessMemory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (MemoryBasicInfo.Protect &amp; PAGE_READWRITE) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Stack location in RW page starting at the bottom.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到正确的页面后，应从页面底部向上枚举堆栈的位置（由于堆栈的性质），并且应该为 ReadProcessMemory 的第五个参数找到一个 0x0000000000000000 的值。 这意味着我们需要确保堆栈偏移量距底部加 Shellcode 的空间至少为 0x28。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                   +--------------+</span><br><span class="line">                   |     ...      |</span><br><span class="line">                   +--------------+ -0x30</span><br><span class="line">    Should be 0 -&gt; |     arg5     |</span><br><span class="line">                   +--------------+ -0x28</span><br><span class="line">                   |     arg4     |</span><br><span class="line">                   +--------------+ -0x20</span><br><span class="line">                   |     arg3     |</span><br><span class="line">                   +--------------+ -0x18</span><br><span class="line">                   |     arg2     |</span><br><span class="line">                   +--------------+ -0x10</span><br><span class="line">                   |     arg1     |</span><br><span class="line">                   +--------------+ -0x8</span><br><span class="line">                   |     ret      |</span><br><span class="line">                   +--------------+ 0x0</span><br><span class="line">                   |   Shellcode  |</span><br><span class="line">Bottom of stack -&gt; +--------------+ </span><br></pre></td></tr></table></figure>
<p>下面是一些演示代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate a stack to read a local copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Stack = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, AddressSize);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scan stack for NULL fifth arg</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Success = <span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    Address,</span><br><span class="line">    Stack,</span><br><span class="line">    AddressSize,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enumerate from bottom (it&#x27;s a stack).</span></span><br><span class="line"><span class="comment">// Start from -5 * 8 =&gt; at least five arguments + shellcode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (SIZE_T i = AddressSize - <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T) - <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode); i &gt; <span class="number">0</span>; i -= <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T)) &#123;</span><br><span class="line">    ULONG_PTR* StackVal = (ULONG_PTR*)((LPBYTE)Stack + i);</span><br><span class="line">    <span class="keyword">if</span> (*StackVal == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Get stack offset.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        *StackOffset = i + <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(SIZE_T);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果可执行文件的模块内没有 RW 页面，则可以执行后备操作以写入堆栈。 要查找远程进程的堆栈，我们可以执行以下操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NtQueryInformationThread</span>(</span><br><span class="line">    ThreadHandle,</span><br><span class="line">    ThreadBasicInformation,</span><br><span class="line">    &amp;ThreadBasicInfo,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(THREAD_BASIC_INFORMATION),</span><br><span class="line">    &amp;ReturnLength</span><br><span class="line">);</span><br><span class="line"><span class="built_in">ReadProcessMemory</span>(</span><br><span class="line">    ProcessHandle,</span><br><span class="line">    ThreadBasicInfo.TebBaseAddress,</span><br><span class="line">    &amp;Tib,</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(NT_TIB),</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get stack offset.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>Tib 中的结果将包含堆栈范围地址。 有了这些值，我们可以在使用代码之前从堆栈底部开始定位适当的偏移量。</p>
<h3 id="写入-ShellCode"><a href="#写入-ShellCode" class="headerlink" title="写入 ShellCode"></a>写入 ShellCode</h3><p>No Allocation 的主要问题是我们必须编写 ShellCode，然后在同一页面中执行它。 有一种方法可以不使用 VirtualProtectEx 或具有此特殊功能的复杂 ROP 链：WriteProcessMemory。 好的，我确实说过我们不能使用 WriteProcessMemory 将数据从我们的进程写入目标，但是我没有说我们不能强迫目标进程自己使用它。WriteProcessMemory 内部的隐藏机制之一是，它将相应地重新保护目标缓冲区的页面以执行写操作。 在这里，我们看到使用 NtQueryVirtualMemory 查询目标缓冲区的页面：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/8AB2CE60AFE4B834E457A8949860FF1E.png" alt=""></p>
<p>然后使用 NtProtectVirtualMemory 对页面进行写保护：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/B029BE46925D6AE3531CE2FED28FC700.png" alt=""></p>
<p>如果您已经注意到，WriteProcessMemory 会在函数开始时修改 shadow 堆栈。 在这种情况下，我们需要修改 ShellCode 以填充 shadow 堆栈：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BYTE Shellcode[] = &#123;</span><br><span class="line">    <span class="comment">// Placeholder for ret from ReadProcessMemory to infinte jmp loop.</span></span><br><span class="line">    <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>,</span><br><span class="line">    <span class="comment">// Pad for shadow stack.</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Shellcode starts here at Shellcode + 0x30...</span></span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xFE</span>, <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xBB</span>, <span class="number">0xCC</span>, <span class="number">0xDD</span>, <span class="number">0xEE</span>, <span class="number">0xFF</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们需要依次调用 ReadProcessMemory 和 WriteProcessMemory。 回到 ReadProcessMemory 的返回中，我们可以简单地跳回到无限 jmp 循环小工具以暂停执行，而不是停止执行 ShellCode（现在位于不可执行的页面）：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/0F7ADBEDB8FC310D3D736DE63C7DF705.png" alt=""></p>
<p>这使得恶意进程有时间调用另一个 SetThreadContext 将 RIP 设置为 WriteProcessMemory 并重用 ReadProcessMemory 中的 RSP。 我们可以从 ReadProcessMemory 复制的同一位置读取 ShellCode（将 0x30 字节复制到实际的 ShellCode），然后将具有执行许可权的任何页面作为目标（同样，假设有 RX 节）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get target process to write the shellcode</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set rip to read our shellcode</span></span><br><span class="line">    &amp;_WriteProcessMemory,</span><br><span class="line">    <span class="comment">// RSP points to same stack offset</span></span><br><span class="line">    &amp;StackLocation,</span><br><span class="line">    <span class="comment">// RCX: Target process&#x27; own handle</span></span><br><span class="line">    (HANDLE)<span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// RDX: Buffer to store shellcode</span></span><br><span class="line">    ShellcodeLocation,</span><br><span class="line">    <span class="comment">// R8: Address to write from</span></span><br><span class="line">    (LPBYTE)StackLocation + <span class="number">0x30</span>,</span><br><span class="line">    <span class="comment">// R9: size to write</span></span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(Shellcode) - <span class="number">0x30</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当 WriteProcessMemory 返回时，它应再次返回到无限 jmp 循环，从而允许恶意进程对 SetThreadContext 进行最终调用以执行 ShellCode：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the shellcodez</span></span><br><span class="line">Success = <span class="built_in">SetExecutionContext</span>(</span><br><span class="line">    &amp;ThreadHandle,</span><br><span class="line">    <span class="comment">// Set RIP to execute shellcode</span></span><br><span class="line">    &amp;ShellcodeLocation,</span><br><span class="line">    <span class="comment">// RSP is optional</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// Arguments to shellcode are optional</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>总体而言，整个注入过程如下：</p>
<ol>
<li>将 SetThreadContext 设置为无限的 jmp 循环，以允许 SetThreadContext 可靠地使用易失性寄存器；</li>
<li>找到一个有效的 RW 堆栈（或伪堆栈）以承载 ReadProcessMemory 和 WriteProcessMemory 参数以及临时的 ShellCode；</li>
<li>使用 DuplicateHandle 为目标进程注册一个重复的句柄，以从恶意进程中读取 ShellCode；</li>
<li>使用 SetThreadContext 调用 ReadProcessMemory 复制 ShellCode；</li>
<li>在 ReadProcessMemory 之后返回无限 jmp 循环；</li>
<li>使用 SetThreadContext 调用 WriteProcessMemory 将 ShellCode 复制到 RX 页面；</li>
<li>在 WriteProcessMemory 之后返回无限 jmp 循环；</li>
<li>使用 SetThreadContext 调用 ShellCode；</li>
</ol>
<h2 id="关于检测"><a href="#关于检测" class="headerlink" title="关于检测"></a>关于检测</h2><p>为了快速测试隐蔽性能，我使用了两个工具：hasherazade 的 PE-sieve 和 Sysinternal 的 Sysmon。 如果还有其他防御性监视工具，我很想看看这种技术与它们对抗的能力。</p>
<h3 id="PE-sieve"><a href="#PE-sieve" class="headerlink" title="PE-sieve"></a>PE-sieve</h3><p>我在玩 PE-sieve 时注意到的一点是，如果我们将 ShellCode 注入到 .text（或其他相关部分）的填充中，则根本不会检测到它：</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/FC5498FEF7E65DEFE01AAA575815E383.png" alt=""></p>
<p>如果 ShellCode 太大而无法填充，则另一个模块可能包含更大的空间。</p>
<h3 id="Sysmon-事件"><a href="#Sysmon-事件" class="headerlink" title="Sysmon 事件"></a>Sysmon 事件</h3><p>这些是使用 CreateProcess 调用而不是 OpenProcess 生成目标进程的预期结果。其他需要注意的是，DuplicateHandle 调用可能会触发 Sysmon 中 ObRegisterCallbacks 的进程句柄事件。并非如此，因为如果拥有相同句柄的进程执行了句柄访问，则 Sysmon 不会跟随该事件。 对于 AV 或 EDR，可能有所不同。</p>
<p><img src="https://image.zeronohacker.com/article/2020/06/05/CE95F26A8415571143CB56743893016F.png" alt=""></p>
<h3 id="进一步改进"><a href="#进一步改进" class="headerlink" title="进一步改进"></a>进一步改进</h3><p>自从我真正着手完成这个（副项目）项目以来，我不会怀疑可能会忽略一些问题 – 我只需要探索这个想法，看看我能走多远。 关于恢复被劫持线程的执行，有可能并且我已经在 PoC 中实现了它，但是它取决于恶意进程，这可能是好事，也可能不是好事。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因此，有可能不使用恶意进程中的 WriteProcessMemory，VirtualAllocEx，VirtualProtectEx，CreateRemoteThread，NtCreateThreadEx，QueueUserApc 和 NtQueueApcThread 来注入远程进程。 OpenProcess 和 OpenThread 的用法仍然值得商榷，因为有时使用 CreateProcess 生成目标进程并不总是这种情况。但是，它确实消除了许多可疑 call，这是此技术的目标。</p>
<p>由于 SetThreadContext 是一个如此强大的原始函数，并且对该函数和其他许多隐秘技术至关重要，因此是否会对此进行更多关注？ 从我所看到的，Microsoft-Windows-Kernel-Audit-API-Calls ETW 提供程序中已经有可用的本机 Windows 日志记录。 我有兴趣了解进程注入的未来 …</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zeronohacker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/">https://zeronohacker.github.io/2020/06/05/nina-x64-process-injection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zeronohacker.github.io" target="_blank">zeronohacker</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NINA/">NINA</a><a class="post-meta__tags" href="/tags/Inject/">Inject</a></div><div class="post_share"><div class="social-share" data-image="https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/31/maldoc-uses-windows-api-to-perform-process-hollowing/"><img class="prev-cover" src="https://image.zeronohacker.com/top_img/2020/08/31/securityrisks1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">恶意文档使用 Windows API 进行 Process hollowing</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/31/make-yara-syntax-highlighting-in-notepad-plus-plus/"><img class="next-cover" src="https://image.zeronohacker.com/top_img/2020/05/31/116-11_800x.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Notepad++ 中让 Yara 语法高亮</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://image.zeronohacker.com/header.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zeronohacker</div><div class="author-info__description">There is no absolutely safe system in the world!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zeronohacker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://twitter.com/zeronohacker" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="mailto:zeronohacker@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://zeronohacker.github.io/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">前述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-No-Injection"><span class="toc-number">2.</span> <span class="toc-text">实现 No Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateProcess"><span class="toc-number">2.1.</span> <span class="toc-text">CreateProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtualAllocEx"><span class="toc-number">2.2.</span> <span class="toc-text">VirtualAllocEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadProcessMemory"><span class="toc-number">2.3.</span> <span class="toc-text">ReadProcessMemory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SetThreadContext"><span class="toc-number">2.4.</span> <span class="toc-text">SetThreadContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9ANo-Allocation"><span class="toc-number">3.</span> <span class="toc-text">实现：No Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5-ShellCode"><span class="toc-number">3.2.</span> <span class="toc-text">写入 ShellCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%A3%80%E6%B5%8B"><span class="toc-number">4.</span> <span class="toc-text">关于检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE-sieve"><span class="toc-number">4.1.</span> <span class="toc-text">PE-sieve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sysmon-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">Sysmon 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E8%BF%9B"><span class="toc-number">4.3.</span> <span class="toc-text">进一步改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">5.</span> <span class="toc-text">结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/13/wmi-registry-part-3/" title="WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)"><img src="https://image.zeronohacker.com/top_img/2021/09/13/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)"/></a><div class="content"><a class="title" href="/2021/09/13/wmi-registry-part-3/" title="WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)">WMI 攻击手法研究 - 与 Windows 注册表交互 (第三部分)</a><time datetime="2021-09-13T14:46:41.000Z" title="发表于 2021-09-13 22:46:41">2021-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/07/wmi-classes-methods-part-2/" title="WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)"><img src="https://image.zeronohacker.com/top_img/2021/09/07/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)"/></a><div class="content"><a class="title" href="/2021/09/07/wmi-classes-methods-part-2/" title="WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)">WMI 攻击手法研究 - 探索命名空间、类和方法 (第二部分)</a><time datetime="2021-09-07T14:35:33.000Z" title="发表于 2021-09-07 22:35:33">2021-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/wmi-basics-part-1/" title="WMI 攻击手法研究 - 基础篇 (第一部分)"><img src="https://image.zeronohacker.com/top_img/2021/08/31/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WMI 攻击手法研究 - 基础篇 (第一部分)"/></a><div class="content"><a class="title" href="/2021/08/31/wmi-basics-part-1/" title="WMI 攻击手法研究 - 基础篇 (第一部分)">WMI 攻击手法研究 - 基础篇 (第一部分)</a><time datetime="2021-08-31T14:25:57.000Z" title="发表于 2021-08-31 22:25:57">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/30/decoding-malious-powershell-activity-a-case-study/" title="从一个恶意活动中学习 PowerShell 解码"><img src="https://image.zeronohacker.com/top_img/2021/03/30/4-0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从一个恶意活动中学习 PowerShell 解码"/></a><div class="content"><a class="title" href="/2021/03/30/decoding-malious-powershell-activity-a-case-study/" title="从一个恶意活动中学习 PowerShell 解码">从一个恶意活动中学习 PowerShell 解码</a><time datetime="2021-03-30T13:50:59.000Z" title="发表于 2021-03-30 21:50:59">2021-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/22/how-to-use-vs2019-to-compile-assembly-and-win32-assembler-under-win10/" title="在 Win10 下如何用 VS2019 编译汇编及 win32 汇编程序"><img src="https://image.zeronohacker.com/top_img/2021/02/22/nzslbk8moxt_2a7a18ugpk4azxq.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在 Win10 下如何用 VS2019 编译汇编及 win32 汇编程序"/></a><div class="content"><a class="title" href="/2021/02/22/how-to-use-vs2019-to-compile-assembly-and-win32-assembler-under-win10/" title="在 Win10 下如何用 VS2019 编译汇编及 win32 汇编程序">在 Win10 下如何用 VS2019 编译汇编及 win32 汇编程序</a><time datetime="2021-02-22T13:42:22.000Z" title="发表于 2021-02-22 21:42:22">2021-02-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://image.zeronohacker.com/top_img/2020/06/05/hacker-injecting-code.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By zeronohacker</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img class="icp-icon" src="https://image.zeronohacker.com/icp.png"><span>赣ICP备20006890号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>